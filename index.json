{
  "Guides/Sync/SyncSortedSet.html": {
    "href": "Guides/Sync/SyncSortedSet.html",
    "title": "SyncSortedSet",
    "keywords": "SyncSortedSet SyncSortedSet are sets similar to C# SortedSet<T> that synchronize their contents from the server to the clients. Unlike SyncHashSets, all elements in a SyncSortedSet are sorted when they are inserted. Please note this has some performance implications. A SyncSortedSet can contain any supported mirror type Usage Create a class that derives from SyncSortedSet for your specific type. This is necessary because Mirror will add methods to that class with the weaver. Then add a SyncSortedSet field to your NetworkBehaviour class. For example: class Player : NetworkBehaviour { class SyncSkillSet : SyncSortedSet<string> {} readonly SyncSkillSet skills = new SyncSkillSet(); int skillPoints = 10; [Command] public void CmdLearnSkill(string skillName) { if (skillPoints > 1) { skillPoints--; skills.Add(skillName); } } } You can also detect when a SyncSortedSet changes. This is useful for refreshing your character in the client or determining when you need to update your database. Subscribe to the Callback event typically during Start , OnClientStart or OnServerStart for that. Note that by the time you subscribe, the set will already be initialized, so you will not get a call for the initial data, only updates. Note SyncSets must be initialized in the constructor, not in Startxxx(). You can make them readonly to ensure correct usage. class Player : NetworkBehaviour { class SyncSetBuffs : SyncSortedSet<string> {}; readonly SyncSetBuffs buffs = new SyncSetBuffs(); // this will add the delegate on the client. // Use OnStartServer instead if you want it on the server public override void OnStartClient() { buffs.Callback += OnBuffsChanged; } void OnBuffsChanged(SyncSetBuffs.Operation op, string buff) { switch (op) { case SyncSetBuffs.Operation.OP_ADD: // we added a buff, draw an icon on the character break; case SyncSetBuffs.Operation.OP_CLEAR: // clear all buffs from the character break; case SyncSetBuffs.Operation.OP_REMOVE: // We removed a buff from the character break; } } }"
  },
  "Guides/Sync/SyncDictionary.html": {
    "href": "Guides/Sync/SyncDictionary.html",
    "title": "SyncDictionary",
    "keywords": "SyncDictionary A SyncDictionary is an associative array containing an unordered list of key, value pairs. Keys and values can be of the following types: Basic type (byte, int, float, string, UInt64, etc) Built-in Unity math type (Vector3, Quaternion, etc) NetworkIdentity Game object with a NetworkIdentity component attached. Struct with any of the above SyncDictionary works much like SyncLists : when you make a change on the server the change is propagated to all clients and the Callback is called. To use it, create a class that derives from SyncDictionary for your specific type. This is necessary because the Weaver will add methods to that class. Then add a field to your NetworkBehaviour class. Note that by the time you subscribe to the callback, the dictionary will already be initialized, so you will not get a call for the initial data, only updates. Note SyncDictionaries must be initialized in the constructor, not in Startxxx(). You can make them readonly to ensure correct usage. Simple Example using UnityEngine; using Mirror; public class ExamplePlayer : NetworkBehaviour { public class SyncDictionaryStringItem : SyncDictionary<string, Item> {} public struct Item { public string name; public int hitPoints; public int durability; } public readonly SyncDictionaryStringItem Equipment = new SyncDictionaryStringItem(); public override void OnStartServer() { Equipment.Add(\"head\", new Item { name = \"Helmet\", hitPoints = 10, durability = 20 }); Equipment.Add(\"body\", new Item { name = \"Epic Armor\", hitPoints = 50, durability = 50 }); Equipment.Add(\"feet\", new Item { name = \"Sneakers\", hitPoints = 3, durability = 40 }); Equipment.Add(\"hands\", new Item { name = \"Sword\", hitPoints = 30, durability = 15 }); } public override void OnStartClient() { // Equipment is already populated with anything the server set up // but we can subscribe to the callback in case it is updated later on Equipment.Callback += OnEquipmentChange; } void OnEquipmentChange(SyncDictionaryStringItem.Operation op, string key, Item item) { // equipment changed, perhaps update the gameobject Debug.Log(op + \" - \" + key); } } By default, SyncDictionary uses a Dictionary to store it's data. If you want to use a different IDictionary implementation such as SortedList or SortedDictionary , add a constructor to your SyncDictionary implementation and pass a dictionary to the base class. For example: public class ExamplePlayer : NetworkBehaviour { public class SyncDictionaryStringItem : SyncDictionary<string, Item> { public SyncDictionaryStringItem() : base (new SortedList<string,Item>()) {} } public readonly SyncDictionaryStringItem Equipment = new SyncDictionaryStringItem(); }"
  },
  "Guides/Sync/SyncLists.html": {
    "href": "Guides/Sync/SyncLists.html",
    "title": "SyncLists",
    "keywords": "SyncLists SyncLists are array based lists similar to C# List<T> that synchronize their contents from the server to the clients. A SyncList can contain any supported mirror type . Differences with HLAPI HLAPI also supports SyncLists, but we have redesigned them to better suit our needs. Some of the key differences include: In HLAPI, SyncLists were synchronized immediately when they changed. If you add 10 elements, that means 10 separate messages. Mirror synchronizes SyncLists with the SyncVars. The 10 elements and other SyncVars are batched together into a single message. Mirror also respects the sync interval when synchronizing lists. In HLAPI if you want a list of structs, you have to use SyncListStruct<MyStructure> , we changed it to just SyncList<MyStructure> In HLAPI the Callback is a delegate. In Mirror we changed it to an event, so that you can add many subscribers. In HLAPI the Callback tells you the operation and index. In Mirror, the callback also receives an item. We made this change so that we could tell what item was removed. Usage Create a class that derives from SyncList for your specific type. This is necessary because Mirror will add methods to that class with the weaver. Then add a SyncList field to your NetworkBehaviour class. For example: public struct Item { public string name; public int amount; public Color32 color; } class SyncListItem : SyncList<Item> {} class Player : NetworkBehaviour { readonly SyncListItem inventory = new SyncListItem(); public int coins = 100; [Command] public void CmdPurchase(string itemName) { if (coins > 10) { coins -= 10; Item item = new Item { name = \"Sword\", amount = 3, color = new Color32(125, 125, 125, 255) }; // during next synchronization, all clients will see the item inventory.Add(item); } } } There are some ready made SyncLists you can use: SyncListString SyncListFloat SyncListInt SyncListUInt SyncListBool You can also detect when a SyncList changes in the client or server. This is useful for refreshing your character when you add equipment or determining when you need to update your database. Subscribe to the Callback event typically during Start , OnClientStart , or OnServerStart for that. Note that by the time you subscribe, the list will already be initialized, so you will not get a call for the initial data, only updates. Note SyncLists must be initialized in the constructor, not in Startxxx(). You can make them readonly to ensure correct usage. class Player : NetworkBehaviour { readonly SyncListItem inventory = new SyncListItem(); // this will add the delegates on both server and client. // Use OnStartClient instead if you just want the client to act upon updates void Start() { inventory.Callback += OnInventoryUpdated; } void OnInventoryUpdated(SyncListItem.Operation op, int index, Item oldItem, Item newItem) { switch (op) { case SyncListItem.Operation.OP_ADD: // index is where it got added in the list // item is the new item break; case SyncListItem.Operation.OP_CLEAR: // list got cleared break; case SyncListItem.Operation.OP_INSERT: // index is where it got added in the list // item is the new item break; case SyncListItem.Operation.OP_REMOVE: // index is where it got removed in the list // item is the item that was removed break; case SyncListItem.Operation.OP_REMOVEAT: // index is where it got removed in the list // item is the item that was removed break; case SyncListItem.Operation.OP_SET: // index is the index of the item that was updated // item is the previous item break; case SyncListItem.Operation.OP_DIRTY: // index is the index of the item that was updated // item is the previous item break; } } } By default, SyncList uses a List to store it's data. If you want to use a different list implementation, add a constructor and pass the list implementation to the parent constructor. For example: class SyncListItem : SyncList<Item> { public SyncListItem() : base(new MyIList<Item>()) {} }"
  },
  "Guides/DevServer/AWS/index.html": {
    "href": "Guides/DevServer/AWS/index.html",
    "title": "Amazon Web Services (AWS)",
    "keywords": "Amazon Web Services (AWS) During this section we will focus on using a Windows instance and connecting from a Windows computer. NOTE : AWS requires a payment method/credit card added before being able to use a Windows server. Don't forget to read up on the free tier limitations . During this example we will be using the free tier of the EC2 option, which gives us the possibility to use a Windows instance (if you have already added a payment method). For more information about which services offer a Free Tier, see AWS Free Tier . These are the steps we will go through from start to finish: Account creation Setting up an instance with the EC2 Management Console Configuring the server via RDP (Remote Desktop) Setting up the firewall to allow connections through Testing the connection 1. Account Creation Go to the Account creation page and sign up with your details and payment method (e.g. credit card). Adding the payment method is necessary to run a windows instance on AWS. 2. Setting up an instance with the EC2 Management Console After setting up your account you should be logged in. Always make sure you're in your correct region so it's a good habit to check in the top right corner. Change it to the closest location to you now. After this click on Services in the top left corner and click on EC2. This will bring you to the EC2 instance dashboard and ready to Launch your instance! Click on \"Launch Instance\" . There are 7 steps to creating your AWS Instance: Choose an Amazon Machine Image (AMI) Choose Instance Type Configure Instance Add Storage Add Tags Configure Security Group Review Step 1: Choose an Amazon Machine Image Scroll down until you see the Microsoft Windows Server 2019 Base (take the newest one if this is outdated). Make sure that the option you select has the \"Free Tier Eligible\" under the icon and click on \"Select\". Step 2: Choose Instance Type Make sure you choose the instance type with the \"free tier eligible\", at the time of writing this is the t2.micro instance. Click on \"Next: Configure Instance Details\" . Do not click on Review and Launch. Step 3: Configure Instance Nothing has to be changed at this step. Keep it default. Click on \"Next: Add Storage\" . Step 4: Add Storage Nothing has to be changed. Keep it default. The 30GB is more than you need but there will be an error if you choose a lower amount. Keep in mind that you can always click \"Previous\" if you need to return, you do not need to repeat the entire process if you make a mistake (unless you click Launch at the end). Click on \"Next: Add Tags\" to continue. Step 5: Add Tags Nothing has to be changed. Keep it default. Click on \"Next: Configure Security Groups\" Step 6: Configure Security Groups IMPORTANT STEP This makes it possible to connect to your instance from outside for: RDP (needed for this example) For clients connecting through port 7777 for your Mirror Project. SSH (if needed) Create a new security group and you can give it your own name and description. Add the following rules: RDP with source \"Anywhere\", Description can be whatever but put it as Remote Desktop Program. Custom TCP Rule with port 7777 and source \"Anywhere\", Description can be whatever but put it as Mirror. SSH with source \"Anywhere\", Description can be whatever but put it as SSH. SSH is not strictly necessary but can be used to remote connect to it through other means than the RDP. You can ignore the warning about the source as this is just a testing environment. In the future you might wish to restrict this but you will almost never know the clients' connection IP's beforehand. Click on \"Next: Review and Launch\" Step 7: Review Almost there! Make sure everything is correct and you are using the free tier, then click on \"Launch\" . One more thing: A window will pop up asking for your key pair. Just create a new one by selecting the dropdown: \"Create a new key pair\" and give it a name, click on \"Download Key Pair\" . Keep the key file (.PEM File) somewhere secure (To be 100% certain, back it up somewhere). YOU CANNOT ACCESS THE CREATED INSTANCE WITHOUT THIS KEY Now you can (finally) click on \"Launch Instances\" ! Go back to your EC2 dashboard by clicking on \"Services\" at the top left and clicking on EC2. Now you see you have \"Running Instances: 1\". Click on \"Running Instances\" to continue . A new instance might take around 5-10 minutes to set up. Refresh the page after 10 minutes if nothing changes. Now you did all this but you want to get ON the dedicated server right? Perfect! The next step will get you up and running! 3. Configuring the server via RDP (Remote Desktop) Time to get the RDP file so you can start connecting. There are a few things we'll need: RDP file with the key pair added to it Configure RDP file once downloaded to allow getting files from our C: drive or other drives (so you can easily get your zip project) Enter the windows Admin password once you start the RDP file Once you've done this, you should be able to continue using the same RDP file. RDP file with the key pair added to it Get the password before clicking Download Copy the Password for later Now click on \"Download Remote Desktop File\" . The RDP file will be downloaded. Configure RDP file for easy file access Go to your freshly downloaded RDP file and rightclick it and then click \"Edit\". Go to the third tab \"Local sources\", at the bottom click \"more\" under local devices and sources. On the new window select your C: drive or any other drive. This is your own computer your connecting from. For easy file exchange. Perfect! Now you can run the RDP file! The RDP file will ask a password. If you forgot your password you can get it back by rightclicking the instance and clicking on \"Get Windows Password\". You will be asked to re-enter your key pair (.PEM) file and decrypt the message. Once done you will be able to copy the password. There you have it! Now you have your password and Remote Desktop should show you logging into your dedicated server! Setting up the firewall to allow connections through Go to the windows firewall settings, go to the advanced firewall settings and go to inbound rules. Add a new rule and choose the port type. Select TCP and enter the 7777 port (or any other if you use another port in Mirror). Continue clicking next and keep things default. Close all the windows when done. AWESOME! You now have everything set up to accept incoming requests on port 7777 . 4. Testing the connection Before you can (finally) test out your server build of your project you need to get it on the dedicated server! Place your (zipped) server build at the root of your added drive (C: or another) to make it easier to find it fast. Go to \"My Computer\" and because of our previous changes to the RDP we should now see your local drive under \"Devices and Drives\". Double click it and because you placed your zipped server build on that drive, you should see it immediatly when it's done loading. Now unzip the project in a new folder on the dedicated server's desktop and run it. Want to test if it sees the 7777 port is open after you started your Mirror server? Get your IPv4 public IP from the EC2 Management Console from your instance and use it on your client to connect to that IP. Go to PortChecker and enter the Dedicated Server IP address and enter port 7777. NOTE: If you are not running your game / project then the port will be closed. It's only open when the server is running."
  },
  "Guides/DevServer/index.html": {
    "href": "Guides/DevServer/index.html",
    "title": "Development Servers",
    "keywords": "Development Servers During this guide we will set up a dedicated server and place the server build of our project on the dedicated server. IMPORTANT: Before we begin, there are some potential problems you may face, as no server is truly 'free': Service providers are NOT free. Most of the time you can start with free trials for a limited time, after x amount of time or x amount of used resources the trial will end and you might incur payment. Always read the providers free trial limitations. Some providers require a payment method for using a Windows instance, however as long as you do not go over the limitations the provider should not bill you. NOTE : Mirror is not affiliated and can not be held responsible for any charges or fees associated with service providers like AWS , Microsoft Azure , Google Compute Engine and others... Introduction During your development with Mirror you will need to test your project as a client and as a server. There are a few possible ways to test your project: Default build: Host/client as one and connecting with another build/editor to the host locally on 1 computer. Server build: Server is a separate executable. You can place it on your computer run it and connect to it as a client. Dedicated Server: Same as the server build but placed on an external machine, you connect to it with the server's external ip. This guide will focus on the \"Dedicated Server\" option. There are multiple providers and even self hosted dedicated machines. All possibilities still go through the same process to ensure connectivity to clients. A few requirements for a dedicated server: Port forwarding (Not strictly necessary but makes everything a lot easier without needing NAT punchthrough) Firewall exceptions Computer/machine that stays online and accessible whenever you need it. In the upcoming sections we will go through setting up a provider with the free tier. Always double check that you do not select a paid feature as this is purely meant as a short term period to test out basic functionality during development of your project. Microsoft Azure Microsoft Azure (as of time of writing) allows setting up a windows instance during the free trial without an active payment method. To be added Google Compute Engine Google Compute Engine (as of time of writing) does not allow setting up a windows instance during the free trial without an active payment method. To be added Self Hosted Dedicated Server A self hosted dedicated server is the same as the other providers but you provide the hardware, internet connection and costs for running the computer. Most of the time this is the cheapest option during development if you already have an extra machine. Preferably you would put the machine on a different network (to simulate the conditions as the other providers). This would mean you could connect to the machine and put your server build on whenever you need and have access to the router and security settings of the machine for port forwarding and firewall exceptions. In essence, this is the simplest set up but does require extra hardware."
  },
  "Guides/ClientsServers.html": {
    "href": "Guides/ClientsServers.html",
    "title": "Network Clients and Servers",
    "keywords": "Network Clients and Servers Many multiplayer games can use the Network Manager to manage connections, but you can also use the lower-level NetworkServer and NetworkClient classes directly. When using the High-Level API, every game must have a host server to connect to. Each participant in a multiplayer game can be a client, a dedicated server, or a combination of server and client at the same time. This combination role is the common case of a multiplayer game with no dedicated server. For multiplayer games with no dedicated server, one of the players running the game acts as the server for that game. That player’s instance of the game runs a “local client” instead of a normal remote client. The local client uses the same Scenes and game objects as the server, and communicates internally using message queues instead of sending messages across the network. To Mirror code and systems, the local client is just another client, so almost all user code is the same, whether a client is local or remote. This makes it easy to make a game that works in both multiplayer and standalone mode with the same code. A common pattern for multiplayer games is to have a game object that manages the network state of the game. Below is the start of a Network Manager script. This script would be attached to a game object that is in the start-up Scene of the game. It has a simple UI and keyboard handling functions that allow the game to be started in different network modes. Before you release your game you should create a more visually appealing menu, with options such as “Start single player game” and “Start multiplayer game”. using UnityEngine; using Mirror; public class MyNetworkManager : MonoBehaviour { public bool isAtStartup = true; void Update () { if (isAtStartup) { if (Input.GetKeyDown(KeyCode.S)) SetupServer(); if (Input.GetKeyDown(KeyCode.C)) SetupClient(); if (Input.GetKeyDown(KeyCode.B)) { SetupServer(); SetupLocalClient(); } } } void OnGUI() { if (isAtStartup) { GUI.Label(new Rect(2, 10, 150, 100), \"Press S for server\"); GUI.Label(new Rect(2, 30, 150, 100), \"Press B for both\"); GUI.Label(new Rect(2, 50, 150, 100), \"Press C for client\"); } } } This basic code calls setup functions to get things going. Below are the simple setup functions for each of the scenarios. These functions create a server, or the right kind of client for each scenario. Note that the remote client assumes the server is on the same machine (localhost). For a finished game this would be an internet address, or something supplied by a matchmaker or master server. // Create a server and listen on a port public void SetupServer() { NetworkServer.Listen(7777); isAtStartup = false; } // Create a client and connect to the server port public void SetupClient() { NetworkClient.RegisterHandler<ConnectMessage>(OnConnected); NetworkClient.Connect(\"localhost\"); isAtStartup = false; } // Create a local client and connect to the local server public void SetupLocalClient() { NetworkClient.RegisterHandler<ConnectMessage>(OnConnected); isAtStartup = false; } The clients in this code register a callback function for the connection event ConnectMessage . This is a built-in message of Mirror that the script invokes when a client connects to a server. In this case, the code for the handler on the client is: // client function public void OnConnected(NetworkConnection conn, ConnectMessage netMsg) { Debug.Log(\"Connected to server\"); } This is enough to get a multiplayer application up and running. With this script you can then send network messages using NetworkClient.Send and NetworkServer.SendToAll . Note that sending messages is a low level way of interacting with the system."
  },
  "Guides/DataTypes.html": {
    "href": "Guides/DataTypes.html",
    "title": "Data types",
    "keywords": "Data types The client and server can pass data to each other via Remote methods , State Synchronization or via Network Messages Mirror supports a number of data types you can use with these, including: Basic c# types (byte, int, char, uint, float, string, UInt64, etc) Built-in Unity math type (Vector3, Quaternion, Rect, Plane, Vector3Int, etc) NetworkIdentity Game object with a NetworkIdentity component attached. Structures with any of the above (it's recommended to implement IEquatable<T> to avoid boxing and to have the struct readonly, cause modifying one of fields doesn't cause a resync) Arrays of any of the above (not supported with syncvars or synclists) ArraySegments of any of the above (not supported with syncvars or synclists) Custom Data Types Sometimes you don't want mirror to generate serialization for your own types. For example, instead of serializing quest data, you may want to serialize just the quest id, and the receiver can look up the quest by id in a predefined list. Sometimes you may want to serialize data which uses a different type not supported by Mirror, such as DateTime or System.Uri You can add support for any type by adding extension methods to NetworkWriter and NetworkReader . For example, to add support for DateTime , add this somewhere in your project: public static class DateTimeReaderWriter { public static void WriteDateTime(this NetworkWriter writer, DateTime dateTime) { writer.WriteInt64(dateTime.Ticks); } public static DateTime ReadDateTime(this NetworkReader reader) { return new DateTime(reader.ReadInt64()); } } ...then you can use DateTime in your [Command] or SyncList Inheritance and Polymorphism Sometimes you might want to send a polymorphic data type to your commands. Mirror does not serialize the type name to keep messages small and for security reasons, therefore Mirror cannot figure out the type of object it received by looking at the message. This code does not work out of the box. class Item { public string name; } class Weapon : Item { public int hitPoints; } class Armor : Item { public int hitPoints; public int level; } class Player : NetworkBehaviour { [Command] void CmdEquip(Item item) { // IMPORTANT: this does not work. Mirror will pass you an object of type item // even if you pass a weapon or an armor. if (item is Weapon weapon) { // The item is a weapon, // maybe you need to equip it in the hand } else if (item is Armor armor) { // you might want to equip armor in the body } } [Command] void CmdEquipArmor(Armor armor) { // IMPORTANT: this does not work either, you will receive an armor, but // the armor will not have a valid Item.name, even if you passed an armor with name } } CmdEquip will work if you provide a custom serializer for the Item type. For example: public static class ItemSerializer { const byte WEAPON = 1; const byte ARMOR = 2; public static void WriteItem(this NetworkWriter writer, Item item) { if (item is Weapon weapon) { writer.WriteByte(WEAPON); writer.WriteString(weapon.name); writer.WritePackedInt32(weapon.hitPoints); } else if (item is Armor armor) { writer.WriteByte(ARMOR); writer.WriteString(armor.name); writer.WritePackedInt32(armor.hitPoints); writer.WritePackedInt32(armor.level); } } public static Item ReadItem(this NetworkReader reader) { byte type = reader.ReadByte(); switch(type) { case WEAPON: return new Weapon { name = reader.ReadString(), hitPoints = reader.ReadPackedInt32() }; case ARMOR: return new Armor { name = reader.ReadString(), hitPoints = reader.ReadPackedInt32(), level = reader.ReadPackedInt32() }; default: throw new Exception($\"Invalid weapon type {type}\"); } } }"
  },
  "Guides/Profiler.html": {
    "href": "Guides/Profiler.html",
    "title": "Mirror Network Profiler",
    "keywords": "Mirror Network Profiler The mirror profiler is part of the Mirror Pro suit. As of this writing it is accessible to our Github Supporters. Installation Make sure you have the latest version of Mirror Become a Github Supporter if you haven't. Download the profiler Install the unity package in your project Usage In Unity menu, click on Open Window -> Analysis -> Mirror Network Profiler. The profiler view will appear You may dock the profiler anywhere you want Start your game in the editor Press \"Record\" in the profiler Begin your game as host, client or server At the top a chart will show messages coming in and out Click the chart to select a frame The profiler will display information about all the messages sent and received in that frame Currently the messages display the following fields: In/Out: Whether the message was received (in) or sent (out) Name: Short name of the message, if the message was a [Command] , [ClientRpc] , [TargetRpc] or [TargetEvent] , this will display the name of the method, otherwise it will display the name of the message class. Bytes: The size of the message in bytes Count: In the case of out messages, this will contain how many clients the message was sent to. Total Bytes: the size of the message multiplied by the amount of clients the message was sent to (Bytes * Count) Channel: The channel used to send the message. As of this writing, we cannot determine the channel for inbound messages, so it displays -1. This will be improved in future versions. Transports can use channels for many purposes such as reliable, unreliable, encrypted, compressed, etc. Optimizing bandwidth On most transports, the total bandwidth is dominated by the Count column. This is because each message is packaged in a TCP or UDP frame, which have large headers. If you are sending multiple [Command] in the same frame, consider consolidating them into a single [Command] call if it makes sense If you see a large Count number on a specific message, consider adding a NetworkProximityChecker to your object, so that it is only visible to nearby players instead of the entire world. This can dramatically reduce the Count (and total bytes) depending on your game. If you are sending a message every single frame, consider changing your logic so that you only send messages when things change, or use a timer. Consider using SyncToOwner feature so that only the owner gets a message when private information such as inventory changes. This can dramatically reduce the Count depending on your game. If you have a lot of [ClientRpc] calls that synchronize data, consider using [SyncVar] and synclists instead. They can reduce the amount of messages because they only send deltas when they change, plus they get batched together, so hundreds of variables can be synchronized with a single message."
  },
  "Guides/ClockSync.html": {
    "href": "Guides/ClockSync.html",
    "title": "Clock Synchronization",
    "keywords": "Clock Synchronization For many algorithms you need the clock to be synchronized between the client and the server. Mirror does that automatically for you. To get the current time use this code: double now = NetworkTime.time; It will return the same value in the client and the servers. It starts at 0 when the server starts. Note the time is a double and should never be casted to a float. Casting this down to a float means the clock will lose precision after some time: after 1 day, accuracy goes down to 8 ms after 10 days, accuracy is 62 ms after 30 days , accuracy is 250 ms after 60 days, accuracy is 500 ms Mirror will also calculate the RTT time as seen by the application: double rtt = NetworkTime.rtt; You can measure accuracy. double time_standard_deviation = NetworkTime.timeSd; for example, if this returns 0.2, it means the time measurements swing up and down roughly 0.2 s Network hiccups are compensated against by smoothing out the values using EMA. You can configure how often you want the the ping to be sent: NetworkTime.PingFrequency = 2.0f; You can also configure how many ping results are used in the calculation: NetworkTime.PingWindowSize = 10;"
  },
  "Guides/IDs.html": {
    "href": "Guides/IDs.html",
    "title": "Got ID?",
    "keywords": "Got ID? Asset Id Mirror uses GUID for Asset Ids. Every prefab with a NetworkIdentity component has an Asset Id, which is simply Unity's AssetDatabase.AssetPathToGUID converted to 16 bytes. Mirror needs that to know which prefabs to spawn. Scene Id Mirror uses uint for Scene Ids. Every game object with a NetworkIdentity in the scene (hierarchy) is assigned a scene id in OnPostProcessScene. Mirror needs that to distinguish scene objects from each other, because Unity has no unique id for different game objects in the scene. Network Instance Id (a.k.a. NetId) Mirror uses uint for NetId. Every NetworkIdentity is assigned a NetId in NetworkIdentity.OnStartServer, or after spawning it. Mirror uses the id when passing messages between client and server to tell which object is the recipient of the message. Connection Id Every network connection has a connection id, which is assigned by the low level Transport layer. Connection id 0 is reserved for the local connection when the server is also a client (host)"
  },
  "Guides/Authority.html": {
    "href": "Guides/Authority.html",
    "title": "Network Authority",
    "keywords": "Network Authority Servers and clients can both manage a game object’s behavior. The concept of “authority” refers to how and where a game object is managed. Server Authority The default state of authority in networked games using Mirror is that the Server has authority over all game objects which do not represent players. This means, for example, the server would manage control of all collectible items, moving platforms, NPCs, and any other parts of your game that players can interact with, and player game objects have authority on their owner’s client (meaning the client manages their behavior). Client Authority Client authority means the local client can control a networked game object. By default only the server has control over a networked object. In practical terms, having client authority means that the client can call Command methods, and if the client disconnects, the object is automatically destroyed. Use the NetworkIdentity.hasAuthority property in the client to find out whether a game object has local authority (also accessible on NetworkBehaviour for convenience). Assigning authority to a client causes Mirror to call OnStartAuthority() on each NetworkBehaviour on the game object on the authority client, and sets the hasAuthority property to true. On other clients, the hasAuthority property remains false. Player objects always have client authority. This is required for controlling movement and other player actions. Client Authority is not to be confused with client authoritative architecture Any action must still go to the server via a Command . The client cannot modify SyncVars or affect other clients directly Non-Player Game Objects It is possible to have client authority over non-player game objects. There are two ways to do this. One is to spawn the game object using NetworkServer.Spawn and pass the network connection of the client to take ownership. The other is to use NetworkIdentity.AssignClientAuthority with the network connection of the client to take ownership. The example below spawns a game object and assigns authority to the client of the player that spawned it. [Command] void CmdSpawn() { GameObject go = Instantiate(otherPrefab, transform.position + new Vector3(0,1,0), Quaternion.identity); NetworkServer.Spawn(go, connectionToClient); } Network Context Properties The NetworkBehaviour class contains properties that allow scripts to know what the context of a networked game object is at any time. isServer : true if the game object is on a server and has been spawned. isClient : true if the game object is on a client, and was created by the server. isLocalPlayer : true if the game object is a player game object for this client. hasAuthority : true if the game object is owned by this client. On the server, the NetworkIdentity holds the owning client in connectionToClient . To see these properties, select the game object you want to inspect, and in the Inspector window, view the preview window for the NetworkBehaviour scripting components. You can use the value of these properties to execute code based on the context in which the script is running."
  },
  "Guides/Visibility.html": {
    "href": "Guides/Visibility.html",
    "title": "Network Visibility",
    "keywords": "Network Visibility Multiplayer games use the concept of network visibility to determine which players can see which game objects at any given time during game play. In a game that has a moving viewpoint and moving game objects, it’s common that players cannot see everything that is happening in the game at once. If a particular player, at a certain point in time during game play, cannot see most of the other players, non-player characters, or other moving or interactive things in your game, there is usually no need for the host to send information about those things to the player’s client. This can benefit your game in two ways: It reduces the amount of data sent across the network between players. This can help improve the responsiveness of your game, and reduce bandwidth use. The bigger and more complex your multiplayer game, the more important this issue is. It also helps prevent hacking. Since a player client does not have information about things that can’t be seen, a hack on that player’s computer cannot reveal the information. The idea of “visibility” in the context of networking doesn’t necessarily relate to whether game objects are directly visible on-screen. Instead, it relates to whether data should or shouldn’t be sent about the game object in question to a particular client. Put simply, if a client can’t ‘see’ an game object, it does not need to be sent information about that game object across the network. Ideally you want to limit the amount of data you are sending across the network to only what is necessary, because sending large amounts of unnecessary data across the network can cause network performance problems. However, it can be also be resource intensive or complex to determine accurately whether a game object truly visible to a given player, so it’s often a good idea to use a more simple calculation for the purposes of determining whether a player should be sent networked data about it - i.e. whether it is ‘Network Visible’. The balance you want to achieve when considering this is between the cost of the complexity of the calculation for determining the visibility, and the cost of sending more information than necessary over the network. A very simple way to calculate this is a distance (proximity) check, and Mirror provides a built-in component for this purpose. Network Proximity Checker Component Mirror’s Network Proximity Checker component is simplest way to implement network visibility for players. It works in conjunction with the physics system to determine whether game objects are close enough (that is, “visible” for the purposes of sending network messages in your multiplayer game). Network Visibility on Remote Clients When a player on a remote client joins a networked game, only game objects that are network-visible to the player will be spawned on that remote client. This means that even if the player enters a large world with many networked game objects, the game can start quickly because it does not need to spawn every game object that exists in the world. Note that this applies to networked game objects in your Scene, but does not affect the loading of Assets. Unity still takes time to load the Assets for registered Prefabs and Scene game objects. When a player moves within the world, the set of network-visible game objects changes. The player’s client is told about these changes as they happen. The ObjectHide message is sent to clients when a game object becomes no longer network-visible. By default, Mirror destroys the game object when it receives this message. When a game object becomes visible, the client receives an ObjectSpawn message, as if Mirror has spawned the game object for the first time. By default, the game object is instantiated like any other spawned game object. Network Visibility on the Host The host shares the same Scene as the server, because it acts as both the server and the client to the player hosting the game. For this reason, it cannot destroy game objects that are not visible to the local player. Instead, there is the virtual method OnSetLocalVisibility on the NetworkBehaviour class that is invoked. This method is invoked on all NetworkBehaviour scripts on game objects that change visibility state on the host. The default implementation of OnSetLocalVisibility disables or enables all renderer components on the game object. If you want to customize this implementation, you can override the method in your script, and provide a new behavior for how the host (and therefore the local client) should respond when a game object becomes network-visible or invisible (such as disabling HUD elements or renderers)."
  },
  "index.html": {
    "href": "index.html",
    "title": "Mirror Networking for Unity",
    "keywords": "Mirror Networking for Unity Mirror is the most compatible direct replacement for the deprecated Unity Networking API. Mirror has nearly all of the components and features from UNet, making networking easy, concise and maintainable, whether you're starting from scratch or converting an existing project. We even have a Migration Tool to do most of the work for you! Built to support games of any scale, from LAN party games to dedicated high-volume authoritative servers running hundreds of players, Mirror is the core networking solution for uMMORPG , uSurvival , Cubica , and more ! uMMORPG was possible with <6000 lines of code. We needed a networking library that allows us to launch our games, period! Full Source included for debugging convenience Several working examples included Active Discord for prompt support Requires Unity 2018.3.6+ and Runtime .Net 4.x (default in Unity 2019) and .Net 2.0 Compatibility is recommended Alpha / Beta Unity versions cannot be supported Multiple Transports Available: TCP ( Telepathy ) UDP ( ENet and LiteNetLib ) Steam ( Steamworks.Net ) WebGL ( Secure Web Sockets ) List Server We've developed a List Server where game servers can register and clients can connect to find those servers to play on them. Key Features & Components: Transports are interchangeable components Additive Scene Loading Single and separated Unity projects supported Network Authenticators to protect your game Network Manager and HUD Network Room Manager and Room Player Network Identity Network Transform Network Animator with 64 parameters Network Proximity Checker SyncVar , SyncList , SyncEvent , SyncDictionary , and SyncHashSet Integrations Dissonance Voice Chat Network Sync Transform Noble Connect Free Rucksack RTS Engine Smooth Sync Weather Maker"
  },
  "Guides/Sync/SyncHashSet.html": {
    "href": "Guides/Sync/SyncHashSet.html",
    "title": "SyncHashSet",
    "keywords": "SyncHashSet SyncHashSet are sets similar to C# HashSet<T> that synchronize their contents from the server to the clients. A SyncHashSet can contain any supported mirror type Usage Create a class that derives from SyncHashSet for your specific type. This is necessary because Mirror will add methods to that class with the weaver. Then add a SyncHashSet field to your NetworkBehaviour class. For example: class Player : NetworkBehaviour { class SyncSkillSet : SyncHashSet<string> {} readonly SyncSkillSet skills = new SyncSkillSet(); int skillPoints = 10; [Command] public void CmdLearnSkill(string skillName) { if (skillPoints > 1) { skillPoints--; skills.Add(skillName); } } } You can also detect when a SyncHashSet changes. This is useful for refreshing your character in the client or determining when you need to update your database. Subscribe to the Callback event typically during Start , OnClientStart or OnServerStart for that. Note that by the time you subscribe, the set will already be initialized, so you will not get a call for the initial data, only updates. Note SyncSets must be initialized in the constructor, not in Startxxx(). You can make them readonly to ensure correct usage. class Player : NetworkBehaviour { class SyncSetBuffs : SyncHashSet<string> {}; public readonly SyncSetBuffs buffs = new SyncSetBuffs(); // this will add the delegate on the client. // Use OnStartServer instead if you want it on the server public override void OnStartClient() { buffs.Callback += OnBuffsChanged; } void OnBuffsChanged(SyncSetBuffs.Operation op, string buff) { switch (op) { case SyncSetBuffs.Operation.OP_ADD: // we added a buff, draw an icon on the character break; case SyncSetBuffs.Operation.OP_CLEAR: // clear all buffs from the character break; case SyncSetBuffs.Operation.OP_REMOVE: // We removed a buff from the character break; } } }"
  },
  "Guides/Sync/SyncVars.html": {
    "href": "Guides/Sync/SyncVars.html",
    "title": "SyncVars",
    "keywords": "SyncVars SyncVars are properties of classes that inherit from NetworkBehaviour, which are synchronized from the server to clients. When a game object is spawned, or a new player joins a game in progress, they are sent the latest state of all SyncVars on networked objects that are visible to them. Use the SyncVar custom attribute to specify which variables in your script you want to synchronize. The state of SyncVars is applied to game objects on clients before OnStartClient() is called, so the state of the object is always up-to-date inside OnStartClient() . SyncVars can use any type supported by Mirror . You can have up to 64 SyncVars on a single NetworkBehaviour script, including SyncLists (see next section, below). The server automatically sends SyncVar updates when the value of a SyncVar changes, so you do not need to track when they change or send information about the changes yourself. The SyncVar hook attribute can be used to specify a method to be called when the SyncVar changes value on the client. SyncVar Example Let's say we have a networked object with a script called Enemy: public class Enemy : NetworkBehaviour { [SyncVar] public int health = 100; void OnMouseUp() { NetworkIdentity ni = NetworkClient.connection.identity; PlayerController pc = ni.GetComponent<PlayerController>(); pc.currentTarget = gameObject; } } The PlayerController might look like this: public class PlayerController : NetworkBehaviour { public GameObject currentTarget; void Update() { if (isLocalPlayer) if (currentTarget != null) if (currentTarget.tag == \"Enemy\") if (Input.GetKeyDown(KeyCode.X)) CmdShoot(currentTarget); } [Command] public void CmdShoot(GameObject enemy) { // Do your own shot validation here because this runs on the server enemy.GetComponent<Enemy>().health -= 5; } } In this example, when a Player clicks on an Enemy, the networked enemy game object is assigned to PlayerController.currentTarget . When the player presses X, with a correct target selected, that target is passed through a Command, which runs on the server, to decrement the health SyncVar. All clients will be updated with that new value. You can then have a UI on the enemy to show the current value. Class inheritance SyncVars work with class inheritance. Consider this example: class Pet : NetworkBehaviour { [SyncVar] String name; } class Cat : Pet { [SyncVar] public Color32 color; } You can attach the Cat component to your cat prefab, and it will synchronize both it's name and color . Warning Both Cat and Pet should be in the same assembly. If they are in separate assemblies, make sure not to change name from inside Cat directly, add a method to Pet instead."
  },
  "Guides/Sync/SyncVarHook.html": {
    "href": "Guides/Sync/SyncVarHook.html",
    "title": "SyncVar Hook",
    "keywords": "SyncVar Hook The hook attribute can be used to specify a function to be called when the SyncVar changes value on the client. This ensures that all clients receive the proper variables from other clients. The Hook method must have a two parameters of the same type as the SyncVar property. One for the old value, one for the new value. The Hook is always called after the value was set. You don't need to set it yourself. Below is a simple example of assigning a random color to each player when they're spawned on the server. All clients will see all players in the correct colors, even if they join later. using UnityEngine; using UnityEngine.Networking; public class PlayerController : NetworkBehaviour { [SyncVar(hook = nameof(SetColor))] Color playerColor = Color.black; // Unity makes a clone of the Material every time GetComponent<Renderer>().material is used. // Cache it here and Destroy it in OnDestroy to prevent a memory leak. Material cachedMaterial; public override void OnStartServer() { base.OnStartServer(); playerColor = Random.ColorHSV(0f, 1f, 1f, 1f, 0.5f, 1f); } void SetColor(Color oldColor, Color newColor) { if (cachedMaterial == null) cachedMaterial = GetComponent<Renderer>().material; cachedMaterial.color = newColor; } void OnDestroy() { Destroy(cachedMaterial); } }"
  },
  "Guides/Conversion.html": {
    "href": "Guides/Conversion.html",
    "title": "Converting a Single-Player Game to Mirror",
    "keywords": "Converting a Single-Player Game to Mirror This document describes steps to converting a single player game to a multiplayer game, using Mirror. The process described here is a simplified, higher level version of the actual process for a real game; it doesn’t always work exactly like this, but it provides a basic recipe for the process. NetworkManager set-up Add a new game object and rename it “NetworkManager”. Add the NetworkManager component to the “NetworkManager” game object. Add the NetworkManagerHUD component to the game object. This provides the default UI​ for managing the network game state. See Using the NetworkManager. Player Prefab Setup Find the Prefab for the player game object in the game, or create a Prefab from the player game object Add the NetworkIdentity component to the player Prefab Set the playerPrefab in the NetworkManager’s Spawn Info section to the player Prefab Remove the player game object instance from the Scene if it exists in the Scene See Player Objects for more information. Player Movement Add a NetworkTransform component to the player Prefab Update input and control scripts to respect isLocalPlayer Fix Camera to use spawned player and isLocalPlayer For example, this script only processes input for the local player: using UnityEngine; using Mirror; public class Controls : NetworkBehaviour { void Update() { if (!isLocalPlayer) { // exit from update if this is not the local player return; } // handle player input for movement } } Basic Player Game State Make scripts that contain important data into NetworkBehaviours instead of MonoBehaviours Make important member variables into SyncVars See State Synchronization. Networked Actions Make scripts that perform important actions into NetworkBehaviours instead of MonoBehaviours Update functions that perform important player actions to be commands See Networked Actions. Non-player Game Objects Fix non-player prefabs such as enemies: Add the NetworkIdentify component Add the NetworkTransform component Register spawnable Prefabs with the NetworkManager Update scripts with game state and actions Spawners Potentially change spawner scripts to be NetworkBehaviours Modify spawners to only run on the server (use isServer property or the OnStartServer() function) Call NetworkServer.Spawn() for created game objects Spawn Positions for Players Add a new game object and place it at player’s start location Add the NetworkStartPosition component to the new game object Room Create Room Scene Add a new game object to the Scene and rename it to “NetworkRoomManager”. Add the NetworkRoomManager component to the new game object. Configure the Manager: Scenes Prefabs Spawners"
  },
  "Guides/Attributes.html": {
    "href": "Guides/Attributes.html",
    "title": "Attributes Overview",
    "keywords": "Attributes Overview Networking attributes are added to member functions of NetworkBehaviour scripts, to make them run on either the client or server. These attributes can be used for Unity game loop methods like Start or Update, as well as other implemented methods. NetworkSettings This attribute has been deprecated because channels were moved to transports (where applicable) and interval was moved to an inspector property Server means don't allow a client to call that method (throws a warning or an error when called on a client). ServerCallback A Custom Attribute that can be added to member functions of NetworkBehaviour scripts, to make them only run on servers. Client means don't allow a server to call that method (throws a warning or an error when called on the server). ClientCallback A Custom Attribute that can be added to member functions of NetworkBehaviour scripts, to make them only run on clients, but not generate warnings. ClientRpc The server uses a Remote Procedure Call (RPC) to run that function on clients. See also: Remote Actions TargetRpc This is an attribute that can be put on methods of NetworkBehaviour classes to allow them to be invoked on clients from a server. Unlike the ClientRpc attribute, these functions are invoked on one individual target client, not all of the ready clients. See also: Remote Actions Command Call this from a client to run this function on the server. Make sure to validate input etc. It's not possible to call this from a server. Use this as a wrapper around another function, if you want to call it from the server too. See also Remote Actions​ The allowed argument types are: Basic type (byte, int, float, string, UInt64, etc) Built-in Unity math type (Vector3, Quaternion, etc), Arrays of basic types Structs containing allowable types NetworkIdentity Game object with a NetworkIdentity component attached. SyncVar SyncVars are used to synchronize a variable from the server to all clients automatically. Don't assign them from a client, it's pointless. Don't let them be null, you will get errors. You can use int, long, float, string, Vector3 etc. (all simple types) and NetworkIdentity and game object if the game object has a NetworkIdentity attached to it. You can use hooks . SyncEvent SyncEvent are networked events like ClientRpc's, but instead of calling a function on the game object, they trigger Events instead."
  },
  "Guides/VisibilityCustom.html": {
    "href": "Guides/VisibilityCustom.html",
    "title": "Customizing Network Visibility",
    "keywords": "Customizing Network Visibility The built-in Network Proximity Checker component is the built-in default component for determining a game object’s network visibility. However, this only provides you with a distance-based check. Sometimes you might want to use other kinds of visibility check, such as grid-based rules, line-of-sight tests, navigation path tests, or any other type of test that suits your game. To do this, you can implement your own custom equivalent of the Network Proximity Checker. To do that, you need to understand how the Network Proximity Checker works. See documentation on the Network Proximity Checker component. The Network Proximity Checker is implemented using the public visibility interface of Mirror’s HLAPI. Using this same interface, you can implement any kind of visibility rules you desire. Each NetworkIdentity keeps track of the set of players that it is visible to. The players that a NetworkIdentity game object is visible to are called the “observers” of the NetworkIdentity. The Network Proximity Checker calls the RebuildObservers method on the Network Identity component at a fixed interval (set using the “Vis Update Interval” value in the inspector), so that the set of network-visible game objects for each player is updated as they move around. On the NetworkBehaviour class (which your networked scripts inherit from), there are some virtual functions for determining visibility. These are: OnCheckObserver This method is called on the server, on each networked game object when a new player enters the game. If it returns true, that player is added to the object’s observers. The Network Proximity Checker does a simple distance check in its implementation of this function, and uses Physics.OverlapSphereNonAlloc to find the players that are within the visibility distance for this object. OnRebuildObservers This method is called on the server when RebuildObservers is invoked. This method expects the set of observers to be populated with the players that can see the object. The NetworkServer then handles sending ObjectHide and ObjectSpawn messages based on the differences between the old and new visibility sets. You can check whether any given networked game object is a player by checking if its NetworkIdentity has a valid connectionToClient. For example: int hitCount = Physics.OverlapSphereNonAlloc(transform.position, visRange, hitsBuffer3D, castLayers); for (int i = 0; i < hitCount; i++) { Collider hit = hitsBuffer3D[i]; NetworkIdentity identity = hit.GetComponent<NetworkIdentity>(); if (identity != null && identity.connectionToClient != null) observers.Add(identity.connectionToClient); }"
  },
  "Guides/index.html": {
    "href": "Guides/index.html",
    "title": "Networking Concepts Overview",
    "keywords": "Networking Concepts Overview High level scripting API Mirror’s networking has a “high-level” scripting API (which we’ll refer to as the HLAPI). Using this means you get access to commands which cover most of the common requirements for multiuser games without needing to worry about the “lower level” implementation details. The HLAPI allows you to: Control the networked state of the game using a “Network Manager”. Operate “client hosted” games, where the host is also a player client. Serialize data using a general-purpose serializer. Send and receive network messages. Send networked commands from clients to servers. Make remote procedure calls (RPCs) from servers to clients. Send networked events from servers to clients. Engine and Editor integration Mirror’s networking is integrated into the engine and the editor, allowing you to work with components and visual aids to build your multiplayer game. It provides: A NetworkIdentity component for networked objects. A NetworkBehaviour for networked scripts. Configurable automatic synchronization of object transforms. Automatic synchronization of script variables. Support for placing networked objects in Unity scenes. Network components"
  },
  "Guides/NetworkBehaviour.html": {
    "href": "Guides/NetworkBehaviour.html",
    "title": "NetworkBehaviour",
    "keywords": "NetworkBehaviour See also NetworkBehaviour in the API Reference. Network Behaviour scripts work with game objects that have a NetworkIdentity component. These scripts can perform high-level API functions such as Commands, ClientRpc's, SyncEvents and SyncVars. With the server-authoritative system of Mirror, the server must use the NetworkServer.Spawn function to spawn game objects with Network Identity components. Spawning them this way assigns them a netId and creates them on clients connected to the server. Note: This is not a component that you can add to a game object directly. Instead, you must create a script which inherits from NetworkBehaviour (instead of the default MonoBehaviour ), then you can add your script as a component to a game object. Properties isLocalPlayer Returns true if this game object represents the player created for this client. isServer Returns true if this game object is running on the server, and has been spawned. isClient Returns true if this game object is on the client and has been spawned by the server. hasAuthority Returns true if this client has ownership over this game object. It is normally false in the server, except if the server is also a client (host mode). netId The unique network ID of this game object. The server assigns this at run time. It is unique for all game objects in that network session. netIdentity Returns the NetworkIdentity of this object connectionToServer The NetworkConnection associated with the Network Identity component attached to this game object. This is only valid for player objects on the client. connectionToClient The NetworkConnection associated with the Network Identity component attached to this game object. This is only valid for player game objects on the server. NetworkBehaviour scripts have the following features: Synchronized variables Network callbacks Server and client functions Sending commands Client RPC calls Networked events Network Callbacks There are built-in callback functions which are invoked on NetworkBehaviour scripts for various network events. These are virtual functions on the base class, so you can override them in your own code like this: public class SpaceShip : NetworkBehaviour { public override void OnStartServer() { // disable client stuff } public override void OnStartClient() { // register client events, enable effects } } The built-in callbacks are: OnStartServer called when a game object spawns on the server, or when the server is started for game objects in the Scene OnStartClient called when the game object spawns on the client, or when the client connects to a server for game objects in the Scene OnSerialize called to gather state to send from the server to clients OnDeSerialize called to apply state to game objects on clients OnNetworkDestroy called on clients when the server destroys the game object OnStartLocalPlayer called on clients for player game objects on the local client (only) OnStartAuthority called on clients for behaviours that have authority, based on context and hasAuthority. OnRebuildObservers called on the server when the set of observers for a game objects is rebuilt OnSetLocalVisibility called on the client and/or server when the visibility of a game object changes for the local client OnCheckObserver called on the server to check visibility state for a new client Note that in a peer-hosted setup, when one of the clients is acting as both host and client, both OnStartServer and OnStartClient are called on the same game object. Both these functions are useful for actions that are specific to either the client or server, such as suppressing effects on a server, or setting up client-side events. Server and Client functions You can tag member functions in NetworkBehaviour scripts with custom attributes to designate them as server-only or client-only functions. Server and ServerCallback return immediately if the client is not active. Likewise, Client and ClientCallback return immediately if the server is not active. The Server and Client attributes are for your own custom callback functions. They do not generate compile time errors, but they do emit a warning log message if called in the wrong scope. The ServerCallback and ClientCallback attributes are for built-in callback functions that are called automatically by Mirror. These attributes do not cause a warning to be generated. For more information, see Attributes . Commands To execute code on the server, you must use commands. The high-level API is a server-authoritative system, so commands are the only way for a client to trigger some code on the server. Only player game objects can send commands. When a client player game object sends a command, that command runs on the corresponding player game object on the server. This routing happens automatically, so it is impossible for a client to send a command for a different player. To define a command in your code, you must write a function which has: A name that begins with Cmd The Command attribute Commands are called just by invoking the function normally on the client. Instead of the command function running on the client, it is automatically invoked on the corresponding player game object on the server. Commands are type-safe, have built-in security and routing to the player, and use an efficient serialization mechanism for the arguments to make calling them fast. See Communications and related sections for more information. Client RPC Calls Client RPC calls are a way for server game objects to make things happen on client game objects. Client RPC calls are not restricted to player game objects, and may be called on any game object with a Network Identity component. To define a Client RPC call in your code, you must write a function which: Has a name that begins with Rpc Has the ClientRpc attribute See Communications and related sections for more information. Networked Events Networked events are like Client RPC calls, but instead of calling a function on the game object, they trigger Events instead. This allows you to write scripts which can register for a callback when an event is triggered. To define a Networked event in your code, you must write a function which both: Has a name that begins with Event Has the SyncEvent attribute You can use events to build powerful networked game systems that can be extended by other scripts. This example shows how an effect script on the client can respond to events generated by a combat script on the server. SyncEvent is the base class that Commands and ClientRpc calls are derived from. You can use the SyncEvent attribute on your own functions to make your own event-driven networked game play code. Using SyncEvent, you can extend Mirror’s Multiplayer features to better fit your own programming patterns. See SyncEvents for more details."
  },
  "Components/NetworkProximityChecker.html": {
    "href": "Components/NetworkProximityChecker.html",
    "title": "NetworkProximityChecker",
    "keywords": "NetworkProximityChecker The Network Proximity Checker component controls the visibility of game objects for network clients, based on proximity to players. Vis Range Define the range that the game object should be visible to observers. Vis Update Interval Define how often (in seconds) the game object should check for observers entering its visible range. Check Method Define which type of physics (2D or 3D) to use for proximity checking. Force Hidden Tick this checkbox to hide this object from all players. With the Network Proximity Checker, a game running on a client doesn’t have information about game objects that are not visible. This has two main benefits: it reduces the amount of data sent across the network, and it makes your game more secure against hacking. This component relies on physics to calculate visibility, so observer game objects must also have a collider component on it. A game object with a Network Proximity Checker component must also have a Network Identity component. When you create a Network Proximity Checker component on a game object, Mirror also creates a Network Identity component on that game object if it does not already have one. Scene objects with a Network Proximity Checker component are disabled when they're out of range, and spawned objects are destroyed when they're out of range."
  },
  "Components/NetworkAnimator.html": {
    "href": "Components/NetworkAnimator.html",
    "title": "Network Animator",
    "keywords": "Network Animator The Network Animator component allows you to synchronize animation states for networked objects. It synchronizes state and parameters from an Animator Controller. Note that if you create a Network Animator component on an empty game object, Mirror also creates a Network Identity component and an Animator component on that game object. Animator Use this field to define the Animator component you want the Network Animator to synchronize with. Details The Network Animator ensures the synchronization of game object animation across the network meaning that all players see the animation happen at the same. There are two kinds of authority for networked animation (see documentation on network authority ): If the game object has authority on the client, you should animate it locally on the client that owns the game object. That client sends the animation state information to the server, which broadcasts it to all the other clients. For example, this may be suitable for player characters with client authority. If the game object has authority on the server, then you should animate it on the server. The server then sends state information to all clients. This is common for animated game objects that are not related to a specific client, such as scene objects and non-player characters, or server-authoritative clients. Animator Triggers are not synced directly. Call NetworkAnimator.SetTrigger instead. A game object with authority can use the SetTrigger function to fire an animation trigger on other clients."
  },
  "Components/NetworkRoomManager.html": {
    "href": "Components/NetworkRoomManager.html",
    "title": "NetworkRoomManager",
    "keywords": "NetworkRoomManager **Please see the Room example in the Examples folder in your Mirror folder The Network Room Manager is a specialized type of Network Manager that provides a multiplayer room before entering the main play scene of the game. It allows you to set up a network with: A maximum player limit Automatic start when all players are ready Option to prevent players from joining a game in progress Customizable ways for players to choose options while in room There are two types of player objects with the Network Room Manager: Room Player Prefab One for each player Created when client connects, or player is added Persists until client disconnects Holds ready flag and configuration data Handles commands in the room Must use the Network Room Player component Player Prefab One for each player Created when game scene is started Destroyed when leaving game scene Handles commands in the game Properties Show Room GUI Show the default OnGUI controls for the room. Min Players Minimum number of players needed to start a game. Room Player Prefab The prefab to create for players when they enter the room (requires Network Room Player component). Room Scene The scene to use for the room. Gameplay Scene The scene to use for main game play. pendingPlayers List<PendingPlayer> that holds players that are ready to start playing. roomSlots List<NetworkRoomPlayer> that manages the slots for connected clients in the room. allPlayersReady Bool indicating if all players are ready to start playing. This value changes as players invoke CmdChangeReadyState indicating true or false, and will be set false when a new client connects. Methods Server Virtual Methods public virtual void OnRoomStartHost() {} public virtual void OnRoomStopHost() {} public virtual void OnRoomStartServer() {} public virtual void OnRoomServerConnect(NetworkConnection conn) {} public virtual void OnRoomServerDisconnect(NetworkConnection conn) {} public virtual void OnRoomServerSceneChanged(string sceneName) {} public virtual GameObject OnRoomServerCreateRoomPlayer(NetworkConnection conn) { return null; } public virtual GameObject OnRoomServerCreateGamePlayer(NetworkConnection conn) { return null; } public virtual bool OnRoomServerSceneLoadedForPlayer(GameObject roomPlayer, GameObject gamePlayer) { return true; } public virtual void OnRoomServerPlayersReady() { ServerChangeScene(GameplayScene); } Client Virtual Methods public virtual void OnRoomClientEnter() {} public virtual void OnRoomClientExit() {} public virtual void OnRoomClientConnect(NetworkConnection conn) {} public virtual void OnRoomClientDisconnect(NetworkConnection conn) {} public virtual void OnRoomStartClient() {} public virtual void OnRoomStopClient() {} public virtual void OnRoomClientSceneChanged(NetworkConnection conn) {} public virtual void OnRoomClientAddPlayerFailed() {}"
  },
  "Components/NetworkRoomPlayer.html": {
    "href": "Components/NetworkRoomPlayer.html",
    "title": "NetworkRoomPlayer",
    "keywords": "NetworkRoomPlayer The Network Room Player stores per-player state for the Network Room Manager while in the room. When using this component, you need to write a script which allows players to indicate they are ready to begin playing, which sets the ReadyToBegin property. A game object with a Network Room Player component must also have a Network Identity component. When you create a Network Room Player component on a game object, Unity also creates a Network Identity component on that game object if it does not already have one. Show Room GUI Enable this to show the developer GUI for players in the room. This UI is only intended to be used for ease of development. This is enabled by default. Ready To Begin Enable this to have room players automatically be set to Ready. Index Sequential index of the player, e.g. Player 1, Player 2, etc. Network Sync Interval The rate at which information is sent from the Network Room Player to the server. Methods Client Virtual Methods public virtual void OnClientEnterRoom() {} public virtual void OnClientExitRoom() {} public virtual void OnClientReady(bool readyState) {}"
  },
  "Components/NetworkTransformChild.html": {
    "href": "Components/NetworkTransformChild.html",
    "title": "NetworkTransformChild",
    "keywords": "NetworkTransformChild The Network Transform Child component synchronizes the position and rotation of the child game object of a game object with a Network Transform component. You should use this component in situations where you need to synchronize an independently-moving child object of a Networked game object. To use the Network Transform Child component, attach it to the same parent game object as the Network Transform, and use the Target field to define which child game object to apply the component settings to. You can have multiple Network Transform Child components on one parent game object . You can modify Compress Rotation to save some bandwidth when synchronizing the rotation. You can use the Network Sync Interval to specify how often it syncs (in seconds). This component takes authority into account, so local player game objects (which have local authority) synchronize their position from the client to server, then out to other clients. Other game objects (with server authority) synchronize their position from the server to clients."
  },
  "Components/NetworkTransform.html": {
    "href": "Components/NetworkTransform.html",
    "title": "NetworkTransform",
    "keywords": "NetworkTransform The Network Transform component synchronizes the movement and rotation of game objects across the network. Note that the network Transform component only synchronizes networked game objects. A game object with a Network Transform component must also have a Network Identity component. When you create a Network Transform component on a game object, Mirror also creates a Network Identity component on that game object if it does not already have one. Network Transform interpolates on clients using Vector3.MoveTowards . You can modify Compress Rotation to save some bandwidth when synchronizing the rotation. You can use the Network Sync Interval to specify how often it syncs (in seconds). This component takes authority into account, so local player game objects (which have local authority) synchronize their position from the client to server, then out to other clients. Other game objects (with server authority) synchronize their position from the server to clients. While this component and simple movement inputs is sufficient for fast prototyping and testing general game mechanics, it's not really intended for use as a fully functional character controller. A proper character controller is recommended, either based on Unity's Character Controller, or a tick-based authoritative physics system."
  },
  "Components/NetworkStartPosition.html": {
    "href": "Components/NetworkStartPosition.html",
    "title": "NetworkStartPosition",
    "keywords": "NetworkStartPosition To control where players are spawned, you can use the Network Start Position component. To use these, attach a Network Start Position component to a game object in the scene, and position the game object where you would like one of the players to start. You can add as many start positions to your Scene as you like. The Network Manager detects all start positions in your Scene, and when it spawns each player instance, it uses the position and orientation of one of them. The Network Manager will spawn players at (0, 0, 0) by default. Adding this component to a game object will automatically register/unregister its game object's transform to the Network Manager as an available spawning position. Depending on the Network Manager Player Spawn Method setting the spawning is either Random (possible that the same spawn position will be used by two or more players) or Round Robin (use every available position, until there are more clients than spawn points)."
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "PLACEHOLDER",
    "keywords": "PLACEHOLDER TODO: Add .NET projects to the src folder and run docfx to generate REAL API Documentation !"
  },
  "Guides/Sync/SyncEvent.html": {
    "href": "Guides/Sync/SyncEvent.html",
    "title": "SyncEvent",
    "keywords": "SyncEvent This is an attribute that can be put on events in NetworkBehaviour classes to allow them to be invoked on client when the event is called on the server. SyncEvent events are called by user code on the server, and then invoked on corresponding client objects on clients connected to the server. The arguments to the Event call are serialized across the network, so that the client event is invoked with the same values as the method on the server. These events must begin with the prefix \"Event\". using UnityEngine; using Mirror; public class DamageClass : NetworkBehaviour { public delegate void TakeDamageDelegate(int amount, float dir); [SyncEvent] public event TakeDamageDelegate EventTakeDamage; [Command] public void CmdDoMe(int val) { EventTakeDamage(val, 1.0f); } } public class Other : NetworkBehaviour { public DamageClass damager; int health = 100; void Start() { if (NetworkClient.active) damager.EventTakeDamage += TakeDamage; } public void TakeDamage(int amount, float dir) { health -= amount; } } SyncEvents allow networked actions to be propagated to other scripts attached to the object. In the example above, the Other class registers for the TakeDamage event on the DamageClass. When the event happens on the DamageClass on the server, the TakeDamage() method will be invoked on the Other class on the client object. This allows modular network aware systems to be created, that can be extended by new scripts that respond to the events generated by them."
  },
  "Guides/Sync/index.html": {
    "href": "Guides/Sync/index.html",
    "title": "State Synchronization",
    "keywords": "State Synchronization State synchronization refers to the synchronization of values such as integers, floating point numbers, strings and boolean values belonging to scripts. State synchronization is done from the Server to remote clients. The local client does not have data serialized to it. It does not need it, because it shares the Scene with the server. However, SyncVar hooks are called on local clients. Data is not synchronized in the opposite direction - from remote clients to the server. To do this, you need to use Commands. SyncVars SyncVars are variables of scripts that inherit from NetworkBehaviour, which are synchronized from the server to clients. SyncEvents SyncEvents are networked events like ClientRpc’s, but instead of calling a function on the game object, they trigger Events instead. SyncLists SyncLists contain lists of values and synchronize data from servers to clients. SyncDictionary A SyncDictionary is an associative array containing an unordered list of key, value pairs. SyncHashSet An unordered set of values that do not repeat. SyncSortedSet A sorted set of values that do not repeat. Sync To Owner It is often the case when you don't want some player data visible to other players. In the inspector change the \"Network Sync Mode\" from \"Observers\" (default) to \"Owner\" to let Mirror know to synchronize the data only with the owning client. For example, suppose you are making an inventory system. Suppose player A,B and C are in the same area. There will be a total of 12 objects in the entire network: Client A has Player A (himself), Player B and Player C Client B has Player A , Player B (himself) and Player C Client C has Player A , Player B and Player C (himself) Server has Player A, Player B, Player C each one of them would have an Inventory component Suppose Player A picks up some loot. The server adds the loot to Player's A inventory, which would have a SyncLists of Items. By default, Mirror now has to synchronize player A's inventory everywhere, that means sending an update message to client A, client B and client C, because they all have a copy of Player A. This is wasteful, Client B and Client C do not need to know about Player's A inventory, they never see it on screen. It is also a security problem, someone could hack the client and display other people's inventory and use it to their advantage. If you set the \"Network Sync Mode\" in the Inventory component to \"Owner\", then Player A's inventory will only be synchronized with Client A. Now, suppose instead of 3 people you have 50 people in an area and one of them picks up loot. It means that instead of sending 50 messages to 50 different clients, you would only send 1. This can have a big impact in bandwith in your game. Other typical use cases include quests, player's hand in a card game, skills, experience, or any other data you don't need to share with other players. Advanced State Synchronization In most cases, the use of SyncVars is enough for your game scripts to serialize their state to clients. However in some cases you might require more complex serialization code. This page is only relevant for advanced developers who need customized synchronization solutions that go beyond Mirror’s normal SyncVar feature. Custom Serialization Functions To perform your own custom serialization, you can implement virtual functions on NetworkBehaviour to be used for SyncVar serialization. These functions are: public virtual bool OnSerialize(NetworkWriter writer, bool initialState); public virtual void OnDeserialize(NetworkReader reader, bool initialState); Use the initialState flag to differentiate between the first time a game object is serialized and when incremental updates can be sent. The first time a game object is sent to a client, it must include a full state snapshot, but subsequent updates can save on bandwidth by including only incremental changes. Note that SyncVar hook functions are not called when initialState is true; they are only called for incremental updates. If a class has SyncVars, then implementations of these functions are added automatically to the class, meaning that a class that has SyncVars cannot also have custom serialization functions. The OnSerialize function should return true to indicate that an update should be sent. If it returns true, the dirty bits for that script are set to zero. If it returns false, the dirty bits are not changed. This allows multiple changes to a script to be accumulated over time and sent when the system is ready, instead of every frame. Although this works, it is usually better to let Mirror generate these methods and provide custom serializers for your specific field. Serialization Flow Game objects with the Network Identity component attached can have multiple scripts derived from NetworkBehaviour . The flow for serializing these game objects is: On the server: Each NetworkBehaviour has a dirty mask. This mask is available inside OnSerialize as syncVarDirtyBits Each SyncVar in a NetworkBehaviour script is assigned a bit in the dirty mask. Changing the value of SyncVars causes the bit for that SyncVar to be set in the dirty mask Alternatively, calling SetDirtyBit writes directly to the dirty mask NetworkIdentity game objects are checked on the server as part of it’s update loop If any NetworkBehaviours on a NetworkIdentity are dirty, then an UpdateVars packet is created for that game object The UpdateVars packet is populated by calling OnSerialize on each NetworkBehaviour on the game object NetworkBehaviours that are not dirty write a zero to the packet for their dirty bits NetworkBehaviours that are dirty write their dirty mask, then the values for the SyncVars that have changed If OnSerialize returns true for a NetworkBehaviour , the dirty mask is reset for that NetworkBehaviour so it does not send again until its value changes. The UpdateVars packet is sent to ready clients that are observing the game object On the client: an UpdateVars packet is received for a game object The OnDeserialize function is called for each NetworkBehaviour script on the game object Each NetworkBehaviour script on the game object reads a dirty mask. If the dirty mask for a NetworkBehaviour is zero, the OnDeserialize function returns without reading any more If the dirty mask is non-zero value, then the OnDeserialize function reads the values for the SyncVars that correspond to the dirty bits that are set If there are SyncVar hook functions, those are invoked with the value read from the stream. So for this script: public class data : NetworkBehaviour { [SyncVar] public int int1 = 66; [SyncVar] public int int2 = 23487; [SyncVar] public string MyString = \"Example string\"; } The following code sample demonstrates the generated OnSerialize function: public override bool OnSerialize(NetworkWriter writer, bool forceAll) { if (forceAll) { // The first time a game object is sent to a client, send all the data (and no dirty bits) writer.WritePackedUInt32((uint)this.int1); writer.WritePackedUInt32((uint)this.int2); writer.Write(this.MyString); return true; } bool wroteSyncVar = false; if ((base.get_syncVarDirtyBits() & 1u) != 0u) { if (!wroteSyncVar) { // Write dirty bits if this is the first SyncVar written writer.WritePackedUInt32(base.get_syncVarDirtyBits()); wroteSyncVar = true; } writer.WritePackedUInt32((uint)this.int1); } if ((base.get_syncVarDirtyBits() & 2u) != 0u) { if (!wroteSyncVar) { // Write dirty bits if this is the first SyncVar written writer.WritePackedUInt32(base.get_syncVarDirtyBits()); wroteSyncVar = true; } writer.WritePackedUInt32((uint)this.int2); } if ((base.get_syncVarDirtyBits() & 4u) != 0u) { if (!wroteSyncVar) { // Write dirty bits if this is the first SyncVar written writer.WritePackedUInt32(base.get_syncVarDirtyBits()); wroteSyncVar = true; } writer.Write(this.MyString); } if (!wroteSyncVar) { // Write zero dirty bits if no SyncVars were written writer.WritePackedUInt32(0); } return wroteSyncVar; } The following code sample demonstrates the OnDeserialize function: public override void OnDeserialize(NetworkReader reader, bool initialState) { if (initialState) { this.int1 = (int)reader.ReadPackedUInt32(); this.int2 = (int)reader.ReadPackedUInt32(); this.MyString = reader.ReadString(); return; } int num = (int)reader.ReadPackedUInt32(); if ((num & 1) != 0) { this.int1 = (int)reader.ReadPackedUInt32(); } if ((num & 2) != 0) { this.int2 = (int)reader.ReadPackedUInt32(); } if ((num & 4) != 0) { this.MyString = reader.ReadString(); } } If a NetworkBehaviour has a base class that also has serialization functions, the base class functions should also be called. Note that the UpdateVar packets created for game object state updates may be aggregated in buffers before being sent to the client, so a single transport layer packet may contain updates for multiple game objects."
  },
  "Guides/Communications/NetworkMessages.html": {
    "href": "Guides/Communications/NetworkMessages.html",
    "title": "Network Messages",
    "keywords": "Network Messages For the most part we recommend the high level Commands and RPC calls and SyncVar , but you can also send low level network messages. This can be useful if you want clients to send messages that are not tied to game objects, such as logging, analytics or profiling information. There is a class called MessageBase that you can extend to make serializable network message classes. This class has Serialize and Deserialize functions that take writer and reader objects. You can implement these functions yourself, but we recommend you let Mirror generate them for you. The base class looks like this: public abstract class MessageBase { // Deserialize the contents of the reader into this message public virtual void Deserialize(NetworkReader reader) {} // Serialize the contents of this message into the writer public virtual void Serialize(NetworkWriter writer) {} } The auto generated Serialize/Deserialize can efficiently deal any supported mirror type . Make your members public. If you need class members or complex containers such as List and Dictionary, you must implement the Serialize and Deserialize methods yourself. To send a message, use the Send() method on the NetworkClient, NetworkServer, and NetworkConnection classes which work the same way. It takes a message object that is derived from MessageBase. The code below demonstrates how to send and handle a message: To declare a custom network message class and use it: using UnityEngine; using Mirror; public class Scores : MonoBehaviour { public class ScoreMessage : MessageBase { public int score; public Vector3 scorePos; public int lives; } public void SendScore(int score, Vector3 scorePos, int lives) { ScoreMessage msg = new ScoreMessage() { score = score, scorePos = scorePos, lives = lives }; NetworkServer.SendToAll(msg); } public void SetupClient() { NetworkClient.RegisterHandler<ScoreMessage>(OnScore); NetworkClient.Connect(\"localhost\"); } public void OnScore(NetworkConnection conn, ScoreMessage msg) { Debug.Log(\"OnScoreMessage \" + msg.score); } } Note that there is no serialization code for the ScoreMessage class in this source code example. The body of the serialization functions is automatically generated for this class by Mirror."
  },
  "Guides/Communications/NetworkBehavior.html": {
    "href": "Guides/Communications/NetworkBehavior.html",
    "title": "NetworkBehaviour Callbacks",
    "keywords": "NetworkBehaviour Callbacks See also NetworkBehaviour in the API Reference. Like the Network Manager callbacks, there are a number of events relating to network behaviours that can occur over the course of a normal multiplayer game. These include events such as the host starting up, a player joining, or a player leaving. Each of these possible events has an associated callback that you can implement in your own code to take action when the event occurs. When you create a script which inherits from NetworkBehaviour , you can write your own implementation of what should happen when these events occur. To do this, you override the virtual methods on the NetworkBehaviour class with your own implementation of what should happen when the given event occurs. This page lists all the virtual methods (callbacks) that you can implement on NetworkBehaviour , and when they occur. Server mode When a client connects: OnStartServer OnRebuildObservers Start() function is called Client mode When a client connects: OnStartClient OnStartLocalPlayer OnStartAuthority Start() function is called Host mode These are only called on the Player Game Objects when a client connects: OnStartServer OnStartClient OnRebuildObservers OnStartAuthority OnStartLocalPlayer Start() function is called OnSetLocalVisibility On any remaining clients, when a client disconnects: OnNetworkDestroy"
  },
  "Guides/Communications/RemoteActions.html": {
    "href": "Guides/Communications/RemoteActions.html",
    "title": "Remote Actions",
    "keywords": "Remote Actions The network system has ways to perform actions across the network. These type of actions are sometimes called Remote Procedure Calls. There are two types of RPCs in the network system, Commands - which are called from the client and run on the server; and ClientRpc calls - which are called on the server and run on clients. The diagram below shows the directions that remote actions take: Commands Commands are sent from player objects on the client to player objects on the server. For security, Commands can only be sent from YOUR player object, so you cannot control the objects of other players. To make a function into a command, add the [Command] custom attribute to it, and add the “Cmd” prefix. This function will now be run on the server when it is called on the client. Any arguments will automatically be passed to the server with the command. Commands functions must have the prefix “Cmd”. This is a hint when reading code that calls the command - this function is special and is not invoked locally like a normal function. public class Player : NetworkBehaviour { void Update() { if (!isLocalPlayer) return; if (Input.GetKey(KeyCode.X)) CmdDropCube(); } // assigned in inspector public GameObject cubePrefab; [Command] void CmdDropCube() { if (cubePrefab != null) { Vector3 spawnPos = transform.position + transform.forward * 2; Quaternion spawnRot = transform.rotation; GameObject cube = Instantiate(cubePrefab, spawnPos, spawnRot); NetworkServer.Spawn(cube); } } } Be careful of sending commands from the client every frame! This can cause a lot of network traffic. It is possible to send commands from non-player objects that have client authority. These objects must have been spawned with NetworkServer.SpawnWithClientAuthority or have authority set with NetworkIdentity.AssignClientAuthority . Commands sent from these object are run on the server instance of the object, not on the associated player object for the client. ClientRpc Calls ClientRpc calls are sent from objects on the server to objects on clients. They can be sent from any server object with a NetworkIdentity that has been spawned. Since the server has authority, then there no security issues with server objects being able to send these calls. To make a function into a ClientRpc call, add the [ClientRpc] custom attribute to it, and add the “Rpc” prefix. This function will now be run on clients when it is called on the server. Any arguments will automatically be passed to the clients with the ClientRpc call.. ClientRpc functions must have the prefix “Rpc”. This is a hint when reading code that calls the method - this function is special and is not invoked locally like a normal function. public class Player : NetworkBehaviour { int health; public void TakeDamage(int amount) { if (!isServer) return; health -= amount; RpcDamage(amount); } [ClientRpc] void RpcDamage(int amount) { Debug.Log(\"Took damage:\" + amount); } } When running a game as a host with a local client, ClientRpc calls will be invoked on the local client even though it is in the same process as the server. So the behaviours of local and remote clients are the same for ClientRpc calls. TargetRpc Calls TargetRpc functions are called by user code on the server, and then invoked on the corresponding client object on the client of the specified NetworkConnection. The arguments to the RPC call are serialized across the network, so that the client function is invoked with the same values as the function on the server. These functions must begin with the prefix \"Target\" and cannot be static. The first argument to an TargetRpc function must be a NetworkConnection object. This example shows how a client can use a Command to make a request from the server ( CmdMagic ) by including its own connectionToClient as one of the parameters of the TargetRpc invoked directly from that Command: public class Player : NetworkBehaviour { [Command] void CmdMagic(int damage) { TargetDoMagic(connectionToClient, damage); } [TargetRpc] public void TargetDoMagic(NetworkConnection target, int damage) { // This output will appear on the client that called the [Command] above Debug.LogFormat(\"Magic Damage = {0}\", damage); } } Arguments to Remote Actions The arguments passed to commands and ClientRpc calls are serialized and sent over the network. You can use any supported mirror type . Arguments to remote actions cannot be sub-components of game objects, such as script instances or Transforms."
  },
  "Guides/Communications/index.html": {
    "href": "Guides/Communications/index.html",
    "title": "Actions and Communication",
    "keywords": "Actions and Communication When you are making a multiplayer game, In addition to synchronizing the properties of networked game objects, you are likely to need to send, receive, and react to other pieces of information - such as when the match starts, when a player joins or leaves the match, or other information specific to your type of game, for example a notification to all players that a flag has been captured in a “capture-the-flag” style game. Within the Mirror networking High-Level API there are three main ways to communicate this type of information. Remote Actions Remote actions allow you to call a method in your script across the network. You can make the server call methods on all clients or individual clients specifically. You can also make clients call methods on the server. Using remote actions, you can pass data as parameters to your methods in a very similar way to how you call methods in local (non-multiplayer) projects. Networking Callbacks Networking callbacks allow you to hook into built-in Mirror events which occur during the course of the game, such as when players join or leave, when game objects are created or destroyed, or when a new Scene is loaded. There are two types of networking callbacks that you can implement: Network manager callbacks, for callbacks relating to the network manager itself (such as when clients connect or disconnect) Network behaviour callbacks, for callbacks relating to individual networked game objects (such as when its Start function is called, or what this particular game object should do if a new player joins the game) Network Messages Network messages are a “lower level” approach to sending messages (although they are still classed as part of the networking “High level API”). They allow you to send data directly between clients and the server using scripting. You can send basic types of data (int, string, etc) as well as most common Unity types (such as Vector3). Since you implement this yourself, these messages are not associated directly with any particular game objects or Unity events - it is up to you do decide their purpose and implement them!"
  },
  "Guides/Communications/NetworkManager.html": {
    "href": "Guides/Communications/NetworkManager.html",
    "title": "Network Manager Callbacks",
    "keywords": "Network Manager Callbacks See also NetworkManager in the API Reference. There are a number of events that can occur over the course of the normal operation of a multiplayer game, such as the host starting up, a player joining, or a player leaving. Each of these possible events has an associated callback that you can implement in your own code to take action when the event occurs. To do this for the NetworkManager , you need to create your own script which inherits from NetworkManager . You can then override the virtual methods on NetworkManager with your own implementation of what should happen when the given event occurs. This page lists all the virtual methods (the callbacks) that you can implement on the NetworkManager , and when they occur. The callbacks that occur, and the order they occur, vary slightly depending on which mode your game is running in, so each mode’s callbacks are listed separately below. A game can be running in one of three modes, host, client, or server-only. The callbacks for each mode are listed below: Host Mode: When the host is started: Start() function is called OnStartHost OnStartServer OnServerConnect OnStartClient OnClientConnect OnServerSceneChanged OnServerReady OnServerAddPlayer OnClientChangeScene OnClientSceneChanged When a client connects: OnServerConnect OnServerReady OnServerAddPlayer When a client disconnects: OnServerDisconnect When the host is stopped: OnStopHost OnStopServer OnStopClient Client Mode When the client starts: Start() function is called OnStartClient OnClientConnect OnClientChangeScene OnClientSceneChanged When the client stops: OnStopClient OnClientDisconnect Server Mode When the server starts: Start() function is called OnStartServer OnServerSceneChanged When a client connects: OnServerConnect OnServerReady OnServerAddPlayer When a client disconnects: OnServerDisconnect When the server stops: OnStopServer"
  },
  "Guides/GameObjects/SpawnObjectCustom.html": {
    "href": "Guides/GameObjects/SpawnObjectCustom.html",
    "title": "Custom Spawn Functions",
    "keywords": "Custom Spawn Functions You can use spawn handler functions to customize the default behavior when creating spawned game objects on the client. Spawn handler functions ensure you have full control of how you spawn the game object, as well as how you destroy it. Use ClientScene.RegisterSpawnHandler to register functions to spawn and destroy client game objects. The server creates game objects directly, and then spawns them on the clients through this functionality. This function takes the asset ID of the game object and two function delegates: one to handle creating game objects on the client, and one to handle destroying game objects on the client. The asset ID can be a dynamic one, or just the asset ID found on the prefab game object you want to spawn (if you have one). The spawn / unspawn delegates need to have this game object signature. This is defined in the high level API. // Handles requests to spawn game objects on the client public delegate GameObject SpawnDelegate(Vector3 position, System.Guid assetId); // Handles requests to unspawn game objects on the client public delegate void UnSpawnDelegate(GameObject spawned); The asset ID passed to the spawn function can be found on NetworkIdentity.assetId for prefabs, where it is populated automatically. The registration for a dynamic asset ID is handled like this: // generate a new unique assetId System.Guid creatureAssetId = System.Guid.NewGuid(); // register handlers for the new assetId ClientScene.RegisterSpawnHandler(creatureAssetId, SpawnCreature, UnSpawnCreature); // get assetId on an existing prefab System.Guid coinAssetId = coinPrefab.GetComponent<NetworkIdentity>().assetId; // register handlers for an existing prefab you'd like to custom spawn ClientScene.RegisterSpawnHandler(coinAssetId, SpawnCoin, UnSpawnCoin); // spawn a coin - SpawnCoin is called on client NetworkServer.Spawn(gameObject, coinAssetId); The spawn functions themselves are implemented with the delegate signature. Here is the coin spawner. The SpawnCreature would look the same, but have different spawn logic: public GameObject SpawnCoin(Vector3 position, System.Guid assetId) { return Instantiate(m_CoinPrefab, position, Quaternion.identity); } public void UnSpawnCoin(GameObject spawned) { Destroy(spawned); } When using custom spawn functions, it is sometimes useful to be able to unspawn game objects without destroying them. This can be done by calling NetworkServer.UnSpawn . This causes a message to be sent to clients to un-spawn the game object, so that the custom unspawn function will be called on the clients. The game object is not destroyed when this function is called. Note that on the host, game objects are not spawned for the local client, because they already exist on the server. This also means that no spawn handler functions are called. Setting Up a Game Object Pool with Custom Spawn Handlers Here is an example of how you might set up a very simple game object pooling system with custom spawn handlers. Spawning and unspawning then puts game objects in or out of the pool. using UnityEngine; using Mirror; using System.Collections; public class SpawnManager : MonoBehaviour { public int m_ObjectPoolSize = 5; public GameObject m_Prefab; public GameObject[] m_Pool; public System.Guid assetId { get; set; } public delegate GameObject SpawnDelegate(Vector3 position, System.Guid assetId); public delegate void UnSpawnDelegate(GameObject spawned); void Start() { assetId = m_Prefab.GetComponent<NetworkIdentity> ().assetId; m_Pool = new GameObject[m_ObjectPoolSize]; for (int i = 0; i < m_ObjectPoolSize; ++i) { m_Pool[i] = Instantiate(m_Prefab, Vector3.zero, Quaternion.identity); m_Pool[i].name = \"PoolObject\" + i; m_Pool[i].SetActive(false); } ClientScene.RegisterSpawnHandler(assetId, SpawnObject, UnSpawnObject); } public GameObject GetFromPool(Vector3 position) { foreach (var obj in m_Pool) { if (!obj.activeInHierarchy) { Debug.Log(\"Activating GameObject \" + obj.name + \" at \" + position); obj.transform.position = position; obj.SetActive (true); return obj; } } Debug.LogError (\"Could not grab game object from pool, nothing available\"); return null; } public GameObject SpawnObject(Vector3 position, System.Guid assetId) { return GetFromPool(position); } public void UnSpawnObject(GameObject spawned) { Debug.Log (\"Re-pooling game object \" + spawned.name); spawned.SetActive (false); } } To use this manager, create a new empty game object and name it “SpawnManager”. Create a new script called SpawnManager, copy in the code sample above, and attach it to the new SpawnManager game object. Next, drag a prefab you want to spawn multiple times to the Prefab field, and set the Object Pool Size (default is 5). Finally, set up a reference to the SpawnManager in the script you are using for player movement: SpawnManager spawnManager; void Start() { spawnManager = GameObject.Find(\"SpawnManager\").GetComponent<SpawnManager> (); } Your player logic might contain something like this, which moves and fires coins: void Update() { if (!isLocalPlayer) return; var x = Input.GetAxis(\"Horizontal\")*0.1f; var z = Input.GetAxis(\"Vertical\")*0.1f; transform.Translate(x, 0, z); if (Input.GetKeyDown(KeyCode.Space)) { // Command function is called on the client, but invoked on the server CmdFire(); } } In the fire logic on the player, make it use the game object pool: [Command] void CmdFire() { // Set up coin on server var coin = spawnManager.GetFromPool(transform.position + transform.forward); coin.GetComponent<Rigidbody>().velocity = transform.forward*4; // spawn coin on client, custom spawn handler is called NetworkServer.Spawn(coin, spawnManager.assetId); // when the coin is destroyed on the server, it is automatically destroyed on clients StartCoroutine (Destroy (coin, 2.0f)); } public IEnumerator Destroy(GameObject go, float timer) { yield return new WaitForSeconds (timer); spawnManager.UnSpawnObject(go); NetworkServer.UnSpawn(go); } The automatic destruction shows how the game objects are returned to the pool and re-used when you fire again."
  },
  "Guides/GameObjects/PickupDropChild.html": {
    "href": "Guides/GameObjects/PickupDropChild.html",
    "title": "Pickups, Drops, and Child Objects",
    "keywords": "Pickups, Drops, and Child Objects Frequently the question comes up about how to handle objects that are attached as children of the player prefab that all clients need to know about and synchronize, such as which weapon is equipped, picking up networked scene objects, and players dropping objects into the scene. Mirror cannot support multiple Network Identity components within an object hierarchy. Since the Player object must have a Network Identity, none of its descendant objects can have one. Child Objects Let's start with the simple case of a single attachment point that is somewhere down the hierarchy of our Player, such as a hand at the end of an arm. In a script that inherits from NetworkBehaviour on the Player Prefab, we'd have a GameObject reference where the attachment point can be assigned in the inspector, a SyncVar enum with various choices of what the player is holding, and and a Hook for the SyncVar to swap out the art of the held item based on the new value. In the image below, Kyle has an empty game object, RightHand , added to the wrist, and some prefabs to be equipped (Ball, Box, Cylinder), and a Player Equip script to handle them. NOTE : The item prefabs are art only ...they have no scripts, and they must not have networking components. They can have monobehaviour-based scripts, of course, which can be referenced and called from ClientRpc's on the player prefab. The inspector shows RightHand assigned in 2 places, the Player Equip script, as well as the target of the Network Transform Child component, so we could adjust the relative position of the attachment point (not the art) for all clients as needed. Below is the Player Equip script to handle the changing of the equipped item, and some notes for consideration: While we could just have all the art items attached at design time and just enable / disable them based on the enum, this doesn't scale well to a lot of items and if they have scripts on them for how they behave in the game, such as animations, special effects, etc. it could get ugly pretty fast, so this example locally instantiates and destroys instead as a design choice. The example makes no effort to deal with position offset between the item and the attach point, e.g. having the grip or handle of an item align with the hand. This is best dealt with in a monobehaviour script on the item that has public fields for the local position and rotation that can be set in the designer and a bit of code in Start to apply those values in local coordinates relative to the parent attach point. using UnityEngine; using System.Collections; using Mirror; public enum EquippedItem : byte { nothing, ball, box, cylinder } public class PlayerEquip : NetworkBehaviour { public GameObject sceneObjectPrefab; public GameObject rightHand; public GameObject ballPrefab; public GameObject boxPrefab; public GameObject cylinderPrefab; [SyncVar(hook = nameof(OnChangeEquipment))] public EquippedItem equippedItem; void OnChangeEquipment(EquippedItem newEquippedItem) { StartCoroutine(ChangeEquipment(newEquippedItem)); } // Since Destroy is delayed to the end of the current frame, we use a coroutine // to clear out any child objects before instantiating the new one IEnumerator ChangeEquipment(EquippedItem newEquippedItem) { while (rightHand.transform.childCount > 0) { Destroy(rightHand.transform.GetChild(0).gameObject); yield return null; } switch (newEquippedItem) { case EquippedItem.ball: Instantiate(ballPrefab, rightHand.transform); break; case EquippedItem.box: Instantiate(boxPrefab, rightHand.transform); break; case EquippedItem.cylinder: Instantiate(cylinderPrefab, rightHand.transform); break; } } void Update() { if (!isLocalPlayer) return; if (Input.GetKeyDown(KeyCode.Alpha0) && equippedItem != EquippedItem.nothing) CmdChangeEquippedItem(EquippedItem.nothing); if (Input.GetKeyDown(KeyCode.Alpha1) && equippedItem != EquippedItem.ball) CmdChangeEquippedItem(EquippedItem.ball); if (Input.GetKeyDown(KeyCode.Alpha2) && equippedItem != EquippedItem.box) CmdChangeEquippedItem(EquippedItem.box); if (Input.GetKeyDown(KeyCode.Alpha3) && equippedItem != EquippedItem.cylinder) CmdChangeEquippedItem(EquippedItem.cylinder); } [Command] void CmdChangeEquippedItem(EquippedItem selectedItem) { equippedItem = selectedItem; } } Dropping Items Now that we can equip the items, we need a way to drop the current item into the world as a networked item. Remember that, as child art, the item prefabs have no networking components on them at all. First, let's add one more Input to the Update method above, and a CmdDropItem method: void Update() { if (!isLocalPlayer) return; if (Input.GetKeyDown(KeyCode.Alpha0) && equippedItem != EquippedItem.nothing) CmdChangeEquippedItem(EquippedItem.nothing); if (Input.GetKeyDown(KeyCode.Alpha1) && equippedItem != EquippedItem.ball) CmdChangeEquippedItem(EquippedItem.ball); if (Input.GetKeyDown(KeyCode.Alpha2) && equippedItem != EquippedItem.box) CmdChangeEquippedItem(EquippedItem.box); if (Input.GetKeyDown(KeyCode.Alpha3) && equippedItem != EquippedItem.cylinder) CmdChangeEquippedItem(EquippedItem.cylinder); if (Input.GetKeyDown(KeyCode.X) && equippedItem != EquippedItem.nothing) CmdDropItem(); } [Command] void CmdDropItem() { // Instantiate the scene object on the server Vector3 pos = rightHand.transform.position; Quaternion rot = rightHand.transform.rotation; GameObject newSceneObject = Instantiate(sceneObjectPrefab, pos, rot); // set the RigidBody as non-kinematic on the server only (isKinematic = true in prefab) newSceneObject.GetComponent<Rigidbody>().isKinematic = false; SceneObject sceneObject = newSceneObject.GetComponent<SceneObject>(); // set the child object on the server sceneObject.SetEquippedItem(equippedItem); // set the SyncVar on the scene object for clients sceneObject.equippedItem = equippedItem; // set the player's SyncVar to nothing so clients will destroy the equipped child item equippedItem = EquippedItem.nothing; // Spawn the scene object on the network for all to see NetworkServer.Spawn(newSceneObject); } In the image above, there's a sceneObjectPrefab field that is assigned to a prefab that will act as a container for our item prefabs. The SceneObject prefab has a SceneObject script with a SyncVar like the Player Equip script, and a SetEquippedItem method that takes the shared enum value as a parameter. using UnityEngine; using System.Collections; using Mirror; public class SceneObject : NetworkBehaviour { [SyncVar(hook = nameof(OnChangeEquipment))] public EquippedItem equippedItem; public GameObject ballPrefab; public GameObject boxPrefab; public GameObject cylinderPrefab; void OnChangeEquipment(EquippedItem newEquippedItem) { StartCoroutine(ChangeEquipment(newEquippedItem)); } // Since Destroy is delayed to the end of the current frame, we use a coroutine // to clear out any child objects before instantiating the new one IEnumerator ChangeEquipment(EquippedItem newEquippedItem) { while (transform.childCount > 0) { Destroy(transform.GetChild(0).gameObject); yield return null; } // Use the new value, not the SyncVar property value SetEquippedItem(newEquippedItem); } // SetEquippedItem is called on the client from OnChangeEquipment (above), // and on the server from CmdDropItem in the PlayerEquip script. public void SetEquippedItem(EquippedItem newEquippedItem) { switch (newEquippedItem) { case EquippedItem.ball: Instantiate(ballPrefab, transform); break; case EquippedItem.box: Instantiate(boxPrefab, transform); break; case EquippedItem.cylinder: Instantiate(cylinderPrefab, transform); break; } } } In the run-time image below, the Ball(Clone) is attached to the RightHand object, and the Box(Clone) is attached to the SceneObject(Clone), which is shown in the inspector. The art prefabs have simple colliders on them (sphere, box, capsule). If your art item has a mesh collider, it must be marked as Convex to work with the RigidBody on the SceneObject container. Pickup Items Now that we have a box dropped in the scene, we need to pick it up again. To do that, a CmdPickupItem method is added to the Player Equip script: // CmdPickupItem is public because it's called from a script on the SceneObject [Command] public void CmdPickupItem(GameObject sceneObject) { // set the player's SyncVar so clients can show the equipped item equippedItem = sceneObject.GetComponent<SceneObject>().equippedItem; // Destroy the scene object NetworkServer.Destroy(sceneObject); } This method is simply called from OnMouseDown in the Scene Object script: void OnMouseDown() { NetworkClient.connection.identity.GetComponent<PlayerEquip>().CmdPickupItem(gameObject); } Since the SceneObject(Clone) is networked, we can pass it directly through to CmdPickupItem on the player object to set the equipped item SyncVar and destroy the scene object. For this entire example, the only prefab that needs to be registered with Network Manager besides the Player is the SceneObject prefab."
  },
  "Guides/GameObjects/SpawnPlayer.html": {
    "href": "Guides/GameObjects/SpawnPlayer.html",
    "title": "Player Game Objects",
    "keywords": "Player Game Objects Mirror’s multiplayer HLAPI system handles player game objects differently to non-player game objects. When a new player joins the game (when a new client connects to the server), that player’s game object becomes a “local player” game object on the client of that player, and Unity associates the player’s connection with the player’s game object. Unity associates one player game object for each person playing the game, and routes networking commands to that individual game object. A player cannot invoke a command on another player’s game object, only their own. The NetworkBehaviour class (which you derive from to create your network scripts) has a property called isLocalPlayer. On each client’s player game object, Mirror sets that property to true on the NetworkBehaviour script, and invokes the OnStartLocalPlayer() callback. This means each client has a different game object set up like this, because on each client a different game object is the one that represents the local player. The diagram below shows two clients and their local players. Only the player game object that is “yours” (from your point of view as the player) has the isLocalPlayer flag set. Usually you should set this flag in script to determine whether to process input, whether to make the camera track the game object, or do any other client-side things that should only occur for the player belonging to that client. Player game objects represent the player (that is, the person playing the game) on the server, and have the ability to run commands from the player’s client. These commands are secure client-to-server remote procedure calls. In this server-authoritative system, other non-player server-side game objects cannot receive commands directly from client-side game objects. This is both for security, and to reduce the complexity of building your game. By routing all incoming commands from users through the player game object, you can ensure that these messages come from the right place, the right client, and can be handled in a central location. The Network Manager adds a player every time a client connects to the server. In some situations though, you might want it not to add players until an input event happens - such as a user pressing a “start” button on the controller. To disable automatic player creation, navigate to the Network Manager component’s Inspector and untick the Auto Create Player checkbox."
  },
  "Guides/GameObjects/SpawnPlayerCustom.html": {
    "href": "Guides/GameObjects/SpawnPlayerCustom.html",
    "title": "Custom Character Spawning",
    "keywords": "Custom Character Spawning Many games need character customization. You may want to pick the color of the hair, eyes, skin, height, race, etc. By default Mirror will instantiate the player for you. While that is convenient, it might prevent you from customizing it. Mirror provides the option of overriding player creation and customize it. Create a class that extends NetworkManager if you have not done so. For example: public class MMONetworkManager : NetworkManager { ... } and use it as your Network manager. Open your Network Manager in the inspector and disable the \"Auto Create Player\" Boolean. Create a message that describes your player. For example: public class CreateMMOCharacterMessage : MessageBase { public Race race; public string name; public Color hairColor; public Color eyeColor; } public enum Race { None, Elvish, Dwarvish, Human } Create your player prefabs (as many as you need) and add them to the \"Register Spawnable Prefabs\" in your Network Manager, or add a single prefab to the player prefab field in the inspector. Send your message and register a player: public class MMONetworkManager : NetworkManager { public override void OnStartServer() { base.OnStartServer(); NetworkServer.RegisterHandler<CreateMMOCharacterMessage>(OnCreateCharacter); } public override void OnClientConnect(NetworkConnection conn) { base.OnClientConnect(conn); // you can send the message here, or wherever else you want CreateMMOCharacterMessage characterMessage = new CreateMMOCharacterMessage { race = Race.Elvish, name = \"Joe Gaba Gaba\", hairColor = Color.red, eyeColor = Color.green }; conn.Send(characterMessage); } void OnCreateCharacter(NetworkConnection conn, CreateMMOCharacterMessage message) { // playerPrefab is the one assigned in the inspector in Network // Manager but you can use different prefabs per race for example GameObject gameobject = Instantiate(playerPrefab); // Apply data from the message however appropriate for your game // Typically Player would be a component you write with syncvars or properties Player player = gameobject.GetComponent<Player>(); player.hairColor = message.hairColor; player.eyeColor = message.eyeColor; player.name = message.name; player.race = message.race; // call this to use this gameobject as the primary controller NetworkServer.AddPlayerForConnection(conn, gameobject); } } Ready State In addition to players, client connections also have a “ready” state. The host sends clients that are ready information about spawned game objects and state synchronization updates; clients which are not ready are not sent these updates. When a client initially connects to a server, it is not ready. While in this non-ready state, the client can do things that don’t require real-time interactions with the game state on the server, such as loading Scenes, allowing the player to choose an avatar, or fill in log-in boxes. Once a client has completed all its pre-game work, and all its Assets are loaded, it can call ClientScene.Ready to enter the “ready” state. The simple example above demonstrates implementation of ready states; because adding a player with NetworkServer.AddPlayerForConnection also puts the client into the ready state if it is not already in that state. Clients can send and receive network messages without being ready, which also means they can do so without having an active player game object. So a client at a menu or selection screen can connect to the game and interact with it, even though they have no player game object. See documentation on Network Messages for more details about sending messages without using commands and RPC calls. Switching Players To replace the player game object for a connection, use NetworkServer.ReplacePlayerForConnection . This is useful for restricting the commands that players can issue at certain times, such as in a pregame room screen. This function takes the same arguments as AddPlayerForConnection , but allows there to already be a player for that connection. The old player game object does not have to be destroyed. The NetworkRoomManager uses this technique to switch from the NetworkRoomPlayer game object to a game play player game object when all the players in the room are ready. You can also use ReplacePlayerForConnection to respawn a player or change the object that represents the player. In some cases it is better to just disable a game object and reset its game attributes on respawn. The following code sample demonstrates how to actually replace the player game object with a new game object: public class MyNetworkManager : NetworkManager { public void ReplacePlayer(GameObject newPrefab) { NetworkConnection conn = NetworkClient.connection; // Cache a reference to the current player object GameObject oldPlayer = conn.identity.gameObject; // Instantiate the new player object and broadcast to clients NetworkServer.ReplacePlayerForConnection(conn, Instantiate(newPrefab)); // Remove the previous player object that's now been replaced NetworkServer.Destroy(oldPlayer); } } If the player game object for a connection is destroyed, then that client cannot execute Commands. They can, however, still send network messages. To use ReplacePlayerForConnection you must have the NetworkConnection game object for the player’s client to establish the relationship between the game object and the client. This is usually the property connectionToClient on the NetworkBehaviour class, but if the old player has already been destroyed, then that might not be readily available. To find the connection, there are some lists available. If using the NetworkRoomManager , then the room players are available in roomSlots . The NetworkServer also has lists of connections ."
  },
  "Guides/GameObjects/SpawnObject.html": {
    "href": "Guides/GameObjects/SpawnObject.html",
    "title": "Spawning Game Objects",
    "keywords": "Spawning Game Objects In Mirror, you usually “spawn” (that is, create) new game objects with Instantiate . However, in the multiplayer High Level API, the word “spawn” means something more specific. In the server-authoritative model of the HLAPI, to “spawn” a game object on the server means that the game object is created on clients connected to the server, and is managed by the spawning system. Once the game object is spawned using this system, state updates are sent to clients whenever the game object changes on the server. When Mirror destroys the game object on the server, it also destroys it on the clients. The server manages spawned game objects alongside all other networked game objects, so that if another client joins the game later, the server can spawn the game objects on that client. These spawned game objects have a unique network instance ID called “netId” that is the same on the server and clients for each game object. The unique network instance ID is used to route messages set across the network to game objects, and to identify game objects. When the server spawns a game object with a Network Identity component, the game object spawned on the client has the same “state”. This means it is identical to the game object on the server; it has the same Transform, movement state, and (if Network Transform and SyncVars are used) synchronized variables. Therefore, client game objects are always up-to-date when Mirror creates them. This avoids issues such as game objects spawning at the wrong initial location, then reappearing at their correct position when a state update arrives. The Network Manager before trying to register it with the Network Manager. To register a Prefab with the Network Manager in the Editor, select the Network Manager game object, and in the Inspector, navigate to the Network Manager component. Click the triangle next to Spawn Info to open the settings, then under Registered Spawnable Prefabs, click the plus (+) button. Drag and drop Prefabs into the empty field to assign them to the list. Spawning Without Network Manager For more advanced users, you may find that you want to register Prefabs and spawn game objects without using the Network Manager component. To spawn game objects without using the Network Manager, you can handle the Prefab registration yourself via script. Use the ClientScene.RegisterPrefab method to register Prefabs to the Network Manager. using UnityEngine; using Mirror; public class MyNetworkManager : MonoBehaviour { public GameObject treePrefab; // Register prefab and connect to the server public void ClientConnect() { ClientScene.RegisterPrefab(treePrefab); NetworkClient.RegisterHandler<ConnectMessage>(OnClientConnect); NetworkClient.Connect(\"localhost\"); } void OnClientConnect(NetworkConnection conn, ConnectMessage msg) { Debug.Log(\"Connected to server: \" + conn); } } In this example, you create an empty game object to act as the Network Manager, then create and attach the MyNetworkManager script (above) to that game object. Create a prefab that has a Network Identity component attached to it, and drag that onto the treePrefab slot on the MyNetworkManager component in the Inspector. This ensures that when the server spawns the tree game object, it also creates the same kind of game object on the clients. Registering prefabs ensures that there is no stalling or loading time for creating the Asset. For the script to work, you also need to add code for the server. Add this to the MyNetworkManager script: public void ServerListen() { NetworkServer.RegisterHandler<ConnectMessage>(OnServerConnect); NetworkServer.RegisterHandler<ReadyMessage>(OnClientReady); if (NetworkServer.Listen(7777)) Debug.Log(\"Server started listening on port 7777\"); } // When client is ready spawn a few trees void OnClientReady(NetworkConnection conn, ReadyMessage msg) { Debug.Log(\"Client is ready to start: \" + conn); NetworkServer.SetClientReady(conn); SpawnTrees(); } void SpawnTrees() { int x = 0; for (int i = 0; i < 5; ++i) { GameObject treeGo = Instantiate(treePrefab, new Vector3(x++, 0, 0), Quaternion.identity); NetworkServer.Spawn(treeGo); } } void OnServerConnect(NetworkConnection conn, ConnectMessage msg) { Debug.Log(\"New client connected: \" + conn); } The server does not need to register anything, as it knows what game object is being spawned (and the asset ID is sent in the spawn message). The client needs to be able to look up the game object, so it must be registered on the client. When writing your own network manager, it’s important to make the client ready to receive state updates before calling the spawn command on the server, otherwise they won’t be sent. If you’re using Mirror’s built-in Network Manager component, this happens automatically. For more advanced uses, such as object pools or dynamically created Assets, you can use the ClientScene.RegisterSpawnHandler method, which allows callback functions to be registered for client-side spawning. See documentation on Custom Spawn Functions for an example of this. If the game object has a network state like synchronized variables, then that state is synchronized with the spawn message. In the following example, this script is attached to the tree Prefab: using UnityEngine; using Mirror; class Tree : NetworkBehaviour { [SyncVar] public int numLeaves; public override void OnStartClient() { Debug.Log(\"Tree spawned with leaf count \" + numLeaves); } } With this script attached, you can change the numLeaves variable and modify the SpawnTrees function to see it accurately reflected on the client: void SpawnTrees() { int x = 0; for (int i = 0; i < 5; ++i) { GameObject treeGo = Instantiate(treePrefab, new Vector3(x++, 0, 0), Quaternion.identity); Tree tree = treeGo.GetComponent<Tree>(); tree.numLeaves = Random.Range(10,200); Debug.Log(\"Spawning leaf with leaf count \" + tree.numLeaves); NetworkServer.Spawn(treeGo); } } Attach the Tree script to the treePrefab script created earlier to see this in action. Constraints A NetworkIdentity must be on the root game object of a spawnable Prefab. Without this, the Network Manager can’t register the Prefab. NetworkBehaviour scripts must be on the same game object as the NetworkIdentity, not on child game objects Game Object Creation Flow The actual flow of internal operations that takes place for spawning game objects is: Prefab with Network Identity component is registered as spawnable. game object is instantiated from the Prefab on the server. Game code sets initial values on the instance (note that 3D physics forces applied here do not take effect immediately). NetworkServer.Spawn is called with the instance. The state of the SyncVars on the instance on the server are collected by calling OnSerialize on [Network Behaviour] components. A network message of type ObjectSpawn is sent to connected clients that includes the SyncVar data. OnStartServer is called on the instance on the server, and isServer is set to true Clients receive the ObjectSpawn message and create a new instance from the registered Prefab. The SyncVar data is applied to the new instance on the client by calling OnDeserialize on Network Behaviour components. OnStartClient is called on the instance on each client, and isClient is set to true As game play progresses, changes to SyncVar values are automatically synchronized to clients. This continues until game ends. NetworkServer.Destroy is called on the instance on the server. A network message of type ObjectDestroy is sent to clients. OnNetworkDestroy is called on the instance on clients, then the instance is destroyed. Player Game Objects Player game objects in the HLAPI work slightly differently to non-player game objects. The flow for spawning player game objects with the Network Manager is: Prefab with NetworkIdentity is registered as the PlayerPrefab Client connects to the server Client calls AddPlayer , network message of type MsgType.AddPlayer is sent to the server Server receives message and calls NetworkManager.OnServerAddPlayer game object is instantiated from the Player Prefab on the server NetworkManager.AddPlayerForConnection is called with the new player instance on the server The player instance is spawned - you do not have to call NetworkServer.Spawn for the player instance. The spawn message is sent to all clients like on a normal spawn. A network message of type Owner is sent to the client that added the player (only that client!) The original client receives the network message OnStartLocalPlayer is called on the player instance on the original client, and isLocalPlayer is set to true Note that OnStartLocalPlayer is called after OnStartClient , because it only happens when the ownership message arrives from the server after the player game object is spawned, so isLocalPlayer is not set in OnStartClient . Because OnStartLocalPlayer is only called for the client’s local player game object, it is a good place to perform initialization that should only be done for the local player. This could include enabling input processing, and enabling camera tracking for the player game object. Spawning Game Objects with Client Authority To spawn game objects and assign authority of those game objects to a particular client, use NetworkServer.SpawnWithClientAuthority , which takes as an argument the NetworkConnection of the client that is to be made the authority. For these game objects, the property hasAuthority is true on the client with authority, and OnStartAuthority is called on the client with authority. That client can issue commands for that game object. On other clients (and on the host), hasAuthority is false. Objects spawned with client authority must have LocalPlayerAuthority set in their NetworkIdentity . For example, the tree spawn example above can be modified to allow the tree to have client authority like this (note that we now need to pass in a NetworkConnection game object for the owning client’s connection): void SpawnTrees(NetworkConnection conn) { int x = 0; for (int i = 0; i < 5; ++i) { GameObject treeGo = Instantiate(treePrefab, new Vector3(x++, 0, 0), Quaternion.identity); Tree tree = treeGo.GetComponent<Tree>(); tree.numLeaves = Random.Range(10,200); Debug.Log(\"Spawning leaf with leaf count \" + tree.numLeaves); NetworkServer.SpawnWithClientAuthority(treeGo, conn); } } The Tree script can now be modified to send a command to the server: public override void OnStartAuthority() { CmdMessageFromTree(\"Tree with \" + numLeaves + \" reporting in\"); } [Command] void CmdMessageFromTree(string msg) { Debug.Log(\"Client sent a tree message: \" + msg); } Note that you can’t just add the CmdMessageFromTree call into OnStartClient , because at that point the authority has not been set yet, so the call would fail."
  },
  "Guides/GameObjects/index.html": {
    "href": "Guides/GameObjects/index.html",
    "title": "Networked Game Objects",
    "keywords": "Networked Game Objects Networked game objects are game objects which are controlled and synchronized by Mirror’s networking system. Using synchronized networked game objects, you can create a shared experience for all the players who are playing an instance of your game. They see and hear the same events and actions - even though that may be from their own unique viewpoints within your game. Multiplayer games in Mirror are typically built using Scenes that contain a mix of networked game objects and regular (non-networked) game objects. The networked game objects are those which move or change during gameplay in a way that needs to be synchronized across all users who are playing the game together. Non-networked game objects are those which either don’t move or change at all during gameplay (for example, static obstacles like rocks or fences), or game objects which have movement or changes that don’t need to be synchronized across players (for example, a gently swaying tree or clouds passing by in the background of your game). A networked game object is one which has a Network Identity component attached. However, a Network Identity component alone is not enough for your game object to be functional and active in your multiplayer game. The Network Identity component is the starting point for synchronization, and it allows the Network Manager to synchronize the creation and destruction of the game object, but other than that, it does not specify which properties of your game object should be synchronized. What exactly should be synchronized on each networked game object depends on the type of game you are making, and what each game object’s purpose is. Some examples of what you might want to synchronize are: The position and rotation of moving game objects such as the players and non-player characters. The animation state of an animated game object The value of a variable, for example how much time is left in the current round of a game, or how much energy a player has. Some of these things can be automatically synchronized by Mirror. The synchronized creation and destruction of networked game objects is managed by the NetworkManager, and is known as Spawning. You can use the Network Transform component to synchronize the position and rotation of a game object, and you can use the Network Animator component to synchronize the animation of a game object. To synchronize other properties of a networked game object, you need to use scripting. See State Synchronization for more information about this."
  },
  "Guides/GameObjects/SceneObjects.html": {
    "href": "Guides/GameObjects/SceneObjects.html",
    "title": "Scene Game Objects",
    "keywords": "Scene Game Objects There are two types of networked game objects in Mirror’s multiplayer system: Those that are created dynamically at runtime Those that are saved as part of a Scene Game objects that are created dynamically at runtime use the multiplayer Spawning system, and the prefabs they are instantiated from must be registered in the Network Manager’s list of networked game object prefabs. However, networked game objects that you save as part of a Scene (and therefore already exist in the Scene when it is loaded) are handled differently. These game objects are loaded as part of the Scene on both the client and server, and exist at runtime before any spawn messages are sent by the multiplayer system. When the Scene is loaded, all networked game objects in the Scene are disabled on both the client and the server. Then, when the Scene is fully loaded, the Network Manager automatically processes the Scene’s networked game objects, registering them all (and therefore causing them to be synchronized across clients), and enabling them, as if they were spawned at runtime. Networked game objects will not be enabled until a client has requested a Player object. Saving networked game objects in your Scene (rather than dynamically spawning them after the scene has loaded) has some benefits: They are loaded with the level, so there will be no pause at runtime. They can have specific modifications that differ from prefabs Other game object instances in the Scene can reference them, which can avoid you having to use code to finding the game objects and make references to them up at runtime. When the Network Manager spawns the networked Scene game objects, those game objects behave like dynamically spawned game objects. Mirror sends them updates and ClientRPC calls. If a Scene game object is destroyed on the server before a client joins the game, then it is never enabled on new clients that join. When a client connects, the client is sent an ObjectSpawnScene spawn message for each of the Scene game objects that exist on the server, that are visible to that client. This message causes the game object on the client to be enabled, and has the latest state of that game object from the server in it. This means that only game objects that are visible to the client, and not destroyed on the server, are activated on the client. Like regular non-Scene game objects, these Scene game objects are started with the latest state when the client joins the game."
  },
  "Guides/Authentication.html": {
    "href": "Guides/Authentication.html",
    "title": "Authentication",
    "keywords": "Authentication When you have a multiplayer game, often you need to store information about your player for later games, keep game stats or communicate with your friends. For all these use cases, you often need a way to uniquely identify a user. Being able to tell users apart is called authentication. There are several methods available, some examples include: Ask the user for username and password Use a third party oath or OpenID identity provider, such as Facebook, Twitter, Google Use a third party service such as PlayFab, GameLift or Steam Use the device id, very popular method in mobile Use Google Play in Android Use Game Center in IOS Use a web service in your website Encryption Warning By default Mirror uses Telepathy, which is not encrypted, so if you want to do authentication through Mirror, we highly recommend you use a transport that supports encryption. Message Registration By default all messages registered to NetworkServer and NetworkClient require authentication unless explicitly indicated otherwise. To register messages to bypass authentication, you need to specify false for a new bool parameter to the RegisterMessage method: NetworkServer.RegisterHandler<ConnectMessage>(OnServerConnectInternal, false); Certain internal messages already have been set to bypass authentication: Server ConnectMessage DisconnectMessage ErrorMessage NetworkPingMessage Client ConnectMessage DisconnectMessage ErrorMessage SceneMessage NetworkPongMessage Basic Authenticator Mirror includes a Basic Authenticator in the Mirror / Authenticators folder which just uses a simple username and password. Custom Authenticators Authenticators are derived from an Authenticator abstract class that allows you to implement any authentication scheme you need. To make your Authenticator, create a class that inherits from Authenticator and override the methods as needed. - When a client is successfully authenticated, call base.OnServerAuthenticated.Invoke(conn) on the server and base.OnClientAuthenticated.Invoke(conn) on the client. Mirror is listening for these events to proceed with the connection sequence. Subscribe to OnServerAuthenticated and OnClientAuthenticated events if you wish to perform additional steps after authentication. Tips Register handlers for messages in OnStartServer and OnStartClient . They're called from StartServer/StartHost, and StartClient, respectively. Send a message to the client if authentication fails, especially if there's some issue they can resolve. Call the Disconnect() method of the NetworkConnection on the server and client when authentication fails. If you want to give the user a few tries to get their credentials right, you certainly can, but Mirror will not do the disconnect for you. Remember to put a small delay on the Disconnect call on the server if you send a failure message so that it has a chance to be delivered before the connection is dropped. NetworkConnection has an AuthenticationData object where you can drop a class instance of any data you need to persist on the server related to the authentication, such as account id's, tokens, character selection, etc. Now that you have the foundation of a custom Authenticator component, the rest is up to you. You can exchange any number of custom messages between the server and client as necessary to complete your authentication process before approving the client. If you write a good authenticator, consider sharing it with other users or donating it to the mirror project."
  },
  "Components/Authenticators/Google.html": {
    "href": "Components/Authenticators/Google.html",
    "title": "Google Authenticator",
    "keywords": "Google Authenticator Coming Soon"
  },
  "Components/Authenticators/Basic.html": {
    "href": "Components/Authenticators/Basic.html",
    "title": "Basic Authenticator",
    "keywords": "Basic Authenticator Mirror includes a Basic Authenticator in the Mirror / Authenticators folder which just uses a simple username and password. Drag the Basic Authenticator script to the inspector of the object in your scene that has Network Manager The Basic Authenticator component will automatically be assigned to the Authenticator field in Network Manager When you're done, it should look like this: Note: You don't need to assign anything to the event lists unless you want to subscribe to the events in your own code for your own purposes. Mirror has internal listeners for both events."
  },
  "Components/Authenticators/PlayFab.html": {
    "href": "Components/Authenticators/PlayFab.html",
    "title": "PlayFab Authenticator",
    "keywords": "PlayFab Authenticator Coming Soon"
  },
  "Components/Authenticators/Facebook.html": {
    "href": "Components/Authenticators/Facebook.html",
    "title": "Facebook Authenticator",
    "keywords": "Facebook Authenticator Coming Soon"
  },
  "Components/Authenticators/index.html": {
    "href": "Components/Authenticators/index.html",
    "title": "Authentication",
    "keywords": "Authentication When you have a multiplayer game, often you need to store information about your player for later games, keep game stats or communicate with your friends. For all these use cases, you often need a way to uniquely identify a user. Being able to tell users apart is called authentication. There are several methods available, some examples include: Ask the user for username and password Use a third party oath or OpenID identity provider, such as Facebook, Twitter, Google Use a third party service such as PlayFab, GameLift or Steam Use the device id, very popular method in mobile Use Google Play in Android Use Game Center in IOS Use a web service in your website In addition to the Authenticators listed below, you can make your own! Check out this Guide for details. Authenticators Basic Authenticator Mirror includes a Basic Authenticator in the Mirror / Authenticators folder which just uses a simple username and password. PlayFab Authenticator Coming Soon Facebook Authenticator Coming Soon Google Authenticator Coming Soon"
  },
  "Components/NetworkIdentity.html": {
    "href": "Components/NetworkIdentity.html",
    "title": "NetworkIdentity",
    "keywords": "NetworkIdentity See also NetworkIdentity in the API Reference. The Network Identity component is at the heart of the Unity networking high-level API. It controls a game object’s unique identity on the network, and it uses that identity to make the networking system aware of the game object. It offers two different options for configuration and they are mutually exclusive, which means either one of the options or none can be checked. Server Only Tick this checkbox to ensure that Unity only spawns the game object on the server, and not on clients. Instantiated Network Game Objects With the Mirror’s server-authoritative networking system, the server must spawn networked game objects with network identities, using NetworkServer.Spawn . This automatically creates them on clients that are connected to the server, and assigns them a netId . You must put a Network Identity component on any Prefabs that spawn at runtime for the network system to use them. See Object Spawning for more information. Scene-based Network Game Objects You can also network game objects that are saved as part of your Scene (for example, environmental props). Networking game objects makes them behave slightly differently, because you need to have them spawn across the network. When building your game, Unity disables all Scene-based game objects with Network Identity components. When a client connects to the server, the server sends spawn messages to tell the client which Scene game objects to enable and what their most up-to-date state information is. This ensures the client’s game does not contain game objects at incorrect locations when they start playing, or that Unity does not spawn and immediately destroy game objects on connection (for example, if an event removed the game object before that client connected). See Networked Scene Game Objects for more information. Preview Pane Information This component contains network tracking information, and displays that information in the preview pane. For example, the scene ID, network ID and asset ID the object has been assigned. This allows you to inspect the information which can be useful for investigation and debugging. At runtime there is more information to display here (a disabled NetworkBehaviour is displayed non-bold):"
  },
  "Components/index.html": {
    "href": "Components/index.html",
    "title": "Components Overview",
    "keywords": "Components Overview These core components are included in Mirror: NetworkAnimator The Network Animator component allows you to synchronize animation states for networked objects. It synchronizes state and parameters from an Animator Controller. NetworkIdentity The Network Identity component is at the heart of the Mirror networking high-level API. It controls a game object’s unique identity on the network, and it uses that identity to make the networking system aware of the game object. It offers two different options for configuration and they are mutually exclusive, which means either one of the options or none can be checked. NetworkManager The Network Manager is a component for managing the networking aspects of a multiplayer game. NetworkManagerHUD The Network Manager HUD is a quick-start tool to help you start building your multiplayer game straight away, without first having to build a user interface for game creation/connection/joining. It allows you to jump straight into your gameplay programming, and means you can build your own version of these controls later in your development schedule. NetworkProximityChecker The Network Proximity Checker component controls the visibility of game objects for network clients, based on proximity to players. NetworkRoomManager The Network Room Manager is an extension component of Network Manager that provides a basic functional room. NetworkRoomPlayer The Network Room Player is a component that's required on Player prefabs used in the Room Scene with the Network Room Manager above. NetworkStartPosition Network Start Position is used by the Network Manager when creating player objects. The position and rotation of the Network Start Position are used to place the newly created player object. NetworkTransform The Network Transform component synchronizes the movement and rotation of game objects across the network. Note that the network Transform component only synchronizes spawned networked game objects. NetworkTransformChild The Network Transform Child component synchronizes the position and rotation of the child game object of a game object with a Network Transform component. Authenticators Authenticators are also available and more will be added soon: Basic Authenticator Mirror includes a Basic Authenticator in the Mirror / Authenticators folder which just uses a simple username and password. PlayFab Authenticator Coming Soon Facebook Authenticator Coming Soon Google Authenticator Coming Soon"
  },
  "Components/NetworkManagerHUD.html": {
    "href": "Components/NetworkManagerHUD.html",
    "title": "NetworkManagerHUD",
    "keywords": "NetworkManagerHUD The Network Manager HUD (“heads-up display”) is a quick-start tool to help you start building your multiplayer game straight away, without first having to build a user interface for game creation/connection/joining. It allows you to jump straight into your game play programming, and means you can build your own version of these controls later in your development schedule. It is not, however, intended to be included in finished games. The idea is that these controls are useful to get you started, but you should create your own UI later on, to allow your players to find and join games in a way that suits your game. For example, you might want to stylize the design of the screens, buttons and list of available games to match the overall style of your game. To start using the Network Manager HUD, either add the component to the same scene object that has the Network Manager component, or create an empty game object in your scene (menu: game object > Create Empty) and add the Network Manager HUD component to the new game object. Show GUI Tick this checkbox to show the HUD GUI at run time. This allows you to reveal or hide it for quick debugging. Offset X Set the horizontal pixel offset of the HUD GUI, measured from the left edge of the screen. Offset Y Set the vertical pixel offset of the HUD GUI, measured from the top edge of the screen. The Network Manager HUD provides the basic functions so that people playing your game can start hosting a networked game, or find and join an existing networked game. Unity displays the Network Manager HUD as a collection of simple UI buttons in the Game view. Using the HUD The Network Manager HUD starts in LAN Host mode, and displays buttons relating to hosting and joining a multiplayer game. LAN Host Click the LAN Host button to start a game as a host on the local network. This client is both the host and one of the players in the game. It uses the information from the Network Info section in the inspector to host the game. When you click this button, the HUD switches to a simple display of network details, and a Stop button which allows you to stop hosting the game and return to the main HUD menu. When you have started a game as a host, other players of the game can then connect to the host to join the game. Click the Stop button to disconnect from the host. Clicking Stop also returns to the main HUD menu. LAN Client To connect to a host on the internet use the text field to the right of the LAN Client button to specify the address of the host. The default host address is “localhost”, which means the client looks on its own computer for the game host. In addition to localhost , you can specify an IPv4 address, and IPv6 address, or a fully-qualified domain name (FQDN), e.g. game.example.com , and the transport with resolve the name using DNS. Click LAN Client to attempt to connect to the host address you have specified. Use the default “localhost” in this field if you are running multiple instances of your game on one computer, to test multiplayer interactivity. To do this, you can create a standalone build of your game, and then launch it multiple times on your computer. This is a common way to quickly test that your networked game interactions are functioning as you expect, without you needing to deploy your game to multiple computers or devices. When you want to test your game on multiple machines you need to put the address of the computer acting as host into the address text field. The computer acting as the host needs to tell their IP address to everyone running clients, so that you can type this into the box. For local clients on a LAN, that's the local IP address. For remote clients, that's the WAN IP address of the router of the host. Firewall rules and port-forwarding are generally required for a computer to act as host and accept connections from other computers, whether they're on the LAN or the internet. Enter the IP address (or leave it as “localhost” if you are testing it on your own machine), then click LAN Client to attempt to connect to the host. When the client is attempting to connect, the HUD displays a Cancel Connection Attempt button. Click this if you want to stop trying to connect to the host. If the connection is successful, the HUD displays the Stop button. Click this if you want to stop the game on the client and disconnect from the host: LAN Server Only Click LAN Server Only to start a game which acts as a server that other clients can connect to, but which does not act as a client to the game itself. This type of game is often called a “dedicated server”. A user cannot play the game on this particular instance of your game. All players must connect as clients, and nobody plays on the instance that is running as the server. A dedicated server results in better performance for all connected players, because the server doesn’t need to process a local player’s game play in addition to acting as server. You might also choose this option if you want to host a game that can be played over the internet (rather than just within a local network), but want to maintain control of the server yourself - for example, to prevent cheating by one of the clients, because only the server has authority over the game. To do this, you would need to run the game in Server Only mode on a computer with a public IP address."
  },
  "Components/NetworkManager.html": {
    "href": "Components/NetworkManager.html",
    "title": "NetworkManager",
    "keywords": "NetworkManager The Network Manager is a component for managing the networking aspects of a multiplayer game. The Network Manager features include: Game state management Spawn management Scene management Debugging information Customization Getting Started with the Network Manager The Network Manager is the core controlling component of a multiplayer game. To get started, create an empty game object in your starting Scene, and add the Network Manager component. The newly added Network Manager component looks like this: The Inspector for the Network Manager in the Editor allows you to configure and control many things related to networking. Note : You can only ever have one active Network Manager in each scene because it's a singleton. Do not place the Network Manager component on a networked game object (one which has a Network Identity component), because Mirror disables these when the Scene loads. If you are already familiar with multiplayer game development, you might find it useful to know that the Network Manager component is implemented entirely using the API, so everything it does is also available to you through scripting. For advanced users, if you find that you need to expand on the Network Manager component’s features, you can use scripting to derive your own class from Network Manager and customize its behavior by overriding any of the virtual function hooks that it provides. However, the Network Manager component wraps up a lot of useful functionality into a single place, and makes creating, running and debugging multiplayer games as simple as possible. Transports Mirror's uses a separate component (derived from the Transport class) to connect across the network. By default, it is Telepathy Transport. This design choice of separating the transport into its own component allows game developers to choose the transport that best fits their game needs. Changing transports is as simple as swapping out the component on the Network Manager object and assigning it to the Transport field. Transports are available for TCP, UDP, WebGL, and Steam. Additionally, there's a Multiplex transport that allows for using two transports together on the server, e.g. Telepathy and WebSockets, so that desktop and browser players can play together on the same server seamlessly. See Transports for more information. Game State Management A Networking multiplayer game can run in three modes - as a client, as a dedicated server, or as a host which is both a client and a server at the same time. If you’re using the Network Manager HUD, it automatically tells the Network Manager which mode to start in, based on which button the player clicks. If you’re writing your own UI that allows the player to start the game, you’ll need to call these from your own code. These methods are: NetworkManager.StartClient NetworkManager.StartServer NetworkManager.StartHost Whichever mode the game starts in (client, server, or host), the Network Address and Transport Port properties are used. In client mode, the game attempts to connect to the address and port specified. A fully-qualified domain name (FQDN) can also be used for the Network Address, e.g. \"game.example.com\". In server or host mode, the game listens for incoming connections on the port specified, but does not bind to any specific IP address (it listens on all available). Spawn Management Use the Network Manager to manage the spawning (networked instantiation) of networked game objects from Prefabs. Most games have a Prefab which represents the player, so the Network Manager has a Player Prefab slot. You should assign this slot with your player Prefab. When you have a player Prefab set, a player game object is automatically spawned from that Prefab for each user in the game. This applies to the local player on a hosted server, and remote players on remote clients. You must attach a Network Identity component to the Player Prefab before assigning it to this field. Once you have assigned a Player Prefab, you can start the game as a host and see the player game object spawn. Stopping the game destroys the player game object . If you build and run another copy of the game and connect it as a client to localhost , the Network Manager makes another player game object appear. When you stop that client, it destroys that player’s game object . In addition to the Player Prefab, you must also register other prefabs that you want to dynamically spawn during game play with the Network Manager. You can add prefabs to the list shown in the inspector labelled Registered Spawnable Prefabs. You can also register prefabs via code, with the ClientScene.RegisterPrefab method. If you have one Network Manager that is persisted through scenes via Don't Destroy On Load (DDOL), you need to register all prefabs to it which might be spawned in any scene. If you have a separate Network Manager in each scene, you only need to register the prefabs relevant for that scene. Start Positions The Network Manager will spawn Player Prefab at their defined transform position and rotation by default, however the Player Spawn Method property allows you to control how start positions are chosen in conjunction with Network Start Position components. Choose Random to spawn players at randomly chosen startPosition options. Choose Round Robin to cycle through startPosition options in a set list. If the Random or Round Robin modes don’t suit your game, you can customize how the start positions are selected by using code. You can access the available Network Start Position components by the list NetworkManager.startPositions , and you can use the helper method GetStartPosition on the Network Manager that can be used in an implementation of OnServerAddPlayer to find a start position. Scene Management Most games have more than one scene. At the very least, there is usually a title screen or starting menu scene in addition to the scene where the game is actually played. The Network Manager is designed to automatically manage scene state and scene transitions in a way that works for a multiplayer game. There are two slots on the Network Manager inspector for scenes: the Offline Scene and the Online Scene. Dragging scene assets into these slots activates networked Scene Management. When a server or host is started, the Online Scene is loaded. This then becomes the current network scene. Any clients that connect to that server are instructed to also load that scene. The name of this scene is stored in the networkSceneName property. When the network is stopped, by stopping the server or host or by a client disconnecting, the offline Scene is loaded. This allows the game to automatically return to a menu scene when disconnected from a multiplayer game. You can also change scenes while the game is active by calling ServerChangeScene . This makes all the currently connected clients change Scene too, and updates networkSceneName so that new clients also load the new Scene. While networked Scene management is active, any calls to game state management functions such as StartHost or StopClient can cause scene changes. This applies to the runtime control UI. By setting up scenes and calling these methods, you can control the flow of your multiplayer game. Note that scene change causes all the game objects in the previous scene to be destroyed. You should normally make sure the Network Manager persists between Scenes, otherwise the network connection is broken upon a scene change. To do this, ensure the Don’t Destroy On Load checkbox is ticked in the inspector. However it is also possible to have a separate Network Manager in each scene with different settings, which may be helpful if you wish to control incremental prefab loading, or different scene transitions. Customization There are virtual functions on the NetworkManager class that you can customize by creating your own derived class that inherits from NetworkManager . When implementing these functions, be sure to take care of the functionality that the default implementations provide. For example, in OnServerAddPlayer , the function NetworkServer.AddPlayer must be called to activate the player game object for the connection. Properties dontDestroyOnLoad Use this property to control whether or not Mirror should destroy the game object with the Network Manager when the Scene changes. Tick this checkbox to ensure Mirror does not destroy your Network Manager game object when the Scene changes in your game. Untick the checkbox if you want Mirror to destroy the game object when the Scene it exists in is no longer the active Scene. This is useful if you want to manage multiple, separate Network Manager game objects in each of your Scenes. This checkbox is ticked by default. runInBackground Use this property to control whether the networked game runs when the window it is running in is not focused. Tick the checkbox if you want it to run; untick it if you want the game to stop running when the window is not focused. This checkbox is ticked by default. You need to enable this property if you want to run multiple instances of a program on the same machine, such as when testing using localhost. You should disable it when deploying to mobile platforms. When enabled, it sets Application.runInBackground to true when the Network Manager starts up. You can also set this property from the Unity menu: Edit > Project Settings, then select the Player category, and navigate to the Resolution and Presentation panel. startOnHeadless If this box is checked (property is true) and computer that runs the program has no graphic device, program will start in server mode. serverTickRate Sets the target frame rate for the server. Default is 30. showDebugMessages Use this property to control the amount of information Mirror outputs to the console window. offlineScene If you assign a Scene to this field, the Network Manager automatically switches to the specified Scene when a network session stops - for example, when the client disconnects, or when the server shuts down. onlineScene If you assign a Scene to this field, the Network Manager automatically switches to the specified Scene when a network session starts - for example, when the client connects to a server, or when the server starts listening for connections. Network Info transport A link to a Component derived from Transport class. TelepathyTransport is created and linked there by default. networkAddress The network address currently in use. For clients, this is the address of the server that is connected to. For servers, this is the local address. This is set to ‘localhost’ by default. A Fully Qualified Domain Name (FQDN) can be used by clients in this field. maxConnections Maximum number of clients connected to a server. Note that host is a server and one client. Transports may also have their own setting for this, otherwise they either copy this value or leave it to Mirror to manage the limit. SpawnInfo You can expand this section of the inspector to access spawn-related settings, listed below playerPrefab Define the default prefab Mirror should use to create player game objects on the server. Mirror creates Player game objects in the default handler for AddPlayer on the server. Implement OnServerAddPlayer to override this behavior. autoCreatePlayer Tick this checkbox if you want Mirror to automatically create player game objects on connect, and when the Scene changes. This checkbox is ticked by default. Note that if you are using the MigrationManager and you do not enable Auto Create Player, you need to call ClientScene.SendReconnectMessage when your client reconnects. playerSpawnMethod Define how Mirror should decide where to spawn new player game objects. This is set to Random by default. random Choose Random to spawn players at randomly chosen startPositions . roundRobin Choose Round Robin to cycle through startPositions in a set list. spawnPrefabs List of prefabs registered in the Network Manager startPositions List of Transforms built from all game objects in the scene with a Network Start Position component. clientLoadedScene Bool that indicates that the client has loaded the current scene numPlayers Returns the number of active connections from NetworkServer . Only valid on the server. networkSceneName Name of currently loaded and active scene. isNetworkActive Bool indicating that the server is online or the client is connected. client Returns the NetworkClient.singleton . isHeadless Bool that indicates of the application was started in headless mode. Methods Unity Virtual Callbacks public virtual void Awake() {} public virtual void Start() {} Server Methods public bool StartServer() {} public void StartClient() {} public void StopHost() {} public void StopServer() {} public void StopClient() {} public Transform GetStartPosition() {} Server Static Methods public static void RegisterStartPosition(Transform start) {} public static void UnRegisterStartPosition(Transform start) {} public static void Shutdown() {} Server Virtual Methods public virtual void ConfigureServerFrameRate() {} public virtual void StartHost() {} public virtual void ServerChangeScene(string newSceneName, LoadSceneMode sceneMode, LocalPhysicsMode physicsMode) {} public virtual void OnServerConnect(NetworkConnection conn) {} public virtual void OnServerDisconnect(NetworkConnection conn) {} public virtual void OnServerReady(NetworkConnection conn) {} public virtual void OnServerAddPlayer(NetworkConnection conn, AddPlayerMessage extraMessage) {} public virtual void OnServerRemovePlayer(NetworkConnection conn, NetworkIdentity player) {} public virtual void OnServerError(NetworkConnection conn, int errorCode) {} public virtual void OnServerSceneChanged(string sceneName) {} public virtual void OnStartHost() {} public virtual void OnStartServer() {} public virtual void OnStopServer() {} public virtual void OnStopHost() {} public virtual void OnDestroy() {} Client Virtual Methods public virtual void OnStartClient() {} public virtual void OnStopClient() {} public virtual void OnClientConnect(NetworkConnection conn) {} public virtual void OnClientDisconnect(NetworkConnection conn) {} public virtual void OnClientError(NetworkConnection conn, int errorCode) {} public virtual void OnClientNotReady(NetworkConnection conn) {} public virtual void OnClientChangeScene(string newSceneName, LoadSceneMode sceneMode) {} public virtual void OnClientSceneChanged(NetworkConnection conn) {}"
  },
  "Transports/Fizzy.html": {
    "href": "Transports/Fizzy.html",
    "title": "FizzySteam",
    "keywords": "FizzySteam Fizzy Steam is a Steam P2P transport for Mirror, it utilizes Steam's P2P service to directly connect or relay your connection to another player. Fizzy Steam is based of Steamworks.Net wrapper. You can get the release Here with the latest version of Steamworks.Net included or you can clone the repo Here . Features Multiple Customizable Channels : You can customize the channels in the transport, whether you want just 1 or 5 channels that are unreliable or reliable (best to leave channel 0 as reliable). Steam Nat Punching & Relay : The transport will use Steam to do Nat Punching to your destination, and if that doesn't work, steam's relay Server will be used to ensure you can always connect (latency may vary). No Code Changes Needed : If you Already use Mirror, you just need to slap this transport in (maybe add your steam App ID in your build), and everything should work the same like any other Mirror Transport. \"It Just Works\" -Todd Howard Credits Fizz Cube : Original author for this Transport. Raystorms : The current maintainer for this Transport. rlabrecque : Creator of Steamworks.Net. vis2k : Creator of Mirror. Valve : Steam"
  },
  "Transports/Ignorance.html": {
    "href": "Transports/Ignorance.html",
    "title": "Ignorance",
    "keywords": "Ignorance What is Ignorance? Ignorance is a reliable UDP transport layer that utilizes the native ENET C Networking library via a custom fork of ENet-CSharp providing an reliable and unreliable sequenced UDP transport for both 64Bit desktop operating systems (Windows, Mac OS and Linux) and Mobile OSes (Apple iOS and Android). It also supports up to 255 channels and 4096 clients connected at one time. ENET is a solid reliable UDP C++ network library that is mature and stable. Unity's LLAPI needs a replacement. Ignorance was designed with that goal in mind - fill the gap and provide a solid, performant RUDP transport for Mirror. Why Ignorance over the Unity LLAPI? Unity's old LLAPI was horridly inefficient, and lots of testing has shown that you will get reduced performance using Unity LLAPI in your project. This is due to the design of the old networking code - Unity Tech made \"by design\" decisions and poor bug fixes that were seen to other developers as band-aids over a gaping wound. They did not care about performance or bug fixes. Unity LLAPI was also closed source, meaning the Mirror developers could not take a knife to it and make it better. This is where the concept of Ignorance took shape. Who develops Ignorance? Coburn is the lead developer of the transport. Oiran Studio actively uses this transport for networked game projects. It is currently also being utilized by some game projects, where you can find on the Mirror Discord server. Why would I want to use reliable UDP over TCP? if you have realtime communications that you need speed over reliability (VoIP...) if you need channels if you need custom channel send types if you need a data hose for your game (a first person shooter, racing game, etc) Why wouldn't I want to use reliable UDP over TCP? if you have mission critical things (as in, data NEEDS to go from A and B, no exceptions) if you need fully reliable network protocol if you're paranoid if you're making a Minecraft-like game and need to keep everyone in sync I want to know more about reliable UDP... A little explanation is required. UDP is best described as a \"shattershot\" data transmission protocol, which means you just spray and pray that packets at a destination and hope for the best. The remote destination may or may not receive those packets, nor are they going to be in order. For example, if you have a packet stream that is: 1 2 3 4 5 6 7 ...then it may end up like any of the following on the other end due to packets arriving out of order. A dot in the following example means that packet went missing. 7 6 1 3 2 4 5 7 6 . . 4 . 1 . . . . 1 2 3 1 2 3 5 4 6 7 For example, say you lost a packet and that contained a player's health update. Everyone else might know they took 69 damage, but that client will still have the old value of say, 72 health. Without reliable UDP, you can become out of sync very quickly. When you're out of sync, the game is over - everything will start operating very strangely. Sequencing and Reliable Delivery Sequencing Sequencing basically tags packets so they know what number they are when being dispatched. So if you send packets 100, 101, 102 to the remote destination, the other end will reconstruct the packet in that order rather than in a different order (like 101, 100, 102 ). If a packet is missing, it'll be skipped but the network library will take note that it's missing and compensate. Reliable mode just tells ENET to send this while waiting for the remote to acknowledge packet reception, before claiming it was 'lost'. ENET will still classify said packets as lost if it doesn't hear back from the remote, but it will retransmit them to compensate for lossy connections or high latency situations. Reliable mode tries to emulate some of TCP's resending if not acknowledged in time, but as UDP does not have all the overhead TCP protocol has, it adds some packet overhead. Ignorance comes with two channels in both Reliable and Unreliable mode by default. There are other channel modes that developers can test as different ones might suit different loads, but the average person does not need to worry about this. Ignorance comes with sane defaults out of the box. Does Ignorance support Websockets? No, it does not. Mirror comes with built-in websockets support. Where can I get Ignorance? Grab the latest build from the releases page on the Ignorance repository . Simply import the Unity Package from the release you downloaded. Where can I get support? You can get support by opening a issue ticket on the Ignorance repository issue tracker or the #ignorance channel in the Mirror Discord server. I still don't understand what this transport is, my head is spinning, help! Come by the Discord and we'll do our best to explain it in plain English."
  },
  "Transports/WebSockets.html": {
    "href": "Transports/WebSockets.html",
    "title": "WebSockets",
    "keywords": "WebSockets General description of WebSockets"
  },
  "Transports/Multiplexer.html": {
    "href": "Transports/Multiplexer.html",
    "title": "MultiplexTransport",
    "keywords": "MultiplexTransport The MultiplexTransport is not a transport itself, but it allows you to combine other transports so that your clients can connect to your servers via either one of them. A common use case for the MultiplexTransport is a server listening to both websockets and TCP. Your webgl clients can connect to the server using websockets and your mobile or desktop clients can connect to the same server via TCP. In HLAPI, you had to chose between websockets and UDP, but you cannot use both at the same time. You can configure any number of transports in the MultiplexTransport. To use the MultiplexTransport follow these steps: Add a gameobject with a NetworkManager to your scene if you have not done so By default, Unity will add TelepathyTransport to your NetworkManager game object Add a MultiplexTransport component to the gameobject Assign the MultiplexTransport component in your NetworkManager's transport Add a WebsocketTransport component to the gameobject Add the TelepathyTransport component to the MultiplexTransport as the first transport Add the WebsocketTransport component to the MultiplexTransport as the second transport Please note that Telepathy and WebsocketTransport cannot listen to the same port. By default Telepathy listens to 7777 and the websocket transport listens to 7778. If you build your game as a webgl game, the TelepathyTransport will be skipped and your client will use the websocket transport. If you build your game as a mobile or desktop app, it will choose TelepathyTransport. The server will happily accept connections from both. Here is what the configuration should look like:"
  },
  "Transports/index.html": {
    "href": "Transports/index.html",
    "title": "Transports Overview",
    "keywords": "Transports Overview Mirror is a high level Networking Library that can use several different low level transports. To use a transport, simply add it as component to the NetworkManager and drag it into the NetworkManager's Transport field. TCP - Telepathy Simple, message based, MMO Scale TCP networking in C#. And no magic. UDP - Ignorance Ignorance implements a reliable and unreliable sequenced UDP transport based on ENet. UDP - LiteNetLib4Mirror LiteNetLib4Mirror implements a UDP transport based on LiteNetLib with Network Discovery and uPnP included. WebGL - WebSockets WebSockets transport layer for Mirror that target WebGL clients, without relying on Unity's stodgy old LLAPI. Steam - Fizzy A complete rebuild utilising Async (Previously SteamNetNetworkTransport) of a Steam P2P network transport layer. Multiplexer - Multiplexer Multiplexer is a bridging transport to allow a server to handle clients on different transports concurrently, for example desktop clients using Telepathy together with WebGL clients using Websockets. Fallback Fallback is a compatibility transport for transports that don't run on all platforms and need fallback options to cover all other platforms."
  },
  "Transports/Fallback.html": {
    "href": "Transports/Fallback.html",
    "title": "FallbackTransport",
    "keywords": "FallbackTransport The FallbackTransport can be used to work around transport platform limits. For example, our Apathy transport is currently only available on Windows, Mac and Linux where as Telepathy is available on all Platforms. Apathy has significant performance improvements, and ideally we would want Mirror to use Apathy if on Windows/Mac/Linux and fall back to Telepathy otherwise. This is what the FallbackTransport allows us to do. Usage: Add a gameobject with a NetworkManager to your scene if you have not done so By default, Unity will add TelepathyTransport to your NetworkManager game object Add a FallbackTransport component to the gameobject Assign the FallbackTransport component in your NetworkManager's transport Add a ApathyTransport component to the gameobject Add both ApathyTransport and TelepathyTransport to the FallbackTransport's transport property. Important: all fallback transport need to be binary compatible with each other. For example, it might happen that the server runs Apathy and a client connects to it with Telepathy."
  },
  "Transports/LiteNetLib4Mirror.html": {
    "href": "Transports/LiteNetLib4Mirror.html",
    "title": "LiteNetLib4Mirror",
    "keywords": "LiteNetLib4Mirror General description of LiteNetLib4Mirror"
  },
  "Transports/Telepathy.html": {
    "href": "Transports/Telepathy.html",
    "title": "Telepathy",
    "keywords": "Telepathy Simple, message based, MMO Scale TCP networking in C#. And no magic. Telepathy was designed with the KISS Principle in mind. Telepathy is fast and extremely reliable, designed for MMO scale Networking. Telepathy uses framing, so anything sent will be received the same way. Telepathy is raw C# and can be used in Unity3D too. Telepathy is available on GitHub What makes Telepathy special? Telepathy was originally designed for uMMORPG after 3 years in UDP hell. We needed a library that is: Stable & Bug free: Telepathy uses only 400 lines of code. There is no magic. High performance: Telepathy can handle thousands of connections and packages. Concurrent: Telepathy uses one thread per connection. It can make heavy use of multi core processors. Simple: Telepathy takes care of everything. All you need to do is call Connect/GetNextMessage/Disconnect. Message based: if we send 10 and then 2 bytes, then the other end receives 10 and then 2 bytes, never 12 at once. MMORPGs are insanely difficult to make and we created Telepathy so that we would never have to worry about low level Networking again. What about... Async Sockets: didn't perform better in our benchmarks. ConcurrentQueue: .NET 3.5 compatibility is important for Unity. Wasn't faster than our SafeQueue anyway. UDP vs. TCP: Minecraft and World of Warcraft are two of the biggest multiplayer games of all time and they both use TCP networking. There is a reason for that."
  },
  "General/Integrations/index.html": {
    "href": "General/Integrations/index.html",
    "title": "Integrations",
    "keywords": "Integrations Here we will maintain a list of assets known to be compatible with Mirror. If you know of others, please have the publisher contact us directly in our Discord . Network Sync Transform SmoothSync Weather Maker Noble Connect Free Dissonance Voice Chat RTS Engine Rucksack Steamworks Networking Master Audio Multiplayer"
  },
  "General/PlayerControllerToIdentity.html": {
    "href": "General/PlayerControllerToIdentity.html",
    "title": "Changing playerController to identity",
    "keywords": "Changing playerController to identity If you need to fix up a project after NetworkConnection.playerController was changed to identity these instructions should be helpful. Open your Unity project and look for Assets/Mirror/Runtime/ NetworkConnection : Open this file in Visual Studio or Visual Code from Unity and look for these lines: The line numbers could be off a bit if minor file changes happen above them after this document was written. Comment the last line shown: // public NetworkIdentity identity { get; internal set; } Double-click and then right-click playerController and select Rename: Change playerController to identity and click Apply: Visual Studio will now have applied the change throughout your project, but you're not done yet! Without using the replace feature this time, simply retype the name back to playerController and un-comment the last line in the code image that you commented out in step 3. Your code should now look like the code image again. Save your work!"
  },
  "General/WhyTCP.html": {
    "href": "General/WhyTCP.html",
    "title": "Why TCP by default and not UDP?",
    "keywords": "Why TCP by default and not UDP? It's the year 2019 and every game developer swears by UDP. Yet we chose TCP as default for Mirror. Why is that? First of all, a quick word about the major differences between UDP and TCP. UDP has lower latency, unreliable and hard to use correctly TCP has higher latency, reliable and easy to use TCP (Transmision Control Protocol) Tcp is a protocol built on top of IP. It is by far the most popular protocol on the internet. Everything you are seeing in this page was sent to your browser via TCP. It is designed to be simple to use and scalable. Servers open a TCP port and wait for connections. Clients send an initial message (handshake) to establish the connection then send data. Data flows one byte after another, always in the right order, without missing anything. Some of the key features include: Reliable: if a packet gets lost, TCP will resend it. All data is either transmitted successfully or you get an error and the connection is closed. Applications don't have to worry about missing packets. Fragmented: network cards cannot just send 1 MB of data. They can only send small packets of 1.5Kb or less. If a lot of data is sent by the application, TCP will split it into small packets and reassemble the data on the receiving end. Sequenced: If you send data \"a\" and \"b\" you will not receive \"b\" and \"a\". TCP guarantees that every byte will arrive in the same order it was sent. Connection oriented: TCP has the concept of a connection. A client sends an initial handshake message. A connection is considered established until either the client and server decides to disconnect. Both the client and server get notified when the connection ends and can react accordingly, for example saving and destroying player object. Congestion control: If a server is being overwhelmed, TCP will throttle the data to avoid congestion collapse. These are great features that make it very easy for programmers to work with TCP, but they come at a cost: Latency. Suppose an object is moving from point a to b to c. The server sends 3 messages: move to a, b, c. Suppose b gets lost (wifi drops a lot of packets for example) and c arrives fine. We could skip b and move towards c instead, but we can't because the operating system won't give us c until b is retransmitted. For this reason, AAA studios consistently prefer UDP for fast paced action games. UDP (User Datagram Protocol) UDP is also a protocol based on IP. It is used for real time applications such as fast paced action games or voice over ip, where low latency is more important than reliability. A server opens a port and waits for messages. Clients send messages to the port, and the server may send messages back. Data flows in both ways as individual messages. There is no concept of connection, so there is no built in way to determine if a client disconnects. Messages are delivered as soon as possible, there is no guarantee that the order will be preserved or that they will be delivered at all. Messages must be small, typically 1.5Kb or less. Mirror does need reliability, fragmentation, sequenced, connections for many things, so we would not use raw UDP. We would use a library that implements those features on top of UDP such as ENet , LiteNetLib or LLAPI, typically referred to as RUDP (Reliable UDP) The obvious question is: do RUDP libraries just reinventing TCP? yes, to some degree they do. But the point is that those features are optional and we can send messages without the extra features for low latency data such as movement or voice. Dark ages Back in 2015 when we started uMMORPG and Cubica, we originally used Unity's built in Networking system aka UNET. UNET used LLAPI, an RUDP library that avoided garbage collection at all costs. What sounds good in theory, was terrible in practice. We spent about half our work hours from 2015 to 2018 dealing with UNET bugs. There was packet loss, highly complex code due to GC avoidance, synchronization issues, memory leaks and random errors. Most importantly, no decent way to debug any of it. If a monster didn't spawn on a client, we wouldn't know what caused it. Was the packet dropped by UDP? Was it a bug in the highly complex UNET source code? Was the reliable layer on top of UDP not working as intended? Was the reliable layer actually fully reliable? Did we use the right networking config for the host that we tested it on? Or was it a bug in our own project? After 3 years in UDP/LLAPI hell, we realized if we ever wanted to finish our games, we would need a networking layer that just works. We could have tried other RUDP transports, but we would end up debugging them instead. That's why we made Telepathy and Mirror. Life is short. We just need the damn thing to work. The choice is yours We acknowledge not everyone will agree with our reasoning. Rather than push our views on users, we made Mirror transport independent. A few months later, Unity did the same thing. You can easily swap out the transport for one of the several RUDP implementations simply by dragging it into your NetworkManager gameobject. Pick whatever works best for you. We recommend you profile your game and collect real world numbers before you make a final decision. After we made Mirror transport independent, the community stepped up integrated several RUDP transports with Mirror. While the default is Telepathy (simple \"just works\" TCP transport) you can choose among several transports or even write your own."
  },
  "General/Deprecations.html": {
    "href": "General/Deprecations.html",
    "title": "Deprecations",
    "keywords": "Deprecations Certain features of Unity Networking were removed from Mirror for various reasons. This page will identify all removed features, the reason for removal, and possible alternatives. Match Namespace As part of the Unity Services, this entire namespace was removed. It didn't work well to begin with, and was incredibly complex to be part of the core networking package. We expect this, along with other back-end services, will be provided through standalone apps that have integration to Mirror. Network Discovery NetworkDiscovery was a UNet component intended for UDP projects. Since Mirror was built on TCP, it was removed. Now that all transports are separate components, Discovery has been re-implemented in at least one of them. networkPort in Network Manager Network Manager's networkPort property was removed now that all transports are separate components. Not all transports use ports, but those that do have a field for it. See Transports for more info. playerController in NetworkConnection This was renamed to identity since that's what it is: the NetworkIdentity for the connection. If you need to convert a project after this change, Visual Studio / VS Code can help...read more here . Local Player Authority in NetworkIdentity This has been phased out through overhauling, and simplifying how Authority works in Mirror. Network Server Simple This was too complex and impractical to maintain for what little it did, and was removed. There are much easier ways to make a basic listen server, with or without one of our transports. Couch Co-Op The core networking was greatly simplified by removing this low-hanging fruit. It was buggy, and too convoluted to be worth fixing. For those that need something like this, consider defining a non-visible player prefab as a message conduit that spawns actual player prefabs with client authority. All inputs would route through the conduit prefab to control the player objects. Network Transform This component was significantly simplified so that it only syncs position and rotation. Rigidbody support was removed. We will create a new separate component for NetworkRigidbody that will be server authoritative with physics simulation and interpolation. Quality of Service Flags In classic UNET, QoS Flags were used to determine how packets got to the remote end. For example, if you needed a packet to be prioritized in the queue, you would specify a high priority flag which the Unity LLAPI would then receive and deal appropriately. Unfortunately, this caused a lot of extra work for the transport layer and some of the QoS flags did not work as intended due to buggy or code that relied on too much magic. In Mirror, QoS flags were replaced with a \"Channels\" system. This system paves the way for future Mirror improvements, so you can send data on different channels - for example, you could have all game activity on channel 0, while in-game text chat is sent on channel 1 and voice chat is sent on channel 2. In the future, it may be possible to assign a transport system per channel, allowing one to have a TCP transport for critical game network data on channel 0, while in-game text and voice chat is running on a UDP transport in parallel on channel 1. Some transports (such as Ignorance.md) also provide legacy compatibility for those attached to QoS flags. The currently defined channels are: Channels.DefaultReliable = 0 Channels.DefaultUnreliable = 1 Currently, Mirror using it's default TCP transport will always send everything over a reliable channel. There is no way to bypass this behaviour without using a third-party transport, since TCP is always reliable. Other transports may support other channel sending methods."
  },
  "General/Start.html": {
    "href": "General/Start.html",
    "title": "Getting Started",
    "keywords": "Getting Started This document describes steps to converting a single player game to a multiplayer game, using the new Unity Multiplayer networking system. The process described here is a simplified, higher level version of the actual process for a real game; it doesn’t always work exactly like this, but it provides a basic recipe for the process. Video tutorials Check out these awesome videos showing you how to get started with mirror. Courtesy of First Gear Games also known as Punfish in discord. Script Templates Create new Network Behaviours and other common scripts faster See Script Templates . NetworkManager set-up Add a new game object to the Scene and rename it “NetworkManager”. Add the NetworkManager component to the “NetworkManager” game object. Add the NetworkManagerHUD component to the game object. This provides the default UI for managing the network game state. See Using the NetworkManager . Player Prefab Find the Prefab for the player game object in the game, or create a Prefab from the player game object Add the NetworkIdentity component to the player Prefab Check the LocalPlayerAuthority box on the NetworkIdentity Set the playerPrefab in the NetworkManager’s Spawn Info section to the player Prefab Remove the player game object instance from the Scene if it exists in the Scene See Player Objects for more information. Player movement Add a NetworkTransform component to the player Prefab Update input and control scripts to respect isLocalPlayer Fix Camera to use spawned player and isLocalPlayer For example, this script only processes input for the local player: using UnityEngine; using Mirror; public class Controls : NetworkBehaviour { void Update() { if (!isLocalPlayer) { // exit from update if this is not the local player return; } // handle player input for movement } } Basic player game state Make scripts that contain important data into NetworkBehaviours instead of MonoBehaviours Make important member variables into SyncVars See State Synchronization . Networked actions Make scripts that perform important actions into NetworkBehaviours instead of MonoBehaviours Update functions that perform important player actions to be commands See Networked Actions . Non-player game objects Fix non-player prefabs such as enemies: Add the NetworkIdentify component Add the NetworkTransform component Register spawnable Prefabs with the NetworkManager Update scripts with game state and actions Spawners Potentially change spawner scripts to be NetworkBehaviours Modify spawners to only run on the server (use isServer property or the OnStartServer() function) Call NetworkServer.Spawn() for created game objects Spawn positions for players Add a new game object and place it at player’s start location Add the NetworkStartPosition component to the new game object"
  },
  "General/ChangeLog.html": {
    "href": "General/ChangeLog.html",
    "title": "Change Log",
    "keywords": "Change Log Version 7.x.x - In Progress Added: NetworkAnimator now has a ResetTrigger function and server / client authority warnings Fixed: NetworkTransform and NetworkAnimator now uses NetworkWriterPool Fixed: NetworkTransform and NetworkAnimator now respect hasAuthority for client owned objects Fixed: NetworkTransform will now correctly teleport if time / distance are too large Fixed: NetworkAnimator now correctly syncs when clientAuthority is false Fixed: Client owned objects are now destroyed when client disconnects (regression) Fixed: Client authority is now preserved for networked objects carried through scene change in DDOL Fixed: Starting server immediately after cancelling client connection attempt no longer throws a NRE Fixed: IL2CPP builds no longer trigger an assert when stopping server Fixed: SyncVars are now set for Host player before hook is invoked Changed: Shutdown logic has been streamlined Changed: OnApplicationQuit virtual method added to Transport class and Transport.activeTransport.Shutdown() is no longer called from Network Manager Changed: Breaking SyncVar Hooks now require two parameters, one each for the old and new value, and the property value is now set before the hook is called. Version 6.7.7 - 2020-Jan-01 Added: Script Templates -- See the new Mirror section in the Assets > Create menu. Added: Full Text Search added to docs Added: Basic Chat example Added: Some youtube videos have been created and linked from various doc pages where appropriate Added: Transports can now support using a URI for connection including port Added: version.txt file is now included with the release version in it. Added: Structs that inherit from IMessageBase now generate serializers Fixed: Components now appear in docs under API Reference Fixed: Delayed disconnect in Basic Authenticator Fixed: Multiplexer now handles OnClientConnect and GetMaxMessageSize correctly Fixed: NetworkRoomManager OnRoomServerCreateGamePlayer now includes the Room Player Object as parameter Changed: Room example now has NetworkRoomManager in the Offline scene and correctly switches to the Room scene when server / client is started Changed: NetworkManager startPositionIndex and loadingSceneAsync are now public Changed: SceneMessage now has an optional customHandling flag so devs can handle their own custom scene loading, e.g. using Addressables. Changed: Breaking NetworkTransform now defaults to server authority and has a Client Authority checkbox. Version 6.3.0 - 2019-Dec-09 Added: SyncMode selector now works for components on any scene objects owned by a client in addition to the player object, e.g. pets Added: MessageBase now fully supports inheritance Added: Room example now has UI button for host to return all clients to the Room scene and other improvements Fixed: ReplacePlayerForConnection now works for existing scene objects as long as another player doesn't own the targetted object Fixed: isClient and isServer are now true for networked objects in Start and OnStartClient / OnStartServer, respectively Fixed: hasAuthority is now set before OnStartClient and OnStartLocalPlayer are invoked Changed: connectionToClient is now used to assign client authority Changed: In many respects, the Host player acts a lot more like a client and will reveal bugs better. Changed: ReplacePlayerForConnection now has an optional bool to retain authority of the previous object (default = false) Removed: NetworkServer.SpawnWithClientAuthority is deprecated in favor of overloads of NetworkServer.Spawn Version 5.0.2 - 2019-Nov-03 Added: SyncList and SyncSet custom Equality Comparer support Added: Custom serializers may be implemented for any type in Cmd's and Rpc's Added: Fallback Transport Fixed: SyncVar hooks are no longer called in Host if no change Fixed: NetworkIdentity no longer throws a null reference exception in RemoveClientAuthority Fixed: Server transport now suspended during scene change to prevent erroneous messages Fixed: SyncList, SyncDictionary and SyncSet now use a custom IEnumerator to avoid memory allocation Fixed: sceneID is no longer reset in certain cases when editing a prefab Changed: PreprocessorDefine code moved to CompilerSymbols folder to avoid paradox of missing symbols preventing the symbols being added to the project. Changed: Host player no longer gets authority assigned to all objects by default Changed: Commands no longer bypass serialization for Host player, making debugging easier Changed: Local connections now maintain their own message queue Changed: Transport.Available is now abstract Removed: Network Identity: Local Player Authority has been removed as no longer necessary Version 4.0.7 - 2019-Oct-03 Added: Authentication support to authenticate clients in the Connect phase Added: Profiler events. These events can be subscribed to by the Network Profiler to provide visual information Added: Transports now include channel in profiler events Added: Transport abstract class now supports sending a message to a list of connection id's Fixed: SceneMessage now has sceneOperation enum so clients can properly handle additive scenes Fixed: NetworkClient handlers are now cleared in Shutdown Fixed: Offline scene is no longer reloaded when client fails to connect or is rejected Fixed: Start Position Index is now reset to zero when server is stopped Fixed: Network Room Players are now all in DontDestroyOnLoad so they don't respawn in the game scene Fixed: Network Room example player controller restores main camera on disable Fixed: Components with different sync intervals were not sending updates to clients Fixed: In certain cases, weaver wouldn't weave some external assemblies Fixed: NetworkAnimator now does a full sync for new clients Fixed: NetworkBehaviour inspector now shows SyncMode for private SyncVars Fixed: Calling Commands and Rpcs of parent classes from inherited classes works as it should Fixed: Telepathy no longer hangs when attempting to connect to a nonexistent host Fixed: Websockets Transport now properly returns the client endpoint information via ServerGetClientAddress Fixed: WebGL build now works with ArraySegment Changed: Mirror is now free of garbage memory allocation on the sending side. Some transports may still have a little garbage allocation yet. Changed: Deprecated the AddPlayerMessage extraMessage byte[] in favor of an easier approach to Custom Players This is a breaking change: The virtual method OnServerAddPlayer loses the AddPlayerMessage parameter. Changed: NetworkIdentity.RemoveAuthorityForConnection is now easier to use: no need to supply the current \"owner\" anymore. Changed: Renamed NetworkConnection.playerController to identity ... see Deprecations for details. Changed: Lobby system renamed to Room to better align the name for what it is and make way for a future Lobby framework Version 3.17.4 - 2019-Sep-04 Added: Custom Network Readers & Writers via extension methods Added: Network Sync Mode selector on components to sync to observers (default) or just the owner Added: SyncVars now support structs and enums in other assemblies Added: Support for reading and writing array segments Added: NetworkAnimator now has layers support Added: New virtual method OnServerChangeScene to NetworkManager Added: XML summary comments for intellisense and future generated class docs Updated Examples and Documentation Fixed: SceneID was not set to 0 for prefab variants Fixed: Observers were not properly rebuilt on scene changes Fixed: SyncVar hooks were not able to change other SyncVars in Host mode Fixed: Telepathy not setting socket options on accepted clients Fixed: Catch IL2CPP bug Fixed: Telepathy and Websockets now start connections ID's at 1 instead of 2 Fixed: Websockets support for SSL restored Fixed: NetworkManager no longer complains about missing player prefab if auto-create is disabled Fixed: Removed a garbage allocation in Network Transform Fixed: NetworkClient.Ready was being called unncessarily in certain cases, e.g. SceneMessages Changed: Documentation moved to website and API generated docs implemented Changed: AddPlayerForConnection handler is now internal to keep safety checks intact Changed: A bunch of messages converted to value types for performance Version 3.11.6 - 2019-Jul-10 Fixed: Telepathy IPv4, IPv6, and FQDN should all work now Fixed: TelepathyTransport error in UWP builds Fixed: OnApplicationQuit is handled better now Fixed: Performance and memory allocation improvements Changed: Telepathy Source is now included instead of a DLL Version 3.10.10 - 2019-Jun-19 Added: Scene Message now supports params for SceneMode (Normal / Additive) and PhysicsMode (2D / 3D) Added: ClientScene.Send now has an optional ChannelId parameter Added: ASMDEF to Examples folder Added: Support for sending and receiving ArraySegment<byte> Added: IReadOnlyList<T> in SyncLists Fixed: NetworkManager not switching to correct scene in some cases Fixed: ListServer Ping not found in WebGL Fixed: TelepathyTransport.GetMaxPacketSize uses the new configurable max size Fixed: Significant reduction in memory allocation and garbage collection Changed: Use transform.localPosition and transform.localRotation for better VR support Removed: Websockets send queues (they never worked) and SSL (temporarily because it didn't work) Version 3.6.7 -- 2019-Apr-28 Changed: NetworkReader now uses ArraySegment<byte> to minimize allocations. Version 3.6.6 -- 2019-Apr-24 Fixed: Reverted two internal refactor commits that had unintended consequences Version 3.6.5 -- 2019-Apr-23 Fixed: Unity 2019.1 compatibility Fixed: Erroneous error indicating prefabs were missing Scene ID's Fixed: OnDeserializeSafely now works without allocations Fixed: Weaver not writing symbol files, preventing breakpoints from working in Visual Studio Fixed: NetworkIdentity SceneID generation now uses RNG Crypto Service Provider Fixed: Scene lighting in Additive example Fixed: Player Prefab transform details now respected when instantiated in the absence of NetworkStartPosition Removed: Tests folder from Unity package generation (no end-user value) Version 3.5.9 -- 2019-Apr-12 Fixed: NetworkManager round-robin mode using NetworkStartPosition objects now uses hierarchy sibling order Fixed: IsLocalPlayer is now reliably accurate in Start() by combining OwnerMessage and SpawnPrefabMessage Fixed: Stack overflow issues with Weaver and Cecil Fixed: Corrected assembly paths passed to weaver Fixed: Enum bandwdith reduced in SyncVars, Commands, and Rpcs Fixed: Placeholder files added for removed code files so updating works better Changed: NetworkManager isHeadless is a static property now, changed from IsHeadless() Version 3.5.3 -- 2019-Apr-10 Fixed: Exceptions in overrides of Network Manager and other components incorrectly silenced. Fixed: Lobby system sometimes would not spawn and swap game player prefabs into the game scene Fixed: Application.targetFrameRate no longer set in host mode Changed: Telepathy: Split MaxMessageSize to allow setting a different value for client and server Version 3.4.9 -- 2019-Apr-6 Added: Semantic Versioning (which is why we jumped from 1.6 to 3.4.9) Added: SyncDictionary Added: SyncHashSet Added: SyncSortedSet Added: SyncList and SyncDictionary support all IList and IDictionary derived types, respectively Added: Documentation for SyncVars Added: Documentation for SyncEvents Added: NoRotation to NetworkTransform Added: Scale is now included in spawn payload along with position and rotation Added: Generic IMessageBase to allow struct message types Added: Weaver now supports Vector2Int and Vector3Int Added: List Server example Added: Additive Scenes example Fixed: SyncLists now work correctly for primitives and structs Fixed: SyncVar Hooks now will update the local property value after the hook is called You no longer need to have a line of code in your hook method to manualy update the local property. Fixed: Host should not call Disconnect on transports Fixed: NetworkAnimimator now supports up to 64 animator parameters Fixed: NetworkManager StartServer no longer assumes scene zero is the default scene...uses GetActiveScene now Fixed: NetworkServer Shutdown now resets netId to zero Fixed: Observers are now properly rebuilt when client joins and OnRebuildObservers / OnCheckObserver is overridden Fixed: NetworkProximityChecker: On rare occasion, player could be excluded from observers rebuild Fixed: NetworkLobbyPlayer OnClientReady works now Fixed: NetworkLobbyPlayer Remove button not showing for P1 when Server Only Fixed: NetworkLobbyManager pendingPlayers and lobbySlots lists are now public for inheritors Fixed: Offline scene switching now works via StopClient() Fixed: Pong example updated Fixed: Source Weaver was deleting PDB files, preventing breakpoints and debugging from working. Changed: TargetRpc NetworkConnection paramater is now optional...the calling client's NetworkConnection is default Changed: Movement example replaced with Tank example Changed: NetworkClient functions are all static now, so the singleton is gone. Use NetworkClient directly. Changed: SyncList now supports structs directly, making SyncListSTRUCT obsolete. Removed: SyncListSTRUCT - Use SyncList instead. Removed: NetworkClient.ShutdownAll is obsolete -- Use NetworkClient.Shutdown instead Version 1.6 -- 2019-Mar-14 Fixed: Websockets transport moved to Mirror.Websocket namespace Fixed: NetworkAnimator bandwidth abuse Fixed: NetworkAnimator float sync bug Fixed: Persistent SceneID's for Networked objects Changed: Documentation for Transports Changed: Weaver is now full source...FINALLY! Changed: ClientScene.AddPlayer 2nd parameter is now byte[] extraData instead of MessageBase extraMessage Please refer to the code sample here to see how to update your code. Changed: NetworkManager -- Headless Auto-Start moved to Start() from Awake() Changed: Removed Message ID's for all messages - See Network Messages for details Message IDs are now generated automatically based on the message name. Previously you would call Send(MyMessage.MsgId, message), now you call Send(message) Removed: Documentation for Groove Transport - use Websockets Transport instead Version 1.5 -- 2019-Mar-01 Added: Migration Tool to (mostly) automate conversion from UNet Added: Full support for WebSockets and WebSocketsSecure to replace UNet LLAPI Added: Transport Multiplexer - allows the use of multiple concurrent transports Added: NetworkLobbyManager and NetworkLobbyPlayer with example game Added: Configurable Server Tickrate in NetworkManager Added: New virtual OnClientChangeScene fires right before SceneManager.LoadSceneAsync is executed Added: Unit tests for Weaver Fixed: Garbage allocations removed from a lot of things (more work to do, we know) Fixed: NetworkProximityChecker now uses OverlapSphereNonAlloc and OverlapCircleNonAlloc Fixed: SyncVar hook not firing when clients joined Fixed: NetworkManager no longer assumes it's on Scene(0) in Build Settings Fixed: NetworkAnimator no longer lmited to 6 variables Fixed: TelepathyTransport delivering messages when disabled Changed: Minimum Unity version: 2018.3.6 Removed: SceneAttribute.cs (merged to CustomAttributes.cs) Removed: NetworkClient.allClients (Use NetworkClient.singleton instead) Removed: NetworkServer.hostId and NetworkConnection.hostId (holdovers from LLAPI) Removed: NetworkConnection.isConnected (NetworkConnection is always connected) Removed: Transport.GetConnectionInfo (Use ServerGetClientAddress instead) Version 1.4 -- 2019-Feb-01 Added: HelpURL attirbutes to components Added: Automatic targetFramerate for headless builds Added: ByteMessage to Messages class Fixed: Connectiing state can be cancelled properly Fixed: NetworkTransformBase interpolation applied to client's own object Fixed: Objects are spawned with correct rotation Fixed: SceneId assignment Fixed: Changed syncInterval wasn't saved...it is now Fixed: Additive Scene loading Changed: Mirror is now full source -- no more DLL's Changed: Transports are now components -- TCP, UDP, WebGL, Steam Changed: Transport class now dispatches Unity Events Changed: NetworkServer.SendToClientOfPlayer uses NetworkIdentity now Changed: NetworkServer.SendToObservers uses NetworkIdentity parameter now Changed: NetworkServer.SendToReady uses NetworkIdentity now Changed: NetworkServer.DestroyPlayerForConnection uses NetworkIdentity.spawned now Changed: NetworkConnection.Dispose uses NetworkIdentity.spawned now Changed: NetworkReader.ReadTransform uses NetworkIdentity.spawned now Changed: NetworkTransform reimplemented -- physics removed, code simplified Removed: NetworkClient.hostPort (port is handled at Transport level) Removed: NetworkServer.FindLocalObject (Use NetworkIdentity.spawned[netId] instead) Removed: ClientScene.FindLocalObject (Use NetworkIdentity.spawned[netId] instead)"
  },
  "General/Support.html": {
    "href": "General/Support.html",
    "title": "Support",
    "keywords": "Support Discord You can find us on Discord . GitHub You can create an issue in GitHub You can also contribute with Pull Requests...see Contributing"
  },
  "General/Migration.html": {
    "href": "General/Migration.html",
    "title": "Migration Guide",
    "keywords": "Migration Guide Migrating a project from UNet (HLAPI) This guide gives you a step by step instruction for migrating your project from HLAP to Mirror. Mirror is a fork of UNet. As such the migration is straight forward for most projects. You should review the information on the Deprecations page to see if your project will be impacted. There's also a Migration Tool you can try: https://github.com/Lymdun/MirrorConverter/ 1. BACKUP You have been warned. 2. Install Mirror and Restart Unity Get Mirror from the asset store and import it in your project. Alternatively you can grab the latest release from GitHub if you're feeling adventurous, but be aware that bleeding edge dev releases are not necessarily stable. NOTE: You must restart Unity after adding Mirror to the project for the components menu to update correctly. 3. Replace namespace Replace UnityEngine.Networking for Mirror everywhere in your project. For example, if you have this: using UnityEngine.Networking; public class Player : NetworkBehaviour { ... } replace it with: using Mirror; public class Player : NetworkBehaviour { ... } At this point, you might get some compilation errors. Don't panic, these are easy to fix. Keep going... 4. Replace playerController with identity Replace references to NetworkConnection.playerController with NetworkConnection.identity . Click here for guidance. 5. Remove NetworkSettings NetworkSettings in UNet have channels, but this is flat out broken. Rather than ignoring your settings we removed channels from NetworkSettings completely. sendInterval is now set in code and / or the inspector too. For example, if you have this code: [NetworkSettings(channel=1,sendInterval=0.05f)] public class NetStreamer : NetworkBehaviour { ... } replace it with: public class NetStreamer : NetworkBehaviour { void Start() { syncInterval = 0.05f; } } Please note that the default transport Telpathy , completely ignores channels, all messages are reliable, sequenced and fragmented. They just work with no fuss. If you want to take advantage of unreliable channels use LLAPITransport instead. 6. Change SyncListStruct to SyncList There is a bug in the original UNet Weaver that makes it mess with our Mirror.SyncListStruct without checking the namespace. In Mirror, we fixed SyncLists so that they work with structs by default. For example, if you have definitions like: public class SyncListQuest : SyncListStruct<Quest> { } replace them with: public class SyncListQuest : SyncList<Quest> { } 7. Replace NetworkHash128 and NetworkInstanceId These have been changed to System.Guid and uint, respectively. For example, if you have something like this: public sealed class SpawnItemMessage : MessageBase { public NetworkHash128 assetID; public NetworkInstanceId networkInstanceID; public Vector3 position; public Quaternion rotation; } replace with: public sealed class SpawnItemMessage : MessageBase { public System.Guid assetID; public uint networkInstanceID; public Vector3 position; public Quaternion rotation; } 8. Update your synclist callbacks In UNet, SyncLists have a callback delegate that gets called in the client whenever the list is updated. We have changed the callback to be a C# event instead and we also pass the item that was updated/removed. For example, if you have this code: using UnityEngine; using UnityEngine.Networking; public class MyBehaviour : NetworkBehaviour { public SyncListInt m_ints = new SyncListInt(); private void OnIntChanged(SyncListInt.Operation op, int index) { Debug.Log(\"list changed \" + op); } public override void OnStartClient() { m_ints.Callback = OnIntChanged; } } replace it with: using UnityEngine; using Mirror; public class MyBehaviour : NetworkBehaviour { public SyncListInt m_ints = new SyncListInt(); private void OnIntChanged(SyncListInt.Operation op, int index, int item) { Debug.Log(\"list changed \" + op + \" item \" + item); } public override void OnStartClient() { m_ints.Callback += OnIntChanged; } } Notice the callback will also work in the server in Mirror. 9. Replace Components Every networked prefab and scene object needs to be adjusted. They will be using NetworkIdentity from Unet, and you need to replace that component with NetworkIdentity from Mirror. You may be using other network components, such as NetworkAnimator or NetworkTransform . All components from Unet should be replaced with their corresponding component from Mirror. Note that if you remove and add a NetworkIdentity, you will need to reassign it in any component that was referencing it. 10. Update Extended Components Some commonly extended components, such as NetworkManager, have changed method parameters in Mirror. A commonly used override is OnServerAddPlayer. Using the original HLAPI, your override may have looked like this: public override void OnServerAddPlayer(NetworkConnection conn, short playerControllerId, NetworkReader extraMessageReader) { base.OnServerAddPlayer(conn, playerControllerId, extraMessageReader); // your code } In your newly Mirror-capable NetworkManager, if you are using the OnServerAddPlayer override, remove the \"playerControllerId\" parameter from your override and the base call, and change the NetworkReader into AddPlayerMessage : public override void OnServerAddPlayer(NetworkConnection conn, AddPlayerMessage extraMessage) { base.OnServerAddPlayer(conn, extraMessage); // your code } Note that in UNet the parameter \"extraMessageReader\" is optional, but in Mirror it is required. 11. Pick your transport You can choose one of several transports in Mirror. Open your NetworkManager gameobject, in the inspector you will see a TelepathyTransport component by default. Drag in one of the available transports and remove TelepathyTransport if you wish to use a UDP based transport instead. 12. Configure address and port In HLAPI, you configure the port and local address in the NetworkManager. One of our goals is to make Mirror transport independent. Not all transports need address and port. Some transports might even use more than one port at the same time, so these settings were inadequate. We removed the port and address and all other Network Info properties from NetworkManager, and we moved them to the transport components instead. 13. Update your firewall and router LLAPI uses UDP. Mirror uses TCP by default. This means you may need to change your router port forwarding and firewall rules in your machine to expose the TCP port instead of UDP. This highly depends on your router and operating system. Video version See for yourself how uMMORPG was migrated to Mirror Possible Error Messages TypeLoadException: A type load exception has occurred. - happens if you still have SyncListStruct instead of SyncListSTRUCT in your project. NullPointerException: The most likely cause is that you replaced NetworkIdentities or other components but you had them assigned somewhere. Reassign those references. error CS0246: The type or namespace name 'UnityWebRequest' could not be found. Are you missing 'UnityEngine.Networking' using directive? Add this to the top of your script: using UnityWebRequest = UnityEngine.Networking.UnityWebRequest; UnityWebRequest is not part of UNet or Mirror, but it is in the same namespace as UNet. Changing the namespace to Mirror caused your script not to find UnityWebRequest. The same applies for WWW and all UnityWebRequest related classes."
  },
  "General/ScriptTemplates.html": {
    "href": "General/ScriptTemplates.html",
    "title": "Script Templates",
    "keywords": "Script Templates We've added Script Templates to make it easier to create derived class scripts that inherit from our base classes. All possible overrides are already made for you and organized They're all fully commented as to what they all do Base method calls are all in place where needed so you can see what they already do. Each has links at the top to their doc page(s) Download the zip file here NOTE : You must restart Unity after importing this package! After importing and restarting Unity, the Mirror section will appear under the Assets > Create menu, as well as the context menu that comes up when you right-click on any folder in your project. You'll be prompted for the file name like any other asset creation. Hopefully these templates will be helpful to new users of Mirror to learn what methods are available in various classes, as well as just being more convenient for everyone."
  },
  "General/index.html": {
    "href": "General/index.html",
    "title": "General Overview",
    "keywords": "General Overview Mirror’s multiplayer High Level API (HLAPI) is a system for building multiplayer capabilities for Unity games. It is built on top of the lower level transport real-time communication layer, and handles many of the common tasks that are required for multiplayer games. While the transport layer supports any kind of network topology, the HLAPI is a server authoritative system; although it allows one of the participants to be a client and the server at the same time, so no dedicated server process is required. Working in conjunction with the internet services, this allows multiplayer games to be played over the internet with little work from developers. The HLAPI is focused on ease of use and iterative development and provides useful functionality for multiplayer games, such as: Message handlers General purpose high performance serialization Distributed object management State synchronization Network classes: Server, Client, Connection, etc The HLAPI is built from a series of layers that add functionality: Server and Host In Mirror’s High Level API (HLAPI) system, multiplayer games include: Server A server is an instance of the game which all other players connect to when they want to play together. A server often manages various aspects of the game, such as keeping score, and transmit that data back to the client. Clients Clients are instances of the game that usually connect from different computers to the server. Clients can connect over a local network, or online. A client is an instance of the game that connects to the server, so that the person playing it can play the game with other people, who connect on their own clients. The server might be either a “dedicated server”, or a “host server”. Dedicated server This is an instance of the game that only runs to act as a server. Host server When there is no dedicated server, one of the clients also plays the role of the server. This client is the “host server”. The host server creates a single instance of the game (called the host), which acts as both server and client. The diagram below represents three players in a multiplayer game. In this game, one client is also acting as host, which means the client itself is the “local client”. The local client connects to the host server, and both run on the same computer. The other two players are remote clients - that is, they are on different computers, connected to the host server. The host is a single instance of your game, acting as both server and client at the same time. The host uses a special kind of internal client for local client communication, while other clients are remote clients. The local client communicates with the server through direct function calls and message queues, because it is in the same process. It actually shares the Scene with the server. Remote clients communicate with the server over a regular network connection. When you use Mirror’s HLAPI, this is all handled automatically for you. One of the aims of the multiplayer system is for the code for local clients and remote clients to be the same, so that you only have to think about one type of client most of the time when developing your game. In most cases, Mirror handles this difference automatically, so you should rarely need to think about the difference between your code running on a local client or a remote client. Instantiate and Spawn When you make a single player game In Mirror, you usually use the GameObject.Instantiate method to create new game objects at runtime. However, with a multiplayer system, the server itself must “spawn” game objects in order for them to be active within the networked game. When the server spawns game objects, it triggers the creation of game objects on connected clients. The spawning system manages the lifecycle of the game object, and synchronizes the state of the game object based on how you set the game object up. For more details about networked instantiating and spawning, see documentation on Spawning game objects . Players and Local Players Mirror’s multiplayer HLAPI system handles player game objects differently to non-player game objects. When a new player joins the game (when a new client connects to the server), that player’s game object becomes a “local player” game object on the client of that player, and Mirror associates the player’s connection with the player’s game object. Mirror associates one player game object for each person playing the game, and routes networking commands to that individual game object. A player cannot invoke a command on another player’s game object, only their own. For more details, see documentation on Player game objects . Authority Servers and clients can both manage a game object’s behavior. The concept of “authority” refers to how and where a game object is managed. Mirror’s HLAPI is based around “server authority” as the default state, where the Server has authority over all game objects. Player game objects are a special case and treated as having “local authority”. You may want to build your game using a different system of authority - for more details, see Network Authority ."
  },
  "Examples/AdditiveScenes/index.html": {
    "href": "Examples/AdditiveScenes/index.html",
    "title": "Additive Scenes",
    "keywords": "Additive Scenes General description of Additive Scenes example."
  },
  "Examples/Tanks/index.html": {
    "href": "Examples/Tanks/index.html",
    "title": "Tanks",
    "keywords": "Tanks General description of Tanks example."
  },
  "Examples/Room/index.html": {
    "href": "Examples/Room/index.html",
    "title": "Room",
    "keywords": "Room General description of Room example."
  },
  "Examples/Basic/index.html": {
    "href": "Examples/Basic/index.html",
    "title": "Basic",
    "keywords": "Basic General description of Basic example."
  },
  "Examples/Pong/index.html": {
    "href": "Examples/Pong/index.html",
    "title": "Pong",
    "keywords": "Pong A simple example for \"How to built a multiplayer game with Mirror\" is Pong, which is included in the AssetStore package of Mirror. It illustrates the usage of NetworkManager, NetworkManagerHUD, NetworkBehaviour, NetworkIdentity, NetworkTransform, NetworkStartPosition and NetworkingAttributes. Setting the number of players First of all, let's have a look at the NetworkManager object in the main scene. When adding the NetworkManager component to a gameobject, a few default settings are already set ( Don't destroy on Load , Run in Background , ...) For playing Pong the maximum number of players is 2, so the setting Network Info/Max connections will also be 2. As there are no other scenes (room, online or offline scene) in this sample the properties for Offline Scene and Online Scene will stay empty. Creating the player Furthermore every player needs a racket to play with. Each player who joins the game will have his own controllable object, which represents him within the game. This gameobject is called PlayerObject . For spawning the PlayerObject a prefab has to be created, containing at least a NetworkIdentity component with Local Player Authority checked. The Local Player Authority allows the player to control and modify the gameobjects properties (e.g. for movement). The NetworkManager needs a reference to this prefab, which is located in Spawn Info/Player Prefab . To have the player movement synchronized over the network, the player prefab also contains a NetworkTransform. Player start position The main scene contains 2 gameobjects with only a NetworkStartPosition component (gameobjects RacketSpawnLeft, RacketSpawnRight in the scene). These transforms will be automatically registered by the NetworkManager as spawning positions. Setting up the network A very convenient component for establish/testing connections is the NetworkManagerHUD. It provides basic functionality for start a game as LAN client, LAN server or host (LAN client and LAN server at the same time). It requires the NetworkManager component. The ball of Pong The ball is the main focus of Pong, as this is the object needed to score points. Its NetworkIdentity component has neither Server Only nor Local Player Authority checked, as it's moved by the server physics engine and can be influenced by the players. As with the PlayerObject the position is synchronized via NetworkTransform. When having multiple scenes, the ball can be spawned by the NetworkManager, but to keep this sample simple, it's placed directly within the main scene."
  },
  "Examples/index.html": {
    "href": "Examples/index.html",
    "title": "Samples Overview",
    "keywords": "Samples Overview Mirror includes several small examples to help you learn how to use various features and how to set things up so they work together. Basic Basic is what it sounds like...the most rudimentary baseline of a networked game. Features SyncVars updating random UI data for each player. Tanks This is a simple scene with animated tanks, networked rigidbody projectiles, and NavMesh movement Pong A simple example for \"How to build a multiplayer game with Mirror\" is Pong. It illustrates the usage of NetworkManager , NetworkManagerHUD , NetworkBehaviour, NetworkIdentity, NetworkTransform , NetworkStartPosition and various Attributes. Additive Scenes The Additive Scenes example demonstrates a server additively loading a sub-scene into a main scene at startup, and having a server-only trigger that generates a message to any client whose player enters the trigger zone to also load the sub-scene, and subsequently unload it when they leave the trigger zone. Only players inside the trigger zone can see the objects in the sub-scene. Network Proximity Checker components are key to making this scenario work. Room System The Room System example demonstrates how to set up a \"staging\" scene where players assemble before starting a match. When all players are ready, the server sends them all a message to change scenes (along with the server itself) to the actual game play scene so they all come in at once. Includes fully playable game with a character controller where players collect server-spawned prizes for score."
  },
  "api/Mirror.SyncIDictionary-2.html": {
    "href": "api/Mirror.SyncIDictionary-2.html",
    "title": "Class SyncIDictionary<TKey, TValue>",
    "keywords": "Class SyncIDictionary<TKey, TValue> Inheritance System.Object SyncIDictionary<TKey, TValue> SyncDictionary<TKey, TValue> Implements ISyncObject Namespace : Mirror Assembly : doc.dll Syntax public abstract class SyncIDictionary<TKey, TValue> : IDictionary<TKey, TValue>, ISyncObject Type Parameters Name Description TKey TValue Constructors | Improve this Doc View Source SyncIDictionary(IDictionary<TKey, TValue>) Declaration protected SyncIDictionary(IDictionary<TKey, TValue> objects) Parameters Type Name Description IDictionary <TKey, TValue> objects Fields | Improve this Doc View Source objects Declaration protected readonly IDictionary<TKey, TValue> objects Field Value Type Description IDictionary <TKey, TValue> Properties | Improve this Doc View Source Count Declaration public int Count { get; } Property Value Type Description System.Int32 | Improve this Doc View Source IsDirty Declaration public bool IsDirty { get; } Property Value Type Description System.Boolean | Improve this Doc View Source IsReadOnly Declaration public bool IsReadOnly { get; } Property Value Type Description System.Boolean | Improve this Doc View Source Item[TKey] Declaration public TValue this[TKey i] { get; set; } Parameters Type Name Description TKey i Property Value Type Description TValue | Improve this Doc View Source Keys Declaration public ICollection<TKey> Keys { get; } Property Value Type Description ICollection <TKey> | Improve this Doc View Source Values Declaration public ICollection<TValue> Values { get; } Property Value Type Description ICollection <TValue> Methods | Improve this Doc View Source Add(TKey, TValue) Declaration public void Add(TKey key, TValue value) Parameters Type Name Description TKey key TValue value | Improve this Doc View Source Add(KeyValuePair<TKey, TValue>) Declaration public void Add(KeyValuePair<TKey, TValue> item) Parameters Type Name Description KeyValuePair <TKey, TValue> item | Improve this Doc View Source Clear() Declaration public void Clear() | Improve this Doc View Source Contains(KeyValuePair<TKey, TValue>) Declaration public bool Contains(KeyValuePair<TKey, TValue> item) Parameters Type Name Description KeyValuePair <TKey, TValue> item Returns Type Description System.Boolean | Improve this Doc View Source ContainsKey(TKey) Declaration public bool ContainsKey(TKey key) Parameters Type Name Description TKey key Returns Type Description System.Boolean | Improve this Doc View Source CopyTo(KeyValuePair<TKey, TValue>[], Int32) Declaration public void CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex) Parameters Type Name Description KeyValuePair <TKey, TValue>[] array System.Int32 arrayIndex | Improve this Doc View Source DeserializeItem(NetworkReader) Declaration protected virtual TValue DeserializeItem(NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description TValue | Improve this Doc View Source DeserializeKey(NetworkReader) Declaration protected virtual TKey DeserializeKey(NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description TKey | Improve this Doc View Source Flush() Declaration public void Flush() | Improve this Doc View Source GetEnumerator() Declaration public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator() Returns Type Description IEnumerator < KeyValuePair <TKey, TValue>> | Improve this Doc View Source OnDeserializeAll(NetworkReader) Declaration public void OnDeserializeAll(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source OnDeserializeDelta(NetworkReader) Declaration public void OnDeserializeDelta(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source OnSerializeAll(NetworkWriter) Declaration public void OnSerializeAll(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer | Improve this Doc View Source OnSerializeDelta(NetworkWriter) Declaration public void OnSerializeDelta(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer | Improve this Doc View Source Remove(TKey) Declaration public bool Remove(TKey key) Parameters Type Name Description TKey key Returns Type Description System.Boolean | Improve this Doc View Source Remove(KeyValuePair<TKey, TValue>) Declaration public bool Remove(KeyValuePair<TKey, TValue> item) Parameters Type Name Description KeyValuePair <TKey, TValue> item Returns Type Description System.Boolean | Improve this Doc View Source SerializeItem(NetworkWriter, TValue) Declaration protected virtual void SerializeItem(NetworkWriter writer, TValue item) Parameters Type Name Description NetworkWriter writer TValue item | Improve this Doc View Source SerializeKey(NetworkWriter, TKey) Declaration protected virtual void SerializeKey(NetworkWriter writer, TKey item) Parameters Type Name Description NetworkWriter writer TKey item | Improve this Doc View Source TryGetValue(TKey, out TValue) Declaration public bool TryGetValue(TKey key, out TValue value) Parameters Type Name Description TKey key TValue value Returns Type Description System.Boolean Events | Improve this Doc View Source Callback Declaration public event SyncIDictionary<TKey, TValue>.SyncDictionaryChanged Callback Event Type Type Description SyncIDictionary.SyncDictionaryChanged <> Implements ISyncObject"
  },
  "api/Mirror.NetworkConnectionToClient.html": {
    "href": "api/Mirror.NetworkConnectionToClient.html",
    "title": "Class NetworkConnectionToClient",
    "keywords": "Class NetworkConnectionToClient Inheritance System.Object NetworkConnection NetworkConnectionToClient Inherited Members NetworkConnection.connectionId NetworkConnection.isAuthenticated NetworkConnection.authenticationData NetworkConnection.isReady NetworkConnection.lastMessageTime NetworkConnection.identity NetworkConnection.clientOwnedObjects NetworkConnection.logNetworkMessages NetworkConnection.Dispose() NetworkConnection.Dispose(Boolean) NetworkConnection.Send<T>(T, Int32) NetworkConnection.ValidatePacketSize(ArraySegment<Byte>, Int32) NetworkConnection.ToString() NetworkConnection.InvokeHandler<T>(T, Int32) Namespace : Mirror Assembly : doc.dll Syntax public class NetworkConnectionToClient : NetworkConnection Constructors | Improve this Doc View Source NetworkConnectionToClient(Int32) Declaration public NetworkConnectionToClient(int networkConnectionId) Parameters Type Name Description System.Int32 networkConnectionId Properties | Improve this Doc View Source address Declaration public override string address { get; } Property Value Type Description System.String Overrides NetworkConnection.address Methods | Improve this Doc View Source Disconnect() Disconnects this connection. Declaration public override void Disconnect() Overrides NetworkConnection.Disconnect()"
  },
  "api/Mirror.NetworkTransformBase.DataPoint.html": {
    "href": "api/Mirror.NetworkTransformBase.DataPoint.html",
    "title": "Class NetworkTransformBase.DataPoint",
    "keywords": "Class NetworkTransformBase.DataPoint Inheritance System.Object NetworkTransformBase.DataPoint Namespace : Mirror Assembly : doc.dll Syntax public class DataPoint : object Fields | Improve this Doc View Source LocalPosition Declaration public Vector3 LocalPosition Field Value Type Description Vector3 | Improve this Doc View Source LocalRotation Declaration public Quaternion LocalRotation Field Value Type Description Quaternion | Improve this Doc View Source LocalScale Declaration public Vector3 LocalScale Field Value Type Description Vector3 | Improve this Doc View Source MovementSpeed Declaration public float MovementSpeed Field Value Type Description System.Single | Improve this Doc View Source TimeStamp Declaration public float TimeStamp Field Value Type Description System.Single"
  },
  "api/Telepathy.EventType.html": {
    "href": "api/Telepathy.EventType.html",
    "title": "Enum EventType",
    "keywords": "Enum EventType Namespace : Telepathy Assembly : doc.dll Syntax public enum EventType : int Fields Name Description Connected Data Disconnected"
  },
  "api/Mirror.NetworkBehaviour.html": {
    "href": "api/Mirror.NetworkBehaviour.html",
    "title": "Class NetworkBehaviour",
    "keywords": "Class NetworkBehaviour Base class which should be inherited by scripts which contain networking functionality. Inheritance System.Object NetworkBehaviour NetworkAnimator NetworkProximityChecker NetworkRoomPlayer NetworkTransformBase Namespace : Mirror Assembly : doc.dll Syntax public class NetworkBehaviour : MonoBehaviour Remarks This is a MonoBehaviour class so scripts which need to use the networking feature should inherit this class instead of MonoBehaviour. It allows you to invoke networked actions, receive various callbacks, and automatically synchronize state from server-to-client. The NetworkBehaviour component requires a NetworkIdentity on the game object. There can be multiple NetworkBehaviours on a single game object. For an object with sub-components in a hierarchy, the NetworkIdentity must be on the root object, and NetworkBehaviour scripts must also be on the root object. Some of the built-in components of the networking system are derived from NetworkBehaviour, including NetworkTransport, NetworkAnimator and NetworkProximityChecker. Fields | Improve this Doc View Source syncInterval sync interval for OnSerialize (in seconds) Declaration public float syncInterval Field Value Type Description System.Single | Improve this Doc View Source syncMode sync mode for OnSerialize Declaration public SyncMode syncMode Field Value Type Description SyncMode | Improve this Doc View Source syncObjects objects that can synchronize themselves, such as synclists Declaration protected readonly List<ISyncObject> syncObjects Field Value Type Description List < ISyncObject > Properties | Improve this Doc View Source ComponentIndex Returns the index of the component on this object Declaration public int ComponentIndex { get; } Property Value Type Description System.Int32 | Improve this Doc View Source connectionToClient The NetworkConnection associated with this NetworkIdentity This is only valid for player objects on the server. Declaration public NetworkConnection connectionToClient { get; } Property Value Type Description NetworkConnection | Improve this Doc View Source connectionToServer The NetworkConnection associated with this NetworkIdentity This is only valid for player objects on the server. Declaration public NetworkConnection connectionToServer { get; } Property Value Type Description NetworkConnection | Improve this Doc View Source hasAuthority This returns true if this object is the authoritative version of the object in the distributed network application. The hasAuthority value on the NetworkIdentity determines how authority is determined. For most objects, authority is held by the server. For objects with hasAuthority set, authority is held by the client of that player. Declaration public bool hasAuthority { get; } Property Value Type Description System.Boolean | Improve this Doc View Source isClient Returns true if running as a client and this object was spawned by a server. Declaration public bool isClient { get; } Property Value Type Description System.Boolean | Improve this Doc View Source isClientOnly True if this object exists on a client that is not also acting as a server Declaration public bool isClientOnly { get; } Property Value Type Description System.Boolean | Improve this Doc View Source isLocalPlayer This returns true if this object is the one that represents the player on the local machine. In multiplayer games, there are multiple instances of the Player object. The client needs to know which one is for \"themselves\" so that only that player processes input and potentially has a camera attached. The IsLocalPlayer function will return true only for the player instance that belongs to the player on the local machine, so it can be used to filter out input for non-local players. Declaration public bool isLocalPlayer { get; } Property Value Type Description System.Boolean | Improve this Doc View Source isServer Returns true if this object is active on an active server. This is only true if the object has been spawned. This is different from NetworkServer.active, which is true if the server itself is active rather than this object being active. Declaration public bool isServer { get; } Property Value Type Description System.Boolean | Improve this Doc View Source isServerOnly True if this object only exists on the server Declaration public bool isServerOnly { get; } Property Value Type Description System.Boolean | Improve this Doc View Source netId The unique network Id of this object. This is assigned at runtime by the network server and will be unique for all objects for that network session. Declaration public uint netId { get; } Property Value Type Description System.UInt32 | Improve this Doc View Source netIdentity Returns the NetworkIdentity of this object Declaration public NetworkIdentity netIdentity { get; } Property Value Type Description NetworkIdentity | Improve this Doc View Source syncVarDirtyBits Declaration protected ulong syncVarDirtyBits { get; } Property Value Type Description System.UInt64 Methods | Improve this Doc View Source ClearAllDirtyBits() This clears all the dirty bits that were set on this script by SetDirtyBits(); This is automatically invoked when an update is sent for this object, but can be called manually as well. Declaration public void ClearAllDirtyBits() | Improve this Doc View Source GetRpcHandler(Int32) Gets the handler function for a given hash Can be used by profilers and debuggers Declaration public static NetworkBehaviour.CmdDelegate GetRpcHandler(int cmdHash) Parameters Type Name Description System.Int32 cmdHash rpc function hash Returns Type Description NetworkBehaviour.CmdDelegate The function delegate that will handle the command | Improve this Doc View Source GetSyncVarGameObject(UInt32, ref GameObject) Declaration protected GameObject GetSyncVarGameObject(uint netId, ref GameObject gameObjectField) Parameters Type Name Description System.UInt32 netId GameObject gameObjectField Returns Type Description GameObject | Improve this Doc View Source getSyncVarHookGuard(UInt64) Declaration protected bool getSyncVarHookGuard(ulong dirtyBit) Parameters Type Name Description System.UInt64 dirtyBit Returns Type Description System.Boolean | Improve this Doc View Source GetSyncVarNetworkIdentity(UInt32, ref NetworkIdentity) Declaration protected NetworkIdentity GetSyncVarNetworkIdentity(uint netId, ref NetworkIdentity identityField) Parameters Type Name Description System.UInt32 netId NetworkIdentity identityField Returns Type Description NetworkIdentity | Improve this Doc View Source InitSyncObject(ISyncObject) Declaration protected void InitSyncObject(ISyncObject syncObject) Parameters Type Name Description ISyncObject syncObject | Improve this Doc View Source InvokeCommand(Int32, NetworkReader) Manually invoke a Command. Declaration public virtual bool InvokeCommand(int cmdHash, NetworkReader reader) Parameters Type Name Description System.Int32 cmdHash Hash of the Command name. NetworkReader reader Parameters to pass to the command. Returns Type Description System.Boolean Returns true if successful. | Improve this Doc View Source InvokeRPC(Int32, NetworkReader) Manually invoke an RPC function. Declaration public virtual bool InvokeRPC(int rpcHash, NetworkReader reader) Parameters Type Name Description System.Int32 rpcHash Hash of the RPC name. NetworkReader reader Parameters to pass to the RPC function. Returns Type Description System.Boolean Returns true if successful. | Improve this Doc View Source InvokeSyncEvent(Int32, NetworkReader) Manually invoke a SyncEvent. Declaration public virtual bool InvokeSyncEvent(int eventHash, NetworkReader reader) Parameters Type Name Description System.Int32 eventHash Hash of the SyncEvent name. NetworkReader reader Parameters to pass to the SyncEvent. Returns Type Description System.Boolean Returns true if successful. | Improve this Doc View Source OnCheckObserver(NetworkConnection) Callback used by the visibility system to determine if an observer (player) can see this object. If this function returns true, the network connection will be added as an observer. Declaration public virtual bool OnCheckObserver(NetworkConnection conn) Parameters Type Name Description NetworkConnection conn Network connection of a player. Returns Type Description System.Boolean True if the player can see this object. | Improve this Doc View Source OnDeserialize(NetworkReader, Boolean) Virtual function to override to receive custom serialization data. The corresponding function to send serialization data is OnSerialize(). Declaration public virtual void OnDeserialize(NetworkReader reader, bool initialState) Parameters Type Name Description NetworkReader reader Reader to read from the stream. System.Boolean initialState True if being sent initial state. | Improve this Doc View Source OnNetworkDestroy() This is invoked on clients when the server has caused this object to be destroyed. This can be used as a hook to invoke effects or do client specific cleanup. Declaration public virtual void OnNetworkDestroy() | Improve this Doc View Source OnRebuildObservers(HashSet<NetworkConnection>, Boolean) Callback used by the visibility system to (re)construct the set of observers that can see this object. Implementations of this callback should add network connections of players that can see this object to the observers set. Declaration public virtual bool OnRebuildObservers(HashSet<NetworkConnection> observers, bool initialize) Parameters Type Name Description HashSet < NetworkConnection > observers The new set of observers for this object. System.Boolean initialize True if the set of observers is being built for the first time. Returns Type Description System.Boolean true when overwriting so that Mirror knows that we wanted to rebuild observers ourselves. otherwise it uses built in rebuild. | Improve this Doc View Source OnSerialize(NetworkWriter, Boolean) Virtual function to override to send custom serialization data. The corresponding function to send serialization data is OnDeserialize(). Declaration public virtual bool OnSerialize(NetworkWriter writer, bool initialState) Parameters Type Name Description NetworkWriter writer Writer to use to write to the stream. System.Boolean initialState If this is being called to send initial state. Returns Type Description System.Boolean True if data was written. Remarks The initialState flag is useful to differentiate between the first time an object is serialized and when incremental updates can be sent. The first time an object is sent to a client, it must include a full state snapshot, but subsequent updates can save on bandwidth by including only incremental changes. Note that SyncVar hook functions are not called when initialState is true, only for incremental updates. If a class has SyncVars, then an implementation of this function and OnDeserialize() are added automatically to the class. So a class that has SyncVars cannot also have custom serialization functions. The OnSerialize function should return true to indicate that an update should be sent. If it returns true, then the dirty bits for that script are set to zero, if it returns false then the dirty bits are not changed. This allows multiple changes to a script to be accumulated over time and sent when the system is ready, instead of every frame. | Improve this Doc View Source OnSetHostVisibility(Boolean) Callback used by the visibility system for objects on a host. Objects on a host (with a local client) cannot be disabled or destroyed when they are not visibile to the local client. So this function is called to allow custom code to hide these objects. A typical implementation will disable renderer components on the object. This is only called on local clients on a host. Declaration public virtual void OnSetHostVisibility(bool visible) Parameters Type Name Description System.Boolean visible New visibility state. | Improve this Doc View Source OnStartAuthority() This is invoked on behaviours that have authority, based on context and hasAuthority . This is called after OnStartServer() and before OnStartClient() When AssignClientAuthority(NetworkConnection) is called on the server, this will be called on the client that owns the object. When an object is spawned with Spawn(GameObject, NetworkConnection) with a NetworkConnection parameter included, this will be called on the client that owns the object. Declaration public virtual void OnStartAuthority() | Improve this Doc View Source OnStartClient() Called on every NetworkBehaviour when it is activated on a client. Objects on the host have this function called, as there is a local client on the host. The values of SyncVars on object are guaranteed to be initialized correctly with the latest state from the server when this function is called on the client. Declaration public virtual void OnStartClient() | Improve this Doc View Source OnStartLocalPlayer() Called when the local player object has been set up. This happens after OnStartClient(), as it is triggered by an ownership message from the server. This is an appropriate place to activate components or functionality that should only be active for the local player, such as cameras and input. Declaration public virtual void OnStartLocalPlayer() | Improve this Doc View Source OnStartServer() This is invoked for NetworkBehaviour objects when they become active on the server. This could be triggered by NetworkServer.Listen() for objects in the scene, or by NetworkServer.Spawn() for objects that are dynamically created. This will be called for objects on a \"host\" as well as for object on a dedicated server. Declaration public virtual void OnStartServer() | Improve this Doc View Source OnStopAuthority() This is invoked on behaviours when authority is removed. When NetworkIdentity.RemoveClientAuthority is called on the server, this will be called on the client that owns the object. Declaration public virtual void OnStopAuthority() | Improve this Doc View Source RegisterCommandDelegate(Type, String, NetworkBehaviour.CmdDelegate) Declaration protected static void RegisterCommandDelegate(Type invokeClass, string cmdName, NetworkBehaviour.CmdDelegate func) Parameters Type Name Description Type invokeClass System.String cmdName NetworkBehaviour.CmdDelegate func | Improve this Doc View Source RegisterDelegate(Type, String, MirrorInvokeType, NetworkBehaviour.CmdDelegate) Declaration protected static void RegisterDelegate(Type invokeClass, string cmdName, MirrorInvokeType invokerType, NetworkBehaviour.CmdDelegate func) Parameters Type Name Description Type invokeClass System.String cmdName MirrorInvokeType invokerType NetworkBehaviour.CmdDelegate func | Improve this Doc View Source RegisterEventDelegate(Type, String, NetworkBehaviour.CmdDelegate) Declaration protected static void RegisterEventDelegate(Type invokeClass, string eventName, NetworkBehaviour.CmdDelegate func) Parameters Type Name Description Type invokeClass System.String eventName NetworkBehaviour.CmdDelegate func | Improve this Doc View Source RegisterRpcDelegate(Type, String, NetworkBehaviour.CmdDelegate) Declaration protected static void RegisterRpcDelegate(Type invokeClass, string rpcName, NetworkBehaviour.CmdDelegate func) Parameters Type Name Description Type invokeClass System.String rpcName NetworkBehaviour.CmdDelegate func | Improve this Doc View Source SendCommandInternal(Type, String, NetworkWriter, Int32) Declaration protected void SendCommandInternal(Type invokeClass, string cmdName, NetworkWriter writer, int channelId) Parameters Type Name Description Type invokeClass System.String cmdName NetworkWriter writer System.Int32 channelId | Improve this Doc View Source SendEventInternal(Type, String, NetworkWriter, Int32) Declaration protected void SendEventInternal(Type invokeClass, string eventName, NetworkWriter writer, int channelId) Parameters Type Name Description Type invokeClass System.String eventName NetworkWriter writer System.Int32 channelId | Improve this Doc View Source SendRPCInternal(Type, String, NetworkWriter, Int32) Declaration protected void SendRPCInternal(Type invokeClass, string rpcName, NetworkWriter writer, int channelId) Parameters Type Name Description Type invokeClass System.String rpcName NetworkWriter writer System.Int32 channelId | Improve this Doc View Source SendTargetRPCInternal(NetworkConnection, Type, String, NetworkWriter, Int32) Declaration protected void SendTargetRPCInternal(NetworkConnection conn, Type invokeClass, string rpcName, NetworkWriter writer, int channelId) Parameters Type Name Description NetworkConnection conn Type invokeClass System.String rpcName NetworkWriter writer System.Int32 channelId | Improve this Doc View Source SerializeObjectsAll(NetworkWriter) Declaration public bool SerializeObjectsAll(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Returns Type Description System.Boolean | Improve this Doc View Source SerializeObjectsDelta(NetworkWriter) Declaration public bool SerializeObjectsDelta(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Returns Type Description System.Boolean | Improve this Doc View Source SetDirtyBit(UInt64) Used to set the behaviour as dirty, so that a network update will be sent for the object. these are masks, not bit numbers, ie. 0x004 not 2 Declaration public void SetDirtyBit(ulong dirtyBit) Parameters Type Name Description System.UInt64 dirtyBit Bit mask to set. | Improve this Doc View Source SetSyncVar<T>(T, ref T, UInt64) Declaration protected void SetSyncVar<T>(T value, ref T fieldValue, ulong dirtyBit) Parameters Type Name Description T value T fieldValue System.UInt64 dirtyBit Type Parameters Name Description T | Improve this Doc View Source SetSyncVarGameObject(GameObject, ref GameObject, UInt64, ref UInt32) Declaration protected void SetSyncVarGameObject(GameObject newGameObject, ref GameObject gameObjectField, ulong dirtyBit, ref uint netIdField) Parameters Type Name Description GameObject newGameObject GameObject gameObjectField System.UInt64 dirtyBit System.UInt32 netIdField | Improve this Doc View Source setSyncVarHookGuard(UInt64, Boolean) Declaration protected void setSyncVarHookGuard(ulong dirtyBit, bool value) Parameters Type Name Description System.UInt64 dirtyBit System.Boolean value | Improve this Doc View Source SetSyncVarNetworkIdentity(NetworkIdentity, ref NetworkIdentity, UInt64, ref UInt32) Declaration protected void SetSyncVarNetworkIdentity(NetworkIdentity newIdentity, ref NetworkIdentity identityField, ulong dirtyBit, ref uint netIdField) Parameters Type Name Description NetworkIdentity newIdentity NetworkIdentity identityField System.UInt64 dirtyBit System.UInt32 netIdField | Improve this Doc View Source SyncVarEqual<T>(T, ref T) Declaration protected bool SyncVarEqual<T>(T value, ref T fieldValue) Parameters Type Name Description T value T fieldValue Returns Type Description System.Boolean Type Parameters Name Description T | Improve this Doc View Source SyncVarGameObjectEqual(GameObject, UInt32) Declaration protected bool SyncVarGameObjectEqual(GameObject newGameObject, uint netIdField) Parameters Type Name Description GameObject newGameObject System.UInt32 netIdField Returns Type Description System.Boolean | Improve this Doc View Source SyncVarNetworkIdentityEqual(NetworkIdentity, UInt32) Declaration protected bool SyncVarNetworkIdentityEqual(NetworkIdentity newIdentity, uint netIdField) Parameters Type Name Description NetworkIdentity newIdentity System.UInt32 netIdField Returns Type Description System.Boolean"
  },
  "api/Telepathy.Client.html": {
    "href": "api/Telepathy.Client.html",
    "title": "Class Client",
    "keywords": "Class Client Inheritance System.Object Common Client Inherited Members Common.receiveQueue Common.ReceiveQueueCount Common.messageQueueSizeWarning Common.GetNextMessage(Message) Common.NoDelay Common.MaxMessageSize Common.SendTimeout Common.SendMessagesBlocking(NetworkStream, Byte[][]) Common.ReadMessageBlocking(NetworkStream, Int32, Byte[]) Common.ReceiveLoop(Int32, TcpClient, ConcurrentQueue<Message>, Int32) Common.SendLoop(Int32, TcpClient, SafeQueue<Byte[]>, ManualResetEvent) Namespace : Telepathy Assembly : doc.dll Syntax public class Client : Common Fields | Improve this Doc View Source client Declaration public TcpClient client Field Value Type Description TcpClient Properties | Improve this Doc View Source Connected Declaration public bool Connected { get; } Property Value Type Description System.Boolean | Improve this Doc View Source Connecting Declaration public bool Connecting { get; } Property Value Type Description System.Boolean Methods | Improve this Doc View Source Connect(String, Int32) Declaration public void Connect(string ip, int port) Parameters Type Name Description System.String ip System.Int32 port | Improve this Doc View Source Disconnect() Declaration public void Disconnect() | Improve this Doc View Source Send(Byte[]) Declaration public bool Send(byte[] data) Parameters Type Name Description System.Byte [] data Returns Type Description System.Boolean"
  },
  "api/Mirror.NetworkTransformBase.Compression.html": {
    "href": "api/Mirror.NetworkTransformBase.Compression.html",
    "title": "Enum NetworkTransformBase.Compression",
    "keywords": "Enum NetworkTransformBase.Compression Namespace : Mirror Assembly : doc.dll Syntax public enum Compression : int Fields Name Description Lots Much None NoRotation"
  },
  "api/Mirror.SyncSortedSet-1.html": {
    "href": "api/Mirror.SyncSortedSet-1.html",
    "title": "Class SyncSortedSet<T>",
    "keywords": "Class SyncSortedSet<T> Inheritance System.Object SyncSet <T> SyncSortedSet<T> Implements ISyncObject Inherited Members SyncSet<T>.objects SyncSet<T>.Count SyncSet<T>.IsReadOnly SyncSet<T>.Callback SyncSet<T>.SerializeItem(NetworkWriter, T) SyncSet<T>.DeserializeItem(NetworkReader) SyncSet<T>.IsDirty SyncSet<T>.Flush() SyncSet<T>.OnSerializeAll(NetworkWriter) SyncSet<T>.OnSerializeDelta(NetworkWriter) SyncSet<T>.OnDeserializeAll(NetworkReader) SyncSet<T>.OnDeserializeDelta(NetworkReader) SyncSet<T>.Add(T) SyncSet<T>.Clear() SyncSet<T>.Contains(T) SyncSet<T>.CopyTo(T[], Int32) SyncSet<T>.Remove(T) SyncSet<T>.ExceptWith(IEnumerable<T>) SyncSet<T>.IntersectWith(IEnumerable<T>) SyncSet<T>.IsProperSubsetOf(IEnumerable<T>) SyncSet<T>.IsProperSupersetOf(IEnumerable<T>) SyncSet<T>.IsSubsetOf(IEnumerable<T>) SyncSet<T>.IsSupersetOf(IEnumerable<T>) SyncSet<T>.Overlaps(IEnumerable<T>) SyncSet<T>.SetEquals(IEnumerable<T>) SyncSet<T>.SymmetricExceptWith(IEnumerable<T>) SyncSet<T>.UnionWith(IEnumerable<T>) Namespace : Mirror Assembly : doc.dll Syntax public abstract class SyncSortedSet<T> : SyncSet<T>, ISyncObject Type Parameters Name Description T Constructors | Improve this Doc View Source SyncSortedSet(IComparer<T>) Declaration protected SyncSortedSet(IComparer<T> comparer = null) Parameters Type Name Description IComparer <T> comparer Methods | Improve this Doc View Source GetEnumerator() Declaration public SortedSet<T>.Enumerator GetEnumerator() Returns Type Description SortedSet.Enumerator <> Implements ISyncObject"
  },
  "api/Mirror.SyncEventMessage.html": {
    "href": "api/Mirror.SyncEventMessage.html",
    "title": "Struct SyncEventMessage",
    "keywords": "Struct SyncEventMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct SyncEventMessage : IMessageBase Fields | Improve this Doc View Source componentIndex Declaration public int componentIndex Field Value Type Description System.Int32 | Improve this Doc View Source functionHash Declaration public int functionHash Field Value Type Description System.Int32 | Improve this Doc View Source netId Declaration public uint netId Field Value Type Description System.UInt32 | Improve this Doc View Source payload Declaration public ArraySegment<byte> payload Field Value Type Description ArraySegment < System.Byte > Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.Transport.html": {
    "href": "api/Mirror.Transport.html",
    "title": "Class Transport",
    "keywords": "Class Transport Inheritance System.Object Transport FallbackTransport LLAPITransport MultiplexTransport TcpTransport TelepathyTransport WebsocketTransport Namespace : Mirror Assembly : doc.dll Syntax public abstract class Transport : MonoBehaviour Fields | Improve this Doc View Source activeTransport The current transport used by Mirror. Declaration public static Transport activeTransport Field Value Type Description Transport | Improve this Doc View Source OnClientConnected Notify subscribers when when this client establish a successful connection to the server Declaration public UnityEvent OnClientConnected Field Value Type Description UnityEvent | Improve this Doc View Source OnClientDataReceived Notify subscribers when this client receive data from the server Declaration public ClientDataReceivedEvent OnClientDataReceived Field Value Type Description ClientDataReceivedEvent | Improve this Doc View Source OnClientDisconnected Notify subscribers when this client disconnects from the server Declaration public UnityEvent OnClientDisconnected Field Value Type Description UnityEvent | Improve this Doc View Source OnClientError Notify subscribers when this clianet encounters an error communicating with the server Declaration public UnityEventException OnClientError Field Value Type Description UnityEventException | Improve this Doc View Source OnServerConnected Notify subscribers when a client connects to this server Declaration public UnityEventInt OnServerConnected Field Value Type Description UnityEventInt | Improve this Doc View Source OnServerDataReceived Notify subscribers when this server receives data from the client Declaration public ServerDataReceivedEvent OnServerDataReceived Field Value Type Description ServerDataReceivedEvent | Improve this Doc View Source OnServerDisconnected Notify subscribers when a client disconnects from this server Declaration public UnityEventInt OnServerDisconnected Field Value Type Description UnityEventInt | Improve this Doc View Source OnServerError Notify subscribers when this server has some problem communicating with the client Declaration public UnityEventIntException OnServerError Field Value Type Description UnityEventIntException Methods | Improve this Doc View Source Available() Is this transport available in the current platform? Some transports might only be available in mobile Many will not work in webgl Example usage: return Application.platform == RuntimePlatform.WebGLPlayer Declaration public abstract bool Available() Returns Type Description System.Boolean True if this transport works in the current platform | Improve this Doc View Source ClientConnect(String) Establish a connection to a server Declaration public abstract void ClientConnect(string address) Parameters Type Name Description System.String address The IP address or FQDN of the server we are trying to connect to | Improve this Doc View Source ClientConnect(Uri) Establish a connection to a server Declaration public virtual void ClientConnect(Uri uri) Parameters Type Name Description Uri uri The address of the server we are trying to connect to | Improve this Doc View Source ClientConnected() Determines if we are currently connected to the server Declaration public abstract bool ClientConnected() Returns Type Description System.Boolean True if a connection has been established to the server | Improve this Doc View Source ClientDisconnect() Disconnect this client from the server Declaration public abstract void ClientDisconnect() | Improve this Doc View Source ClientSend(Int32, ArraySegment<Byte>) Send data to the server Declaration public abstract bool ClientSend(int channelId, ArraySegment<byte> segment) Parameters Type Name Description System.Int32 channelId The channel to use. 0 is the default channel, but some transports might want to provide unreliable, encrypted, compressed, or any other feature as new channels ArraySegment < System.Byte > segment The data to send to the server. Will be recycled after returning, so either use it directly or copy it internally. This allows for allocation-free sends! Returns Type Description System.Boolean true if the send was successful | Improve this Doc View Source GetMaxPacketSize(Int32) The maximum packet size for a given channel. Unreliable transports usually can only deliver small packets. Reliable fragmented channels can usually deliver large ones. GetMaxPacketSize needs to return a value at all times. Even if the Transport isn't running, or isn't Available(). This is because Fallback and Multiplex transports need to find the smallest possible packet size at runtime. Declaration public abstract int GetMaxPacketSize(int channelId = null) Parameters Type Name Description System.Int32 channelId channel id Returns Type Description System.Int32 the size in bytes that can be sent via the provided channel | Improve this Doc View Source OnApplicationQuit() called when quitting the application by closing the window / pressing stop in the editor virtual so that inheriting classes' OnApplicationQuit() can call base.OnApplicationQuit() too Declaration public virtual void OnApplicationQuit() | Improve this Doc View Source ServerActive() Determines if the server is up and running Declaration public abstract bool ServerActive() Returns Type Description System.Boolean true if the transport is ready for connections from clients | Improve this Doc View Source ServerDisconnect(Int32) Disconnect a client from this server. Useful to kick people out. Declaration public abstract bool ServerDisconnect(int connectionId) Parameters Type Name Description System.Int32 connectionId the id of the client to disconnect Returns Type Description System.Boolean true if the client was kicked | Improve this Doc View Source ServerGetClientAddress(Int32) Get the client address Declaration public abstract string ServerGetClientAddress(int connectionId) Parameters Type Name Description System.Int32 connectionId id of the client Returns Type Description System.String address of the client | Improve this Doc View Source ServerSend(List<Int32>, Int32, ArraySegment<Byte>) Send data to one or multiple clients. We provide a list, so that transports can make use of multicasting, and avoid allocations where possible. We don't provide a single ServerSend function to reduce complexity. Simply overwrite this one in your Transport. Declaration public abstract bool ServerSend(List<int> connectionIds, int channelId, ArraySegment<byte> segment) Parameters Type Name Description List < System.Int32 > connectionIds The list of client connection ids to send the data to System.Int32 channelId The channel to be used. Transports can use channels to implement other features such as unreliable, encryption, compression, etc... ArraySegment < System.Byte > segment Returns Type Description System.Boolean true if the data was sent to all clients | Improve this Doc View Source ServerStart() Start listening for clients Declaration public abstract void ServerStart() | Improve this Doc View Source ServerStop() Stop listening for clients and disconnect all existing clients Declaration public abstract void ServerStop() | Improve this Doc View Source Shutdown() Shut down the transport, both as client and server Declaration public abstract void Shutdown() | Improve this Doc View Source Update() Declaration public void Update()"
  },
  "api/Mirror.ClientScene.html": {
    "href": "api/Mirror.ClientScene.html",
    "title": "Class ClientScene",
    "keywords": "Class ClientScene A client manager which contains static client information and functions. This manager contains references to tracked static local objects such as spawner registrations. It also has the default message handlers used by clients when they registered none themselves. The manager handles adding/removing player objects to the game after a client connection has been set as ready. The ClientScene is a singleton, and it has static convenience methods such as ClientScene.Ready(). The ClientScene is used by the NetworkManager, but it can be used by itself. As the ClientScene manages player objects on the client, it is where clients request to add players. The NetworkManager does this via the ClientScene automatically when auto-add-players is set, but it can be done through code using the function ClientScene.AddPlayer(). This sends an AddPlayer message to the server and will cause a player object to be created for this client. Like NetworkServer, the ClientScene understands the concept of the local client. The function ClientScene.ConnectLocalServer() is used to become a host by starting a local client (when a server is already running). Inheritance System.Object ClientScene Namespace : Mirror Assembly : doc.dll Syntax public static class ClientScene : object Fields | Improve this Doc View Source prefabs This is a dictionary of the prefabs that are registered on the client with ClientScene.RegisterPrefab(). The key to the dictionary is the prefab asset Id. Declaration public static Dictionary<System.Guid, GameObject> prefabs Field Value Type Description Dictionary < System.Guid , GameObject > | Improve this Doc View Source spawnableObjects This is dictionary of the disabled NetworkIdentity objects in the scene that could be spawned by messages from the server. The key to the dictionary is the NetworkIdentity sceneId. Declaration public static Dictionary<ulong, NetworkIdentity> spawnableObjects Field Value Type Description Dictionary < System.UInt64 , NetworkIdentity > Properties | Improve this Doc View Source localPlayer NetworkIdentity of the localPlayer Declaration public static NetworkIdentity localPlayer { get; } Property Value Type Description NetworkIdentity | Improve this Doc View Source ready Returns true when a client's connection has been set to ready. A client that is ready recieves state updates from the server, while a client that is not ready does not. This useful when the state of the game is not normal, such as a scene change or end-of-game. This is read-only. To change the ready state of a client, use ClientScene.Ready(). The server is able to set the ready state of clients using NetworkServer.SetClientReady(), NetworkServer.SetClientNotReady() and NetworkServer.SetAllClientsNotReady(). This is done when changing scenes so that clients don't receive state update messages during scene loading. Declaration public static bool ready { get; } Property Value Type Description System.Boolean | Improve this Doc View Source readyConnection The NetworkConnection object that is currently \"ready\". This is the connection to the server where objects are spawned from. This connection can be used to send messages to the server. There can only be one ready connection at a time. There can be multiple NetworkClient instances in existence, each with their own NetworkConnections, but there is only one ClientScene instance and corresponding ready connection. Declaration public static NetworkConnection readyConnection { get; } Property Value Type Description NetworkConnection Methods | Improve this Doc View Source AddPlayer() This adds a player GameObject for this client. This causes an AddPlayer message to be sent to the server, and NetworkManager.OnServerAddPlayer is called. Declaration public static bool AddPlayer() Returns Type Description System.Boolean True if player was added. | Improve this Doc View Source AddPlayer(NetworkConnection) This adds a player GameObject for this client. This causes an AddPlayer message to be sent to the server, and NetworkManager.OnServerAddPlayer is called. If an extra message was passed to AddPlayer, then OnServerAddPlayer will be called with a NetworkReader that contains the contents of the message. extraMessage can contain character selection, etc. Declaration public static bool AddPlayer(NetworkConnection readyConn) Parameters Type Name Description NetworkConnection readyConn The connection to become ready for this client. Returns Type Description System.Boolean True if player was added. | Improve this Doc View Source ClearSpawners() This clears the registered spawn prefabs and spawn handler functions for this client. Declaration public static void ClearSpawners() | Improve this Doc View Source DestroyAllClientObjects() Destroys all networked objects on the client. This can be used to clean up when a network connection is closed. Declaration public static void DestroyAllClientObjects() | Improve this Doc View Source GetPrefab(System.Guid, out GameObject) Find the registered prefab for this asset id. Useful for debuggers Declaration public static bool GetPrefab(System.Guid assetId, out GameObject prefab) Parameters Type Name Description System.Guid assetId asset id of the prefab GameObject prefab the prefab gameobject Returns Type Description System.Boolean true if prefab was registered | Improve this Doc View Source PrepareToSpawnSceneObjects() Call this after loading/unloading a scene in the client after connection to register the spawnable objects Declaration public static void PrepareToSpawnSceneObjects() | Improve this Doc View Source Ready(NetworkConnection) Signal that the client connection is ready to enter the game. This could be for example when a client enters an ongoing game and has finished loading the current scene. The server should respond to the SYSTEM_READY event with an appropriate handler which instantiates the players object for example. Declaration public static bool Ready(NetworkConnection conn) Parameters Type Name Description NetworkConnection conn The client connection which is ready. Returns Type Description System.Boolean True if succcessful | Improve this Doc View Source RegisterPrefab(GameObject) Registers a prefab with the spawning system. When a NetworkIdentity object is spawned on a server with NetworkServer.SpawnObject(), and the prefab that the object was created from was registered with RegisterPrefab(), the client will use that prefab to instantiate a corresponding client object with the same netId. The NetworkManager has a list of spawnable prefabs, it uses this function to register those prefabs with the ClientScene. The set of current spawnable object is available in the ClientScene static member variable ClientScene.prefabs, which is a dictionary of NetworkAssetIds and prefab references. Declaration public static void RegisterPrefab(GameObject prefab) Parameters Type Name Description GameObject prefab A Prefab that will be spawned. | Improve this Doc View Source RegisterPrefab(GameObject, SpawnDelegate, UnSpawnDelegate) Registers a prefab with the spawning system. When a NetworkIdentity object is spawned on a server with NetworkServer.SpawnObject(), and the prefab that the object was created from was registered with RegisterPrefab(), the client will use that prefab to instantiate a corresponding client object with the same netId. The NetworkManager has a list of spawnable prefabs, it uses this function to register those prefabs with the ClientScene. The set of current spawnable object is available in the ClientScene static member variable ClientScene.prefabs, which is a dictionary of NetworkAssetIds and prefab references. Declaration public static void RegisterPrefab(GameObject prefab, SpawnDelegate spawnHandler, UnSpawnDelegate unspawnHandler) Parameters Type Name Description GameObject prefab A Prefab that will be spawned. SpawnDelegate spawnHandler A method to use as a custom spawnhandler on clients. UnSpawnDelegate unspawnHandler A method to use as a custom un-spawnhandler on clients. | Improve this Doc View Source RegisterPrefab(GameObject, SpawnHandlerDelegate, UnSpawnDelegate) Registers a prefab with the spawning system. When a NetworkIdentity object is spawned on a server with NetworkServer.SpawnObject(), and the prefab that the object was created from was registered with RegisterPrefab(), the client will use that prefab to instantiate a corresponding client object with the same netId. The NetworkManager has a list of spawnable prefabs, it uses this function to register those prefabs with the ClientScene. The set of current spawnable object is available in the ClientScene static member variable ClientScene.prefabs, which is a dictionary of NetworkAssetIds and prefab references. Declaration public static void RegisterPrefab(GameObject prefab, SpawnHandlerDelegate spawnHandler, UnSpawnDelegate unspawnHandler) Parameters Type Name Description GameObject prefab A Prefab that will be spawned. SpawnHandlerDelegate spawnHandler A method to use as a custom spawnhandler on clients. UnSpawnDelegate unspawnHandler A method to use as a custom un-spawnhandler on clients. | Improve this Doc View Source RegisterPrefab(GameObject, System.Guid) Registers a prefab with the spawning system. When a NetworkIdentity object is spawned on a server with NetworkServer.SpawnObject(), and the prefab that the object was created from was registered with RegisterPrefab(), the client will use that prefab to instantiate a corresponding client object with the same netId. The NetworkManager has a list of spawnable prefabs, it uses this function to register those prefabs with the ClientScene. The set of current spawnable object is available in the ClientScene static member variable ClientScene.prefabs, which is a dictionary of NetworkAssetIds and prefab references. Declaration public static void RegisterPrefab(GameObject prefab, System.Guid newAssetId) Parameters Type Name Description GameObject prefab A Prefab that will be spawned. System.Guid newAssetId An assetId to be assigned to this prefab. This allows a dynamically created game object to be registered for an already known asset Id. | Improve this Doc View Source RegisterSpawnHandler(System.Guid, SpawnDelegate, UnSpawnDelegate) This is an advanced spawning function that registers a custom assetId with the UNET spawning system. This can be used to register custom spawning methods for an assetId - instead of the usual method of registering spawning methods for a prefab. This should be used when no prefab exists for the spawned objects - such as when they are constructed dynamically at runtime from configuration data. Declaration public static void RegisterSpawnHandler(System.Guid assetId, SpawnDelegate spawnHandler, UnSpawnDelegate unspawnHandler) Parameters Type Name Description System.Guid assetId Custom assetId string. SpawnDelegate spawnHandler A method to use as a custom spawnhandler on clients. UnSpawnDelegate unspawnHandler A method to use as a custom un-spawnhandler on clients. | Improve this Doc View Source RegisterSpawnHandler(System.Guid, SpawnHandlerDelegate, UnSpawnDelegate) This is an advanced spawning function that registers a custom assetId with the UNET spawning system. This can be used to register custom spawning methods for an assetId - instead of the usual method of registering spawning methods for a prefab. This should be used when no prefab exists for the spawned objects - such as when they are constructed dynamically at runtime from configuration data. Declaration public static void RegisterSpawnHandler(System.Guid assetId, SpawnHandlerDelegate spawnHandler, UnSpawnDelegate unspawnHandler) Parameters Type Name Description System.Guid assetId Custom assetId string. SpawnHandlerDelegate spawnHandler A method to use as a custom spawnhandler on clients. UnSpawnDelegate unspawnHandler A method to use as a custom un-spawnhandler on clients. | Improve this Doc View Source RemovePlayer() Removes the player from the game. Declaration public static bool RemovePlayer() Returns Type Description System.Boolean True if succcessful | Improve this Doc View Source UnregisterPrefab(GameObject) Removes a registered spawn prefab that was setup with ClientScene.RegisterPrefab. Declaration public static void UnregisterPrefab(GameObject prefab) Parameters Type Name Description GameObject prefab The prefab to be removed from registration. | Improve this Doc View Source UnregisterSpawnHandler(System.Guid) Removes a registered spawn handler function that was registered with ClientScene.RegisterHandler(). Declaration public static void UnregisterSpawnHandler(System.Guid assetId) Parameters Type Name Description System.Guid assetId The assetId for the handler to be removed for."
  },
  "api/Telepathy.NetworkStreamExtensions.html": {
    "href": "api/Telepathy.NetworkStreamExtensions.html",
    "title": "Class NetworkStreamExtensions",
    "keywords": "Class NetworkStreamExtensions Inheritance System.Object NetworkStreamExtensions Namespace : Telepathy Assembly : doc.dll Syntax public static class NetworkStreamExtensions : object Methods | Improve this Doc View Source ReadExactly(NetworkStream, Byte[], Int32) Declaration public static bool ReadExactly(this NetworkStream stream, byte[] buffer, int amount) Parameters Type Name Description NetworkStream stream System.Byte [] buffer System.Int32 amount Returns Type Description System.Boolean | Improve this Doc View Source ReadSafely(NetworkStream, Byte[], Int32, Int32) Declaration public static int ReadSafely(this NetworkStream stream, byte[] buffer, int offset, int size) Parameters Type Name Description NetworkStream stream System.Byte [] buffer System.Int32 offset System.Int32 size Returns Type Description System.Int32"
  },
  "api/Mirror.html": {
    "href": "api/Mirror.html",
    "title": "Namespace Mirror",
    "keywords": "Namespace Mirror Classes Channels ClientAttribute Prevents the server from running this method. Prints a warning if the server tries to execute this method. ClientCallbackAttribute Prevents the server from running this method. No warning is printed. ClientDataReceivedEvent ClientRpcAttribute The server uses a Remote Procedure Call (RPC) to run this function on clients. ClientScene A client manager which contains static client information and functions. This manager contains references to tracked static local objects such as spawner registrations. It also has the default message handlers used by clients when they registered none themselves. The manager handles adding/removing player objects to the game after a client connection has been set as ready. The ClientScene is a singleton, and it has static convenience methods such as ClientScene.Ready(). The ClientScene is used by the NetworkManager, but it can be used by itself. As the ClientScene manages player objects on the client, it is where clients request to add players. The NetworkManager does this via the ClientScene automatically when auto-add-players is set, but it can be done through code using the function ClientScene.AddPlayer(). This sends an AddPlayer message to the server and will cause a player object to be created for this client. Like NetworkServer, the ClientScene understands the concept of the local client. The function ClientScene.ConnectLocalServer() is used to become a host by starting a local client (when a server is already running). CommandAttribute Call this from a client to run this function on the server. Make sure to validate input etc. It's not possible to call this from a server. ExponentialMovingAverage FallbackTransport FloatBytePacker LLAPITransport LogFilter MessageBase MessagePacker MultiplexTransport NetworkAnimator A component to synchronize Mecanim animation states for networked objects. NetworkAuthenticator Base class for implementing component-based authentication during the Connect phase NetworkBehaviour Base class which should be inherited by scripts which contain networking functionality. NetworkBehaviour.Invoker NetworkClient This is a network client class used by the networking system. It contains a NetworkConnection that is used to connect to a network server. The NetworkClient handle connection state, messages handlers, and connection configuration. There can be many NetworkClient instances in a process at a time, but only one that is connected to a game server ( NetworkServer ) that uses spawned objects. NetworkClient has an internal update function where it handles events from the transport layer. This includes asynchronous connect events, disconnect events and incoming data from a server. The NetworkManager has a NetworkClient instance that it uses for games that it starts, but the NetworkClient may be used by itself. NetworkConnection A High level network connection. This is used for connections from client-to-server and for connection from server-to-client. NetworkConnectionToClient NetworkConnectionToServer NetworkDiagnostics Provides profiling information from mirror A profiler can subscribe to these events and present the data in a friendly way to the user NetworkIdentity The NetworkIdentity identifies objects across the network, between server and clients. Its primary data is a NetworkInstanceId which is allocated by the server and then set on clients. This is used in network communications to be able to lookup game objects on different machines. NetworkManager NetworkManagerHUD An extension for the NetworkManager that displays a default HUD for controlling the network state of the game. This component also shows useful internal state for the networking system in the inspector window of the editor. It allows users to view connections, networked objects, message handlers, and packet statistics. This information can be helpful when debugging networked games. NetworkProximityChecker Component that controls visibility of networked objects for players. Any object with this component on it will not be visible to players more than a (configurable) distance away. NetworkReader NetworkReaderExtensions NetworkRoomManager This is a specialized NetworkManager that includes a networked room. NetworkRoomPlayer This component works in conjunction with the NetworkRoomManager to make up the multiplayer room system. The RoomPrefab object of the NetworkRoomManager must have this component on it. This component holds basic room player data required for the room to function. Game specific data for room players can be put in other components on the RoomPrefab or in scripts derived from NetworkRoomPlayer. NetworkServer The NetworkServer. NetworkStartPosition This component is used to make a gameObject a starting position for spawning player objects in multiplayer games. This object's transform will be automatically registered and unregistered with the NetworkManager as a starting position. NetworkTime Synchronize time between the server and the clients NetworkTransform NetworkTransformBase NetworkTransformBase.DataPoint NetworkTransformChild A component to synchronize the position of child transforms of networked objects. There must be a NetworkTransform on the root object of the hierarchy. There can be multiple NetworkTransformChild components on an object. This does not use physics for synchronization, it simply synchronizes the localPosition and localRotation of the child transform and lerps towards the recieved values. NetworkWriter NetworkWriterExtensions NetworkWriterPool SceneAttribute Converts a string property into a Scene property in the inspector ServerAttribute Prevents clients from running this method. Prints a warning if a client tries to execute this method. ServerCallbackAttribute Prevents clients from running this method. No warning is thrown. ServerDataReceivedEvent StringHash SyncDictionary<TKey, TValue> SyncEventAttribute SyncEvents are networked events like ClientRpc's, but instead of calling a function on the game object, they trigger Events instead. SyncHashSet<T> SyncIDictionary<TKey, TValue> SyncList<T> SyncListBool SyncListFloat SyncListInt SyncListString SyncListUInt SyncSet<T> SyncSortedSet<T> SyncVarAttribute SyncVars are used to synchronize a variable from the server to all clients automatically. Value must be changed on server, not directly by clients. Hook parameter allows you to define a client-side method to be invoked when the client gets an update from the server. TargetRpcAttribute The server uses a Remote Procedure Call (RPC) to run this function on a specific client. TelepathyTransport Transport UnityEventException UnityEventInt UnityEventIntException Structs AddPlayerMessage CommandMessage ConnectMessage DisconnectMessage ErrorMessage NetworkDiagnostics.MessageInfo Describes an outgoing message NetworkPingMessage NetworkPongMessage NetworkRoomManager.PendingPlayer NotReadyMessage ObjectDestroyMessage ObjectHideMessage ObjectSpawnFinishedMessage ObjectSpawnStartedMessage ReadyMessage RemovePlayerMessage RpcMessage SceneMessage SpawnMessage SyncEventMessage SyncList<T>.Enumerator UpdateVarsMessage Interfaces IMessageBase ISyncObject Enums ConnectState MirrorInvokeType NetworkManagerMode NetworkProximityChecker.CheckMethod Enumeration of methods to use to check proximity. NetworkTransformBase.Compression PlayerSpawnMethod Enumeration of methods of where to spawn player objects in multiplayer games. SceneOperation SyncIDictionary<TKey, TValue>.Operation SyncList<T>.Operation SyncMode Sync to everyone, or only to owner. SyncSet<T>.Operation Version Delegates NetworkBehaviour.CmdDelegate Delegate for Command functions. NetworkIdentity.ClientAuthorityCallback The delegate type for the clientAuthorityCallback. SpawnDelegate SpawnHandlerDelegate SyncIDictionary<TKey, TValue>.SyncDictionaryChanged SyncList<T>.SyncListChanged SyncSet<T>.SyncSetChanged UnSpawnDelegate"
  },
  "api/Mirror.Websocket.WebsocketTransport.html": {
    "href": "api/Mirror.Websocket.WebsocketTransport.html",
    "title": "Class WebsocketTransport",
    "keywords": "Class WebsocketTransport Inheritance System.Object Transport WebsocketTransport Inherited Members Transport.activeTransport Transport.OnClientConnected Transport.OnClientDataReceived Transport.OnClientError Transport.OnClientDisconnected Transport.OnServerConnected Transport.OnServerDataReceived Transport.OnServerError Transport.OnServerDisconnected Transport.Update() Transport.OnApplicationQuit() Namespace : Mirror.Websocket Assembly : doc.dll Syntax public class WebsocketTransport : Transport Constructors | Improve this Doc View Source WebsocketTransport() Declaration public WebsocketTransport() Fields | Improve this Doc View Source CertificatePassword Declaration public string CertificatePassword Field Value Type Description System.String | Improve this Doc View Source CertificatePath Declaration public string CertificatePath Field Value Type Description System.String | Improve this Doc View Source client Declaration protected Client client Field Value Type Description Client | Improve this Doc View Source NoDelay Declaration public bool NoDelay Field Value Type Description System.Boolean | Improve this Doc View Source port Declaration public int port Field Value Type Description System.Int32 | Improve this Doc View Source Scheme Declaration public const string Scheme = null Field Value Type Description System.String | Improve this Doc View Source Secure Declaration public bool Secure Field Value Type Description System.Boolean | Improve this Doc View Source SecureScheme Declaration public const string SecureScheme = null Field Value Type Description System.String | Improve this Doc View Source server Declaration protected Server server Field Value Type Description Server Methods | Improve this Doc View Source Available() Declaration public override bool Available() Returns Type Description System.Boolean Overrides Transport.Available() | Improve this Doc View Source ClientConnect(String) Declaration public override void ClientConnect(string host) Parameters Type Name Description System.String host Overrides Transport.ClientConnect(String) | Improve this Doc View Source ClientConnect(Uri) Declaration public override void ClientConnect(Uri uri) Parameters Type Name Description Uri uri Overrides Transport.ClientConnect(Uri) | Improve this Doc View Source ClientConnected() Declaration public override bool ClientConnected() Returns Type Description System.Boolean Overrides Transport.ClientConnected() | Improve this Doc View Source ClientDisconnect() Declaration public override void ClientDisconnect() Overrides Transport.ClientDisconnect() | Improve this Doc View Source ClientSend(Int32, ArraySegment<Byte>) Declaration public override bool ClientSend(int channelId, ArraySegment<byte> segment) Parameters Type Name Description System.Int32 channelId ArraySegment < System.Byte > segment Returns Type Description System.Boolean Overrides Transport.ClientSend(Int32, ArraySegment<Byte>) | Improve this Doc View Source GetMaxPacketSize(Int32) Declaration public override int GetMaxPacketSize(int channelId) Parameters Type Name Description System.Int32 channelId Returns Type Description System.Int32 Overrides Transport.GetMaxPacketSize(Int32) | Improve this Doc View Source ServerActive() Declaration public override bool ServerActive() Returns Type Description System.Boolean Overrides Transport.ServerActive() | Improve this Doc View Source ServerDisconnect(Int32) Declaration public override bool ServerDisconnect(int connectionId) Parameters Type Name Description System.Int32 connectionId Returns Type Description System.Boolean Overrides Transport.ServerDisconnect(Int32) | Improve this Doc View Source ServerGetClientAddress(Int32) Declaration public override string ServerGetClientAddress(int connectionId) Parameters Type Name Description System.Int32 connectionId Returns Type Description System.String Overrides Transport.ServerGetClientAddress(Int32) | Improve this Doc View Source ServerSend(List<Int32>, Int32, ArraySegment<Byte>) Declaration public override bool ServerSend(List<int> connectionIds, int channelId, ArraySegment<byte> segment) Parameters Type Name Description List < System.Int32 > connectionIds System.Int32 channelId ArraySegment < System.Byte > segment Returns Type Description System.Boolean Overrides Transport.ServerSend(List<Int32>, Int32, ArraySegment<Byte>) | Improve this Doc View Source ServerStart() Declaration public override void ServerStart() Overrides Transport.ServerStart() | Improve this Doc View Source ServerStop() Declaration public override void ServerStop() Overrides Transport.ServerStop() | Improve this Doc View Source Shutdown() Declaration public override void Shutdown() Overrides Transport.Shutdown() | Improve this Doc View Source ToString() Declaration public override string ToString() Returns Type Description System.String"
  },
  "api/Mirror.SpawnMessage.html": {
    "href": "api/Mirror.SpawnMessage.html",
    "title": "Struct SpawnMessage",
    "keywords": "Struct SpawnMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct SpawnMessage : IMessageBase Fields | Improve this Doc View Source assetId Declaration public Guid assetId Field Value Type Description Guid | Improve this Doc View Source isLocalPlayer Declaration public bool isLocalPlayer Field Value Type Description System.Boolean | Improve this Doc View Source isOwner Declaration public bool isOwner Field Value Type Description System.Boolean | Improve this Doc View Source netId Declaration public uint netId Field Value Type Description System.UInt32 | Improve this Doc View Source payload Declaration public ArraySegment<byte> payload Field Value Type Description ArraySegment < System.Byte > | Improve this Doc View Source position Declaration public Vector3 position Field Value Type Description Vector3 | Improve this Doc View Source rotation Declaration public Quaternion rotation Field Value Type Description Quaternion | Improve this Doc View Source scale Declaration public Vector3 scale Field Value Type Description Vector3 | Improve this Doc View Source sceneId Declaration public ulong sceneId Field Value Type Description System.UInt64 Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.Tcp.NetworkStreamExtensions.html": {
    "href": "api/Mirror.Tcp.NetworkStreamExtensions.html",
    "title": "Class NetworkStreamExtensions",
    "keywords": "Class NetworkStreamExtensions Inheritance System.Object NetworkStreamExtensions Namespace : Mirror.Tcp Assembly : doc.dll Syntax public static class NetworkStreamExtensions : object Methods | Improve this Doc View Source ReadExactlyAsync(Stream, Int32) Declaration public static Task<byte[]> ReadExactlyAsync(this Stream stream, int size) Parameters Type Name Description Stream stream System.Int32 size Returns Type Description Task < System.Byte []> | Improve this Doc View Source WriteInt(Stream, Int32) Declaration public static void WriteInt(this Stream stream, int length) Parameters Type Name Description Stream stream System.Int32 length | Improve this Doc View Source WritePrefixedData(Stream, ArraySegment<Byte>) Declaration public static void WritePrefixedData(this Stream stream, ArraySegment<byte> data) Parameters Type Name Description Stream stream ArraySegment < System.Byte > data"
  },
  "api/Mirror.SyncSet-1.SyncSetChanged.html": {
    "href": "api/Mirror.SyncSet-1.SyncSetChanged.html",
    "title": "Delegate SyncSet<T>.SyncSetChanged",
    "keywords": "Delegate SyncSet<T>.SyncSetChanged Namespace : Mirror Assembly : doc.dll Syntax public delegate void SyncSetChanged(SyncSet<T>.Operation op, T item); Parameters Type Name Description SyncSet.Operation <> op T item"
  },
  "api/Mirror.SyncList-1.SyncListChanged.html": {
    "href": "api/Mirror.SyncList-1.SyncListChanged.html",
    "title": "Delegate SyncList<T>.SyncListChanged",
    "keywords": "Delegate SyncList<T>.SyncListChanged Namespace : Mirror Assembly : doc.dll Syntax public delegate void SyncListChanged(SyncList<T>.Operation op, int itemIndex, T oldItem, T newItem); Parameters Type Name Description SyncList.Operation <> op System.Int32 itemIndex T oldItem T newItem"
  },
  "api/Mirror.NetworkManagerHUD.html": {
    "href": "api/Mirror.NetworkManagerHUD.html",
    "title": "Class NetworkManagerHUD",
    "keywords": "Class NetworkManagerHUD An extension for the NetworkManager that displays a default HUD for controlling the network state of the game. This component also shows useful internal state for the networking system in the inspector window of the editor. It allows users to view connections, networked objects, message handlers, and packet statistics. This information can be helpful when debugging networked games. Inheritance System.Object NetworkManagerHUD Namespace : Mirror Assembly : doc.dll Syntax public class NetworkManagerHUD : MonoBehaviour Fields | Improve this Doc View Source offsetX The horizontal offset in pixels to draw the HUD runtime GUI at. Declaration public int offsetX Field Value Type Description System.Int32 | Improve this Doc View Source offsetY The vertical offset in pixels to draw the HUD runtime GUI at. Declaration public int offsetY Field Value Type Description System.Int32 | Improve this Doc View Source showGUI Whether to show the default control HUD at runtime. Declaration public bool showGUI Field Value Type Description System.Boolean"
  },
  "api/Mirror.ConnectState.html": {
    "href": "api/Mirror.ConnectState.html",
    "title": "Enum ConnectState",
    "keywords": "Enum ConnectState Namespace : Mirror Assembly : doc.dll Syntax public enum ConnectState : int Fields Name Description Connected Connecting Disconnected None"
  },
  "api/Mirror.SceneOperation.html": {
    "href": "api/Mirror.SceneOperation.html",
    "title": "Enum SceneOperation",
    "keywords": "Enum SceneOperation Namespace : Mirror Assembly : doc.dll Syntax public enum SceneOperation : byte Fields Name Description LoadAdditive Normal UnloadAdditive"
  },
  "api/Telepathy.Utils.html": {
    "href": "api/Telepathy.Utils.html",
    "title": "Class Utils",
    "keywords": "Class Utils Inheritance System.Object Utils Namespace : Telepathy Assembly : doc.dll Syntax public static class Utils : object Methods | Improve this Doc View Source BytesToIntBigEndian(Byte[]) Declaration public static int BytesToIntBigEndian(byte[] bytes) Parameters Type Name Description System.Byte [] bytes Returns Type Description System.Int32 | Improve this Doc View Source IntToBytesBigEndian(Int32) Declaration public static byte[] IntToBytesBigEndian(int value) Parameters Type Name Description System.Int32 value Returns Type Description System.Byte [] | Improve this Doc View Source IntToBytesBigEndianNonAlloc(Int32, Byte[]) Declaration public static void IntToBytesBigEndianNonAlloc(int value, byte[] bytes) Parameters Type Name Description System.Int32 value System.Byte [] bytes"
  },
  "api/Mirror.NetworkWriterPool.html": {
    "href": "api/Mirror.NetworkWriterPool.html",
    "title": "Class NetworkWriterPool",
    "keywords": "Class NetworkWriterPool Inheritance System.Object NetworkWriterPool Namespace : Mirror Assembly : doc.dll Syntax public static class NetworkWriterPool : object Methods | Improve this Doc View Source GetWriter() Declaration public static NetworkWriter GetWriter() Returns Type Description NetworkWriter | Improve this Doc View Source Recycle(NetworkWriter) Declaration public static void Recycle(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer"
  },
  "api/Mirror.NetworkReader.html": {
    "href": "api/Mirror.NetworkReader.html",
    "title": "Class NetworkReader",
    "keywords": "Class NetworkReader Inheritance System.Object NetworkReader Namespace : Mirror Assembly : doc.dll Syntax public class NetworkReader : object Constructors | Improve this Doc View Source NetworkReader(ArraySegment<Byte>) Declaration public NetworkReader(ArraySegment<byte> segment) Parameters Type Name Description ArraySegment < System.Byte > segment | Improve this Doc View Source NetworkReader(Byte[]) Declaration public NetworkReader(byte[] bytes) Parameters Type Name Description System.Byte [] bytes Fields | Improve this Doc View Source Position Declaration public int Position Field Value Type Description System.Int32 Properties | Improve this Doc View Source Length Declaration public int Length { get; } Property Value Type Description System.Int32 Methods | Improve this Doc View Source ReadByte() Declaration public byte ReadByte() Returns Type Description System.Byte | Improve this Doc View Source ReadBytes(Byte[], Int32) Declaration public byte[] ReadBytes(byte[] bytes, int count) Parameters Type Name Description System.Byte [] bytes System.Int32 count Returns Type Description System.Byte [] | Improve this Doc View Source ReadBytesSegment(Int32) Declaration public ArraySegment<byte> ReadBytesSegment(int count) Parameters Type Name Description System.Int32 count Returns Type Description ArraySegment < System.Byte > | Improve this Doc View Source ReadInt32() Declaration public int ReadInt32() Returns Type Description System.Int32 | Improve this Doc View Source ReadInt64() Declaration public long ReadInt64() Returns Type Description System.Int64 | Improve this Doc View Source ReadUInt32() Declaration public uint ReadUInt32() Returns Type Description System.UInt32 | Improve this Doc View Source ReadUInt64() Declaration public ulong ReadUInt64() Returns Type Description System.UInt64 | Improve this Doc View Source ToString() Declaration public override string ToString() Returns Type Description System.String Extension Methods NetworkReaderExtensions.ReadByte(NetworkReader) NetworkReaderExtensions.ReadSByte(NetworkReader) NetworkReaderExtensions.ReadChar(NetworkReader) NetworkReaderExtensions.ReadBoolean(NetworkReader) NetworkReaderExtensions.ReadInt16(NetworkReader) NetworkReaderExtensions.ReadUInt16(NetworkReader) NetworkReaderExtensions.ReadInt32(NetworkReader) NetworkReaderExtensions.ReadUInt32(NetworkReader) NetworkReaderExtensions.ReadInt64(NetworkReader) NetworkReaderExtensions.ReadUInt64(NetworkReader) NetworkReaderExtensions.ReadSingle(NetworkReader) NetworkReaderExtensions.ReadDouble(NetworkReader) NetworkReaderExtensions.ReadDecimal(NetworkReader) NetworkReaderExtensions.ReadString(NetworkReader) NetworkReaderExtensions.ReadBytesAndSize(NetworkReader) NetworkReaderExtensions.ReadBytesAndSizeSegment(NetworkReader) NetworkReaderExtensions.ReadPackedInt32(NetworkReader) NetworkReaderExtensions.ReadPackedUInt32(NetworkReader) NetworkReaderExtensions.ReadPackedInt64(NetworkReader) NetworkReaderExtensions.ReadPackedUInt64(NetworkReader) NetworkReaderExtensions.ReadVector2(NetworkReader) NetworkReaderExtensions.ReadVector3(NetworkReader) NetworkReaderExtensions.ReadVector4(NetworkReader) NetworkReaderExtensions.ReadVector2Int(NetworkReader) NetworkReaderExtensions.ReadVector3Int(NetworkReader) NetworkReaderExtensions.ReadColor(NetworkReader) NetworkReaderExtensions.ReadColor32(NetworkReader) NetworkReaderExtensions.ReadQuaternion(NetworkReader) NetworkReaderExtensions.ReadRect(NetworkReader) NetworkReaderExtensions.ReadPlane(NetworkReader) NetworkReaderExtensions.ReadRay(NetworkReader) NetworkReaderExtensions.ReadMatrix4x4(NetworkReader) NetworkReaderExtensions.ReadBytes(NetworkReader, Int32) NetworkReaderExtensions.ReadGuid(NetworkReader) NetworkReaderExtensions.ReadTransform(NetworkReader) NetworkReaderExtensions.ReadGameObject(NetworkReader) NetworkReaderExtensions.ReadNetworkIdentity(NetworkReader)"
  },
  "api/Mirror.SyncMode.html": {
    "href": "api/Mirror.SyncMode.html",
    "title": "Enum SyncMode",
    "keywords": "Enum SyncMode Sync to everyone, or only to owner. Namespace : Mirror Assembly : doc.dll Syntax public enum SyncMode : int Fields Name Description Observers Owner"
  },
  "api/Mirror.ClientCallbackAttribute.html": {
    "href": "api/Mirror.ClientCallbackAttribute.html",
    "title": "Class ClientCallbackAttribute",
    "keywords": "Class ClientCallbackAttribute Prevents the server from running this method. No warning is printed. Inheritance System.Object ClientCallbackAttribute Namespace : Mirror Assembly : doc.dll Syntax public class ClientCallbackAttribute : Attribute"
  },
  "api/Mirror.NetworkBehaviour.CmdDelegate.html": {
    "href": "api/Mirror.NetworkBehaviour.CmdDelegate.html",
    "title": "Delegate NetworkBehaviour.CmdDelegate",
    "keywords": "Delegate NetworkBehaviour.CmdDelegate Delegate for Command functions. Namespace : Mirror Assembly : doc.dll Syntax public delegate void CmdDelegate(NetworkBehaviour obj, NetworkReader reader); Parameters Type Name Description NetworkBehaviour obj NetworkReader reader"
  },
  "api/Mirror.LogFilter.html": {
    "href": "api/Mirror.LogFilter.html",
    "title": "Class LogFilter",
    "keywords": "Class LogFilter Inheritance System.Object LogFilter Namespace : Mirror Assembly : doc.dll Syntax public static class LogFilter : object Fields | Improve this Doc View Source Debug Declaration public static bool Debug Field Value Type Description System.Boolean"
  },
  "api/Mirror.TargetRpcAttribute.html": {
    "href": "api/Mirror.TargetRpcAttribute.html",
    "title": "Class TargetRpcAttribute",
    "keywords": "Class TargetRpcAttribute The server uses a Remote Procedure Call (RPC) to run this function on a specific client. Inheritance System.Object TargetRpcAttribute Namespace : Mirror Assembly : doc.dll Syntax public class TargetRpcAttribute : Attribute Fields | Improve this Doc View Source channel Declaration public int channel Field Value Type Description System.Int32"
  },
  "api/Mirror.SyncListString.html": {
    "href": "api/Mirror.SyncListString.html",
    "title": "Class SyncListString",
    "keywords": "Class SyncListString Inheritance System.Object SyncList < System.String > SyncListString Implements IReadOnlyList < System.String > ISyncObject Inherited Members SyncList<String>.Count SyncList<String>.IsReadOnly SyncList<String>.Callback SyncList<String>.IsDirty SyncList<String>.Flush() SyncList<String>.OnSerializeAll(NetworkWriter) SyncList<String>.OnSerializeDelta(NetworkWriter) SyncList<String>.OnDeserializeAll(NetworkReader) SyncList<String>.OnDeserializeDelta(NetworkReader) SyncList<String>.Add(String) SyncList<String>.Clear() SyncList<String>.Contains(String) SyncList<String>.CopyTo(String[], Int32) SyncList<String>.IndexOf(String) SyncList<String>.FindIndex(Predicate<String>) SyncList<String>.Insert(Int32, String) SyncList<String>.Remove(String) SyncList<String>.RemoveAt(Int32) SyncList<String>.Item[Int32] SyncList<String>.GetEnumerator() Namespace : Mirror Assembly : doc.dll Syntax public class SyncListString : SyncList<string>, IReadOnlyList<string>, ISyncObject Methods | Improve this Doc View Source DeserializeItem(NetworkReader) Declaration protected override string DeserializeItem(NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description System.String Overrides Mirror.SyncList<System.String>.DeserializeItem(Mirror.NetworkReader) | Improve this Doc View Source SerializeItem(NetworkWriter, String) Declaration protected override void SerializeItem(NetworkWriter writer, string item) Parameters Type Name Description NetworkWriter writer System.String item Overrides Mirror.SyncList<System.String>.SerializeItem(Mirror.NetworkWriter, System.String) Implements IReadOnlyList<> ISyncObject"
  },
  "api/Mirror.FloatBytePacker.html": {
    "href": "api/Mirror.FloatBytePacker.html",
    "title": "Class FloatBytePacker",
    "keywords": "Class FloatBytePacker Inheritance System.Object FloatBytePacker Namespace : Mirror Assembly : doc.dll Syntax public static class FloatBytePacker : object Methods | Improve this Doc View Source PackThreeFloatsIntoUShort(Single, Single, Single, Single, Single) Declaration public static ushort PackThreeFloatsIntoUShort(float u, float v, float w, float minValue, float maxValue) Parameters Type Name Description System.Single u System.Single v System.Single w System.Single minValue System.Single maxValue Returns Type Description System.UInt16 | Improve this Doc View Source ScaleByteToFloat(Byte, Byte, Byte, Single, Single) Declaration public static float ScaleByteToFloat(byte value, byte minValue, byte maxValue, float minTarget, float maxTarget) Parameters Type Name Description System.Byte value System.Byte minValue System.Byte maxValue System.Single minTarget System.Single maxTarget Returns Type Description System.Single | Improve this Doc View Source ScaleFloatToByte(Single, Single, Single, Byte, Byte) Declaration public static byte ScaleFloatToByte(float value, float minValue, float maxValue, byte minTarget, byte maxTarget) Parameters Type Name Description System.Single value System.Single minValue System.Single maxValue System.Byte minTarget System.Byte maxTarget Returns Type Description System.Byte | Improve this Doc View Source UnpackUShortIntoThreeFloats(UInt16, Single, Single) Declaration public static Vector3 UnpackUShortIntoThreeFloats(ushort combined, float minTarget, float maxTarget) Parameters Type Name Description System.UInt16 combined System.Single minTarget System.Single maxTarget Returns Type Description Vector3"
  },
  "api/Mirror.NetworkDiagnostics.MessageInfo.html": {
    "href": "api/Mirror.NetworkDiagnostics.MessageInfo.html",
    "title": "Struct NetworkDiagnostics.MessageInfo",
    "keywords": "Struct NetworkDiagnostics.MessageInfo Describes an outgoing message Namespace : Mirror Assembly : doc.dll Syntax public struct MessageInfo Fields | Improve this Doc View Source bytes how big was the message (does not include transport headers) Declaration public readonly int bytes Field Value Type Description System.Int32 | Improve this Doc View Source channel channel through which the message was sent Declaration public readonly int channel Field Value Type Description System.Int32 | Improve this Doc View Source count How many connections was the message sent to If an object has a lot of observers this count could be high Declaration public readonly int count Field Value Type Description System.Int32 | Improve this Doc View Source message The message being sent Declaration public readonly IMessageBase message Field Value Type Description IMessageBase"
  },
  "api/Mirror.NetworkStartPosition.html": {
    "href": "api/Mirror.NetworkStartPosition.html",
    "title": "Class NetworkStartPosition",
    "keywords": "Class NetworkStartPosition This component is used to make a gameObject a starting position for spawning player objects in multiplayer games. This object's transform will be automatically registered and unregistered with the NetworkManager as a starting position. Inheritance System.Object NetworkStartPosition Namespace : Mirror Assembly : doc.dll Syntax public class NetworkStartPosition : MonoBehaviour Methods | Improve this Doc View Source Awake() Declaration public void Awake() | Improve this Doc View Source OnDestroy() Declaration public void OnDestroy()"
  },
  "api/Mirror.UnityEventException.html": {
    "href": "api/Mirror.UnityEventException.html",
    "title": "Class UnityEventException",
    "keywords": "Class UnityEventException Inheritance System.Object UnityEventException Namespace : Mirror Assembly : doc.dll Syntax public class UnityEventException : UnityEvent<Exception>"
  },
  "api/Mirror.NetworkWriterExtensions.html": {
    "href": "api/Mirror.NetworkWriterExtensions.html",
    "title": "Class NetworkWriterExtensions",
    "keywords": "Class NetworkWriterExtensions Inheritance System.Object NetworkWriterExtensions Namespace : Mirror Assembly : doc.dll Syntax public static class NetworkWriterExtensions : object Methods | Improve this Doc View Source Write<T>(NetworkWriter, T) Declaration public static void Write<T>(this NetworkWriter writer, T msg) where T : IMessageBase Parameters Type Name Description NetworkWriter writer T msg Type Parameters Name Description T | Improve this Doc View Source WriteBoolean(NetworkWriter, Boolean) Declaration public static void WriteBoolean(this NetworkWriter writer, bool value) Parameters Type Name Description NetworkWriter writer System.Boolean value | Improve this Doc View Source WriteByte(NetworkWriter, Byte) Declaration public static void WriteByte(this NetworkWriter writer, byte value) Parameters Type Name Description NetworkWriter writer System.Byte value | Improve this Doc View Source WriteBytesAndSize(NetworkWriter, Byte[]) Declaration public static void WriteBytesAndSize(this NetworkWriter writer, byte[] buffer) Parameters Type Name Description NetworkWriter writer System.Byte [] buffer | Improve this Doc View Source WriteBytesAndSize(NetworkWriter, Byte[], Int32, Int32) Declaration public static void WriteBytesAndSize(this NetworkWriter writer, byte[] buffer, int offset, int count) Parameters Type Name Description NetworkWriter writer System.Byte [] buffer System.Int32 offset System.Int32 count | Improve this Doc View Source WriteBytesAndSizeSegment(NetworkWriter, ArraySegment<Byte>) Declaration public static void WriteBytesAndSizeSegment(this NetworkWriter writer, ArraySegment<byte> buffer) Parameters Type Name Description NetworkWriter writer ArraySegment < System.Byte > buffer | Improve this Doc View Source WriteChar(NetworkWriter, Char) Declaration public static void WriteChar(this NetworkWriter writer, char value) Parameters Type Name Description NetworkWriter writer System.Char value | Improve this Doc View Source WriteColor(NetworkWriter, Color) Declaration public static void WriteColor(this NetworkWriter writer, Color value) Parameters Type Name Description NetworkWriter writer Color value | Improve this Doc View Source WriteColor32(NetworkWriter, Color32) Declaration public static void WriteColor32(this NetworkWriter writer, Color32 value) Parameters Type Name Description NetworkWriter writer Color32 value | Improve this Doc View Source WriteDecimal(NetworkWriter, Decimal) Declaration public static void WriteDecimal(this NetworkWriter writer, decimal value) Parameters Type Name Description NetworkWriter writer System.Decimal value | Improve this Doc View Source WriteDouble(NetworkWriter, Double) Declaration public static void WriteDouble(this NetworkWriter writer, double value) Parameters Type Name Description NetworkWriter writer System.Double value | Improve this Doc View Source WriteGameObject(NetworkWriter, GameObject) Declaration public static void WriteGameObject(this NetworkWriter writer, GameObject value) Parameters Type Name Description NetworkWriter writer GameObject value | Improve this Doc View Source WriteGuid(NetworkWriter, Guid) Declaration public static void WriteGuid(this NetworkWriter writer, Guid value) Parameters Type Name Description NetworkWriter writer Guid value | Improve this Doc View Source WriteInt16(NetworkWriter, Int16) Declaration public static void WriteInt16(this NetworkWriter writer, short value) Parameters Type Name Description NetworkWriter writer System.Int16 value | Improve this Doc View Source WriteMatrix4x4(NetworkWriter, Matrix4x4) Declaration public static void WriteMatrix4x4(this NetworkWriter writer, Matrix4x4 value) Parameters Type Name Description NetworkWriter writer Matrix4x4 value | Improve this Doc View Source WriteNetworkIdentity(NetworkWriter, NetworkIdentity) Declaration public static void WriteNetworkIdentity(this NetworkWriter writer, NetworkIdentity value) Parameters Type Name Description NetworkWriter writer NetworkIdentity value | Improve this Doc View Source WritePackedInt32(NetworkWriter, Int32) Declaration public static void WritePackedInt32(this NetworkWriter writer, int i) Parameters Type Name Description NetworkWriter writer System.Int32 i | Improve this Doc View Source WritePackedInt64(NetworkWriter, Int64) Declaration public static void WritePackedInt64(this NetworkWriter writer, long i) Parameters Type Name Description NetworkWriter writer System.Int64 i | Improve this Doc View Source WritePackedUInt32(NetworkWriter, UInt32) Declaration public static void WritePackedUInt32(this NetworkWriter writer, uint value) Parameters Type Name Description NetworkWriter writer System.UInt32 value | Improve this Doc View Source WritePackedUInt64(NetworkWriter, UInt64) Declaration public static void WritePackedUInt64(this NetworkWriter writer, ulong value) Parameters Type Name Description NetworkWriter writer System.UInt64 value | Improve this Doc View Source WritePlane(NetworkWriter, Plane) Declaration public static void WritePlane(this NetworkWriter writer, Plane value) Parameters Type Name Description NetworkWriter writer Plane value | Improve this Doc View Source WriteQuaternion(NetworkWriter, Quaternion) Declaration public static void WriteQuaternion(this NetworkWriter writer, Quaternion value) Parameters Type Name Description NetworkWriter writer Quaternion value | Improve this Doc View Source WriteRay(NetworkWriter, Ray) Declaration public static void WriteRay(this NetworkWriter writer, Ray value) Parameters Type Name Description NetworkWriter writer Ray value | Improve this Doc View Source WriteRect(NetworkWriter, Rect) Declaration public static void WriteRect(this NetworkWriter writer, Rect value) Parameters Type Name Description NetworkWriter writer Rect value | Improve this Doc View Source WriteSByte(NetworkWriter, SByte) Declaration public static void WriteSByte(this NetworkWriter writer, sbyte value) Parameters Type Name Description NetworkWriter writer System.SByte value | Improve this Doc View Source WriteSingle(NetworkWriter, Single) Declaration public static void WriteSingle(this NetworkWriter writer, float value) Parameters Type Name Description NetworkWriter writer System.Single value | Improve this Doc View Source WriteString(NetworkWriter, String) Declaration public static void WriteString(this NetworkWriter writer, string value) Parameters Type Name Description NetworkWriter writer System.String value | Improve this Doc View Source WriteTransform(NetworkWriter, Transform) Declaration public static void WriteTransform(this NetworkWriter writer, Transform value) Parameters Type Name Description NetworkWriter writer Transform value | Improve this Doc View Source WriteUInt16(NetworkWriter, UInt16) Declaration public static void WriteUInt16(this NetworkWriter writer, ushort value) Parameters Type Name Description NetworkWriter writer System.UInt16 value | Improve this Doc View Source WriteVector2(NetworkWriter, Vector2) Declaration public static void WriteVector2(this NetworkWriter writer, Vector2 value) Parameters Type Name Description NetworkWriter writer Vector2 value | Improve this Doc View Source WriteVector2Int(NetworkWriter, Vector2Int) Declaration public static void WriteVector2Int(this NetworkWriter writer, Vector2Int value) Parameters Type Name Description NetworkWriter writer Vector2Int value | Improve this Doc View Source WriteVector3(NetworkWriter, Vector3) Declaration public static void WriteVector3(this NetworkWriter writer, Vector3 value) Parameters Type Name Description NetworkWriter writer Vector3 value | Improve this Doc View Source WriteVector3Int(NetworkWriter, Vector3Int) Declaration public static void WriteVector3Int(this NetworkWriter writer, Vector3Int value) Parameters Type Name Description NetworkWriter writer Vector3Int value | Improve this Doc View Source WriteVector4(NetworkWriter, Vector4) Declaration public static void WriteVector4(this NetworkWriter writer, Vector4 value) Parameters Type Name Description NetworkWriter writer Vector4 value"
  },
  "api/Mirror.ClientRpcAttribute.html": {
    "href": "api/Mirror.ClientRpcAttribute.html",
    "title": "Class ClientRpcAttribute",
    "keywords": "Class ClientRpcAttribute The server uses a Remote Procedure Call (RPC) to run this function on clients. Inheritance System.Object ClientRpcAttribute Namespace : Mirror Assembly : doc.dll Syntax public class ClientRpcAttribute : Attribute Fields | Improve this Doc View Source channel Declaration public int channel Field Value Type Description System.Int32"
  },
  "api/Mirror.NetworkAnimator.html": {
    "href": "api/Mirror.NetworkAnimator.html",
    "title": "Class NetworkAnimator",
    "keywords": "Class NetworkAnimator A component to synchronize Mecanim animation states for networked objects. Inheritance System.Object NetworkBehaviour NetworkAnimator Inherited Members NetworkBehaviour.syncMode NetworkBehaviour.syncInterval NetworkBehaviour.isServer NetworkBehaviour.isClient NetworkBehaviour.isLocalPlayer NetworkBehaviour.isServerOnly NetworkBehaviour.isClientOnly NetworkBehaviour.hasAuthority NetworkBehaviour.netId NetworkBehaviour.connectionToServer NetworkBehaviour.connectionToClient NetworkBehaviour.syncVarDirtyBits NetworkBehaviour.getSyncVarHookGuard(UInt64) NetworkBehaviour.setSyncVarHookGuard(UInt64, Boolean) NetworkBehaviour.syncObjects NetworkBehaviour.netIdentity NetworkBehaviour.ComponentIndex NetworkBehaviour.InitSyncObject(ISyncObject) NetworkBehaviour.SendCommandInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeCommand(Int32, NetworkReader) NetworkBehaviour.SendRPCInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.SendTargetRPCInternal(NetworkConnection, Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeRPC(Int32, NetworkReader) NetworkBehaviour.SendEventInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeSyncEvent(Int32, NetworkReader) NetworkBehaviour.RegisterDelegate(Type, String, MirrorInvokeType, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterCommandDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterRpcDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterEventDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.GetRpcHandler(Int32) NetworkBehaviour.SyncVarGameObjectEqual(GameObject, UInt32) NetworkBehaviour.SetSyncVarGameObject(GameObject, GameObject, UInt64, UInt32) NetworkBehaviour.GetSyncVarGameObject(UInt32, GameObject) NetworkBehaviour.SyncVarNetworkIdentityEqual(NetworkIdentity, UInt32) NetworkBehaviour.SetSyncVarNetworkIdentity(NetworkIdentity, NetworkIdentity, UInt64, UInt32) NetworkBehaviour.GetSyncVarNetworkIdentity(UInt32, NetworkIdentity) NetworkBehaviour.SyncVarEqual<T>(T, T) NetworkBehaviour.SetSyncVar<T>(T, T, UInt64) NetworkBehaviour.SetDirtyBit(UInt64) NetworkBehaviour.ClearAllDirtyBits() NetworkBehaviour.SerializeObjectsAll(NetworkWriter) NetworkBehaviour.SerializeObjectsDelta(NetworkWriter) NetworkBehaviour.OnNetworkDestroy() NetworkBehaviour.OnStartServer() NetworkBehaviour.OnStartClient() NetworkBehaviour.OnStartLocalPlayer() NetworkBehaviour.OnStartAuthority() NetworkBehaviour.OnStopAuthority() NetworkBehaviour.OnRebuildObservers(HashSet<NetworkConnection>, Boolean) NetworkBehaviour.OnSetHostVisibility(Boolean) NetworkBehaviour.OnCheckObserver(NetworkConnection) Namespace : Mirror Assembly : doc.dll Syntax public class NetworkAnimator : NetworkBehaviour Remarks The animation of game objects can be networked by this component. There are two models of authority for networked movement: If the object has authority on the client, then it should animated locally on the owning client. The animation state information will be sent from the owning client to the server, then broadcast to all of the other clients. This is common for player objects. If the object has authority on the server, then it should be animated on the server and state information will be sent to all clients. This is common for objects not related to a specific client, such as an enemy unit. The NetworkAnimator synchronizes the animation parameters that are checked in the inspector view. It does not automatically sychronize triggers. The function SetTrigger can by used by an object with authority to fire an animation trigger on other clients. Fields | Improve this Doc View Source Animator The animator component to synchronize. Declaration public Animator Animator Field Value Type Description Animator | Improve this Doc View Source ClientAuthority Declaration public bool ClientAuthority Field Value Type Description System.Boolean Methods | Improve this Doc View Source OnDeserialize(NetworkReader, Boolean) Custom Deserialization Declaration public override void OnDeserialize(NetworkReader reader, bool initialState) Parameters Type Name Description NetworkReader reader System.Boolean initialState Overrides NetworkBehaviour.OnDeserialize(NetworkReader, Boolean) | Improve this Doc View Source OnSerialize(NetworkWriter, Boolean) Custom Serialization Declaration public override bool OnSerialize(NetworkWriter writer, bool initialState) Parameters Type Name Description NetworkWriter writer System.Boolean initialState Returns Type Description System.Boolean Overrides NetworkBehaviour.OnSerialize(NetworkWriter, Boolean) | Improve this Doc View Source ResetTrigger(Int32) Causes an animation trigger to be reset for a networked object. Declaration public void ResetTrigger(int hash) Parameters Type Name Description System.Int32 hash Hash id of trigger (from the Animator). | Improve this Doc View Source ResetTrigger(String) Causes an animation trigger to be reset for a networked object. If local authority is set, and this is called from the client, then the trigger will be reset on the server and all clients. If not, then this is called on the server, and the trigger will be reset on all clients. Declaration public void ResetTrigger(string triggerName) Parameters Type Name Description System.String triggerName Name of trigger. | Improve this Doc View Source SetTrigger(Int32) Causes an animation trigger to be invoked for a networked object. Declaration public void SetTrigger(int hash) Parameters Type Name Description System.Int32 hash Hash id of trigger (from the Animator). | Improve this Doc View Source SetTrigger(String) Causes an animation trigger to be invoked for a networked object. If local authority is set, and this is called from the client, then the trigger will be invoked on the server and all clients. If not, then this is called on the server, and the trigger will be called on all clients. Declaration public void SetTrigger(string triggerName) Parameters Type Name Description System.String triggerName Name of trigger."
  },
  "api/Mirror.IMessageBase.html": {
    "href": "api/Mirror.IMessageBase.html",
    "title": "Interface IMessageBase",
    "keywords": "Interface IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public interface IMessageBase Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer"
  },
  "api/Mirror.ErrorMessage.html": {
    "href": "api/Mirror.ErrorMessage.html",
    "title": "Struct ErrorMessage",
    "keywords": "Struct ErrorMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct ErrorMessage : IMessageBase Constructors | Improve this Doc View Source ErrorMessage(Byte) Declaration public ErrorMessage(byte v) Parameters Type Name Description System.Byte v Fields | Improve this Doc View Source value Declaration public byte value Field Value Type Description System.Byte Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.Websocket.Client.html": {
    "href": "api/Mirror.Websocket.Client.html",
    "title": "Class Client",
    "keywords": "Class Client Inheritance System.Object Client Namespace : Mirror.Websocket Assembly : doc.dll Syntax public class Client : object Fields | Improve this Doc View Source NoDelay Declaration public bool NoDelay Field Value Type Description System.Boolean Properties | Improve this Doc View Source Connecting Declaration public bool Connecting { get; set; } Property Value Type Description System.Boolean | Improve this Doc View Source IsConnected Declaration public bool IsConnected { get; set; } Property Value Type Description System.Boolean Methods | Improve this Doc View Source Connect(Uri) Declaration public Task Connect(Uri uri) Parameters Type Name Description Uri uri Returns Type Description Task | Improve this Doc View Source Disconnect() Declaration public void Disconnect() | Improve this Doc View Source Send(ArraySegment<Byte>) Declaration public Task Send(ArraySegment<byte> segment) Parameters Type Name Description ArraySegment < System.Byte > segment Returns Type Description Task | Improve this Doc View Source ToString() Declaration public override string ToString() Returns Type Description System.String Events | Improve this Doc View Source Connected Declaration public event Action Connected Event Type Type Description Action | Improve this Doc View Source Disconnected Declaration public event Action Disconnected Event Type Type Description Action | Improve this Doc View Source ReceivedData Declaration public event Action<ArraySegment<byte>> ReceivedData Event Type Type Description Action < ArraySegment < System.Byte >> | Improve this Doc View Source ReceivedError Declaration public event Action<Exception> ReceivedError Event Type Type Description Action < Exception >"
  },
  "api/Mirror.ClientAttribute.html": {
    "href": "api/Mirror.ClientAttribute.html",
    "title": "Class ClientAttribute",
    "keywords": "Class ClientAttribute Prevents the server from running this method. Prints a warning if the server tries to execute this method. Inheritance System.Object ClientAttribute Namespace : Mirror Assembly : doc.dll Syntax public class ClientAttribute : Attribute"
  },
  "api/Mirror.Tcp.html": {
    "href": "api/Mirror.Tcp.html",
    "title": "Namespace Mirror.Tcp",
    "keywords": "Namespace Mirror.Tcp Classes Client Common NetworkStreamExtensions ObjectPool<T> Server TcpTransport"
  },
  "api/Telepathy.html": {
    "href": "api/Telepathy.html",
    "title": "Namespace Telepathy",
    "keywords": "Namespace Telepathy Classes Client Common Logger NetworkStreamExtensions SafeQueue<T> Server ThreadExtensions Utils Structs Message Enums EventType"
  },
  "api/Mirror.NetworkTransformChild.html": {
    "href": "api/Mirror.NetworkTransformChild.html",
    "title": "Class NetworkTransformChild",
    "keywords": "Class NetworkTransformChild A component to synchronize the position of child transforms of networked objects. There must be a NetworkTransform on the root object of the hierarchy. There can be multiple NetworkTransformChild components on an object. This does not use physics for synchronization, it simply synchronizes the localPosition and localRotation of the child transform and lerps towards the recieved values. Inheritance System.Object NetworkBehaviour NetworkTransformBase NetworkTransformChild Inherited Members NetworkTransformBase.clientAuthority NetworkTransformBase.OnSerialize(NetworkWriter, Boolean) NetworkTransformBase.OnDeserialize(NetworkReader, Boolean) NetworkBehaviour.syncMode NetworkBehaviour.syncInterval NetworkBehaviour.isServer NetworkBehaviour.isClient NetworkBehaviour.isLocalPlayer NetworkBehaviour.isServerOnly NetworkBehaviour.isClientOnly NetworkBehaviour.hasAuthority NetworkBehaviour.netId NetworkBehaviour.connectionToServer NetworkBehaviour.connectionToClient NetworkBehaviour.syncVarDirtyBits NetworkBehaviour.getSyncVarHookGuard(UInt64) NetworkBehaviour.setSyncVarHookGuard(UInt64, Boolean) NetworkBehaviour.syncObjects NetworkBehaviour.netIdentity NetworkBehaviour.ComponentIndex NetworkBehaviour.InitSyncObject(ISyncObject) NetworkBehaviour.SendCommandInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeCommand(Int32, NetworkReader) NetworkBehaviour.SendRPCInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.SendTargetRPCInternal(NetworkConnection, Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeRPC(Int32, NetworkReader) NetworkBehaviour.SendEventInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeSyncEvent(Int32, NetworkReader) NetworkBehaviour.RegisterDelegate(Type, String, MirrorInvokeType, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterCommandDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterRpcDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterEventDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.GetRpcHandler(Int32) NetworkBehaviour.SyncVarGameObjectEqual(GameObject, UInt32) NetworkBehaviour.SetSyncVarGameObject(GameObject, GameObject, UInt64, UInt32) NetworkBehaviour.GetSyncVarGameObject(UInt32, GameObject) NetworkBehaviour.SyncVarNetworkIdentityEqual(NetworkIdentity, UInt32) NetworkBehaviour.SetSyncVarNetworkIdentity(NetworkIdentity, NetworkIdentity, UInt64, UInt32) NetworkBehaviour.GetSyncVarNetworkIdentity(UInt32, NetworkIdentity) NetworkBehaviour.SyncVarEqual<T>(T, T) NetworkBehaviour.SetSyncVar<T>(T, T, UInt64) NetworkBehaviour.SetDirtyBit(UInt64) NetworkBehaviour.ClearAllDirtyBits() NetworkBehaviour.SerializeObjectsAll(NetworkWriter) NetworkBehaviour.SerializeObjectsDelta(NetworkWriter) NetworkBehaviour.OnNetworkDestroy() NetworkBehaviour.OnStartServer() NetworkBehaviour.OnStartClient() NetworkBehaviour.OnStartLocalPlayer() NetworkBehaviour.OnStartAuthority() NetworkBehaviour.OnStopAuthority() NetworkBehaviour.OnRebuildObservers(HashSet<NetworkConnection>, Boolean) NetworkBehaviour.OnSetHostVisibility(Boolean) NetworkBehaviour.OnCheckObserver(NetworkConnection) Namespace : Mirror Assembly : doc.dll Syntax public class NetworkTransformChild : NetworkTransformBase Fields | Improve this Doc View Source Target Declaration public Transform Target Field Value Type Description Transform Properties | Improve this Doc View Source TargetComponent Declaration protected override Transform TargetComponent { get; } Property Value Type Description Transform Overrides NetworkTransformBase.TargetComponent"
  },
  "api/Mirror.CommandAttribute.html": {
    "href": "api/Mirror.CommandAttribute.html",
    "title": "Class CommandAttribute",
    "keywords": "Class CommandAttribute Call this from a client to run this function on the server. Make sure to validate input etc. It's not possible to call this from a server. Inheritance System.Object CommandAttribute Namespace : Mirror Assembly : doc.dll Syntax public class CommandAttribute : Attribute Fields | Improve this Doc View Source channel Declaration public int channel Field Value Type Description System.Int32"
  },
  "api/Mirror.ObjectDestroyMessage.html": {
    "href": "api/Mirror.ObjectDestroyMessage.html",
    "title": "Struct ObjectDestroyMessage",
    "keywords": "Struct ObjectDestroyMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct ObjectDestroyMessage : IMessageBase Fields | Improve this Doc View Source netId Declaration public uint netId Field Value Type Description System.UInt32 Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.SyncSet-1.html": {
    "href": "api/Mirror.SyncSet-1.html",
    "title": "Class SyncSet<T>",
    "keywords": "Class SyncSet<T> Inheritance System.Object SyncSet<T> SyncHashSet<T> SyncSortedSet<T> Implements ISyncObject Namespace : Mirror Assembly : doc.dll Syntax public abstract class SyncSet<T> : ISet<T>, ISyncObject Type Parameters Name Description T Constructors | Improve this Doc View Source SyncSet(ISet<T>) Declaration protected SyncSet(ISet<T> objects) Parameters Type Name Description ISet <T> objects Fields | Improve this Doc View Source objects Declaration protected readonly ISet<T> objects Field Value Type Description ISet <T> Properties | Improve this Doc View Source Count Declaration public int Count { get; } Property Value Type Description System.Int32 | Improve this Doc View Source IsDirty Declaration public bool IsDirty { get; } Property Value Type Description System.Boolean | Improve this Doc View Source IsReadOnly Declaration public bool IsReadOnly { get; } Property Value Type Description System.Boolean Methods | Improve this Doc View Source Add(T) Declaration public bool Add(T item) Parameters Type Name Description T item Returns Type Description System.Boolean | Improve this Doc View Source Clear() Declaration public void Clear() | Improve this Doc View Source Contains(T) Declaration public bool Contains(T item) Parameters Type Name Description T item Returns Type Description System.Boolean | Improve this Doc View Source CopyTo(T[], Int32) Declaration public void CopyTo(T[] array, int index) Parameters Type Name Description T[] array System.Int32 index | Improve this Doc View Source DeserializeItem(NetworkReader) Declaration protected virtual T DeserializeItem(NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description T | Improve this Doc View Source ExceptWith(IEnumerable<T>) Declaration public void ExceptWith(IEnumerable<T> other) Parameters Type Name Description IEnumerable <T> other | Improve this Doc View Source Flush() Declaration public void Flush() | Improve this Doc View Source GetEnumerator() Declaration public IEnumerator<T> GetEnumerator() Returns Type Description IEnumerator <T> | Improve this Doc View Source IntersectWith(IEnumerable<T>) Declaration public void IntersectWith(IEnumerable<T> other) Parameters Type Name Description IEnumerable <T> other | Improve this Doc View Source IsProperSubsetOf(IEnumerable<T>) Declaration public bool IsProperSubsetOf(IEnumerable<T> other) Parameters Type Name Description IEnumerable <T> other Returns Type Description System.Boolean | Improve this Doc View Source IsProperSupersetOf(IEnumerable<T>) Declaration public bool IsProperSupersetOf(IEnumerable<T> other) Parameters Type Name Description IEnumerable <T> other Returns Type Description System.Boolean | Improve this Doc View Source IsSubsetOf(IEnumerable<T>) Declaration public bool IsSubsetOf(IEnumerable<T> other) Parameters Type Name Description IEnumerable <T> other Returns Type Description System.Boolean | Improve this Doc View Source IsSupersetOf(IEnumerable<T>) Declaration public bool IsSupersetOf(IEnumerable<T> other) Parameters Type Name Description IEnumerable <T> other Returns Type Description System.Boolean | Improve this Doc View Source OnDeserializeAll(NetworkReader) Declaration public void OnDeserializeAll(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source OnDeserializeDelta(NetworkReader) Declaration public void OnDeserializeDelta(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source OnSerializeAll(NetworkWriter) Declaration public void OnSerializeAll(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer | Improve this Doc View Source OnSerializeDelta(NetworkWriter) Declaration public void OnSerializeDelta(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer | Improve this Doc View Source Overlaps(IEnumerable<T>) Declaration public bool Overlaps(IEnumerable<T> other) Parameters Type Name Description IEnumerable <T> other Returns Type Description System.Boolean | Improve this Doc View Source Remove(T) Declaration public bool Remove(T item) Parameters Type Name Description T item Returns Type Description System.Boolean | Improve this Doc View Source SerializeItem(NetworkWriter, T) Declaration protected virtual void SerializeItem(NetworkWriter writer, T item) Parameters Type Name Description NetworkWriter writer T item | Improve this Doc View Source SetEquals(IEnumerable<T>) Declaration public bool SetEquals(IEnumerable<T> other) Parameters Type Name Description IEnumerable <T> other Returns Type Description System.Boolean | Improve this Doc View Source SymmetricExceptWith(IEnumerable<T>) Declaration public void SymmetricExceptWith(IEnumerable<T> other) Parameters Type Name Description IEnumerable <T> other | Improve this Doc View Source UnionWith(IEnumerable<T>) Declaration public void UnionWith(IEnumerable<T> other) Parameters Type Name Description IEnumerable <T> other Events | Improve this Doc View Source Callback Declaration public event SyncSet<T>.SyncSetChanged Callback Event Type Type Description SyncSet.SyncSetChanged <> Implements ISyncObject"
  },
  "api/Mirror.ObjectSpawnFinishedMessage.html": {
    "href": "api/Mirror.ObjectSpawnFinishedMessage.html",
    "title": "Struct ObjectSpawnFinishedMessage",
    "keywords": "Struct ObjectSpawnFinishedMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct ObjectSpawnFinishedMessage : IMessageBase Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.SyncList-1.Enumerator.html": {
    "href": "api/Mirror.SyncList-1.Enumerator.html",
    "title": "Struct SyncList<T>.Enumerator",
    "keywords": "Struct SyncList<T>.Enumerator Implements IEnumerator <T> Namespace : Mirror Assembly : doc.dll Syntax public struct Enumerator : IEnumerator<T> Constructors | Improve this Doc View Source Enumerator(SyncList<T>) Declaration public Enumerator(SyncList<T> list) Parameters Type Name Description SyncList <T> list Properties | Improve this Doc View Source Current Declaration public T Current { get; } Property Value Type Description T Methods | Improve this Doc View Source Dispose() Declaration public void Dispose() | Improve this Doc View Source MoveNext() Declaration public bool MoveNext() Returns Type Description System.Boolean | Improve this Doc View Source Reset() Declaration public void Reset() Implements IEnumerator<>"
  },
  "api/Mirror.NetworkRoomPlayer.html": {
    "href": "api/Mirror.NetworkRoomPlayer.html",
    "title": "Class NetworkRoomPlayer",
    "keywords": "Class NetworkRoomPlayer This component works in conjunction with the NetworkRoomManager to make up the multiplayer room system. The RoomPrefab object of the NetworkRoomManager must have this component on it. This component holds basic room player data required for the room to function. Game specific data for room players can be put in other components on the RoomPrefab or in scripts derived from NetworkRoomPlayer. Inheritance System.Object NetworkBehaviour NetworkRoomPlayer Inherited Members NetworkBehaviour.syncMode NetworkBehaviour.syncInterval NetworkBehaviour.isServer NetworkBehaviour.isClient NetworkBehaviour.isLocalPlayer NetworkBehaviour.isServerOnly NetworkBehaviour.isClientOnly NetworkBehaviour.hasAuthority NetworkBehaviour.netId NetworkBehaviour.connectionToServer NetworkBehaviour.connectionToClient NetworkBehaviour.syncVarDirtyBits NetworkBehaviour.getSyncVarHookGuard(UInt64) NetworkBehaviour.setSyncVarHookGuard(UInt64, Boolean) NetworkBehaviour.syncObjects NetworkBehaviour.netIdentity NetworkBehaviour.ComponentIndex NetworkBehaviour.InitSyncObject(ISyncObject) NetworkBehaviour.SendCommandInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeCommand(Int32, NetworkReader) NetworkBehaviour.SendRPCInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.SendTargetRPCInternal(NetworkConnection, Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeRPC(Int32, NetworkReader) NetworkBehaviour.SendEventInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeSyncEvent(Int32, NetworkReader) NetworkBehaviour.RegisterDelegate(Type, String, MirrorInvokeType, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterCommandDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterRpcDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterEventDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.GetRpcHandler(Int32) NetworkBehaviour.SyncVarGameObjectEqual(GameObject, UInt32) NetworkBehaviour.SetSyncVarGameObject(GameObject, GameObject, UInt64, UInt32) NetworkBehaviour.GetSyncVarGameObject(UInt32, GameObject) NetworkBehaviour.SyncVarNetworkIdentityEqual(NetworkIdentity, UInt32) NetworkBehaviour.SetSyncVarNetworkIdentity(NetworkIdentity, NetworkIdentity, UInt64, UInt32) NetworkBehaviour.GetSyncVarNetworkIdentity(UInt32, NetworkIdentity) NetworkBehaviour.SyncVarEqual<T>(T, T) NetworkBehaviour.SetSyncVar<T>(T, T, UInt64) NetworkBehaviour.SetDirtyBit(UInt64) NetworkBehaviour.ClearAllDirtyBits() NetworkBehaviour.OnSerialize(NetworkWriter, Boolean) NetworkBehaviour.OnDeserialize(NetworkReader, Boolean) NetworkBehaviour.SerializeObjectsAll(NetworkWriter) NetworkBehaviour.SerializeObjectsDelta(NetworkWriter) NetworkBehaviour.OnNetworkDestroy() NetworkBehaviour.OnStartServer() NetworkBehaviour.OnStartClient() NetworkBehaviour.OnStartLocalPlayer() NetworkBehaviour.OnStartAuthority() NetworkBehaviour.OnStopAuthority() NetworkBehaviour.OnRebuildObservers(HashSet<NetworkConnection>, Boolean) NetworkBehaviour.OnSetHostVisibility(Boolean) NetworkBehaviour.OnCheckObserver(NetworkConnection) Namespace : Mirror Assembly : doc.dll Syntax public class NetworkRoomPlayer : NetworkBehaviour Fields | Improve this Doc View Source Index Current index of the player, e.g. Player1, Player2, etc. Declaration public int Index Field Value Type Description System.Int32 | Improve this Doc View Source ReadyToBegin This is a flag that control whether this player is ready for the game to begin. When all players are ready to begin, the game will start. This should not be set directly, the SendReadyToBeginMessage function should be called on the client to set it on the server. Declaration public bool ReadyToBegin Field Value Type Description System.Boolean | Improve this Doc View Source ShowRoomGUI This flag controls whether the default UI is shown for the room player. As this UI is rendered using the old GUI system, it is only recommended for testing purposes. Declaration public bool ShowRoomGUI Field Value Type Description System.Boolean Methods | Improve this Doc View Source CmdChangeReadyState(Boolean) Declaration public void CmdChangeReadyState(bool readyState) Parameters Type Name Description System.Boolean readyState | Improve this Doc View Source OnClientEnterRoom() This is a hook that is invoked on all player objects when entering the room. Note: isLocalPlayer is not guaranteed to be set until OnStartLocalPlayer is called. Declaration public virtual void OnClientEnterRoom() | Improve this Doc View Source OnClientExitRoom() This is a hook that is invoked on all player objects when exiting the room. Declaration public virtual void OnClientExitRoom() | Improve this Doc View Source OnClientReady(Boolean) This is a hook that is invoked on clients when a RoomPlayer switches between ready or not ready. This function is called when the a client player calls SendReadyToBeginMessage() or SendNotReadyToBeginMessage(). Declaration public virtual void OnClientReady(bool readyState) Parameters Type Name Description System.Boolean readyState Whether the player is ready or not. | Improve this Doc View Source OnGUI() Render a UI for the room. Override to provide your on UI Declaration public virtual void OnGUI() | Improve this Doc View Source Start() Do not use Start - Override OnStartrHost / OnStartClient instead! Declaration public void Start()"
  },
  "api/Mirror.SyncDictionary-2.html": {
    "href": "api/Mirror.SyncDictionary-2.html",
    "title": "Class SyncDictionary<TKey, TValue>",
    "keywords": "Class SyncDictionary<TKey, TValue> Inheritance System.Object SyncIDictionary <TKey, TValue> SyncDictionary<TKey, TValue> Implements ISyncObject Inherited Members SyncIDictionary<TKey, TValue>.objects SyncIDictionary<TKey, TValue>.Count SyncIDictionary<TKey, TValue>.IsReadOnly SyncIDictionary<TKey, TValue>.Callback SyncIDictionary<TKey, TValue>.SerializeKey(NetworkWriter, TKey) SyncIDictionary<TKey, TValue>.SerializeItem(NetworkWriter, TValue) SyncIDictionary<TKey, TValue>.DeserializeKey(NetworkReader) SyncIDictionary<TKey, TValue>.DeserializeItem(NetworkReader) SyncIDictionary<TKey, TValue>.IsDirty SyncIDictionary<TKey, TValue>.Keys SyncIDictionary<TKey, TValue>.Values SyncIDictionary<TKey, TValue>.Flush() SyncIDictionary<TKey, TValue>.OnSerializeAll(NetworkWriter) SyncIDictionary<TKey, TValue>.OnSerializeDelta(NetworkWriter) SyncIDictionary<TKey, TValue>.OnDeserializeAll(NetworkReader) SyncIDictionary<TKey, TValue>.OnDeserializeDelta(NetworkReader) SyncIDictionary<TKey, TValue>.Clear() SyncIDictionary<TKey, TValue>.ContainsKey(TKey) SyncIDictionary<TKey, TValue>.Remove(TKey) SyncIDictionary<TKey, TValue>.Item[TKey] SyncIDictionary<TKey, TValue>.TryGetValue(TKey, TValue) SyncIDictionary<TKey, TValue>.Add(TKey, TValue) SyncIDictionary<TKey, TValue>.Add(KeyValuePair<TKey, TValue>) SyncIDictionary<TKey, TValue>.Contains(KeyValuePair<TKey, TValue>) SyncIDictionary<TKey, TValue>.CopyTo(KeyValuePair<TKey, TValue>[], Int32) SyncIDictionary<TKey, TValue>.Remove(KeyValuePair<TKey, TValue>) SyncIDictionary<TKey, TValue>.GetEnumerator() Namespace : Mirror Assembly : doc.dll Syntax public abstract class SyncDictionary<TKey, TValue> : SyncIDictionary<TKey, TValue>, ISyncObject Type Parameters Name Description TKey TValue Constructors | Improve this Doc View Source SyncDictionary() Declaration protected SyncDictionary() | Improve this Doc View Source SyncDictionary(IEqualityComparer<TKey>) Declaration protected SyncDictionary(IEqualityComparer<TKey> eq) Parameters Type Name Description IEqualityComparer <TKey> eq Properties | Improve this Doc View Source Keys Declaration public Dictionary<TKey, TValue>.KeyCollection Keys { get; } Property Value Type Description Dictionary.KeyCollection <> | Improve this Doc View Source Values Declaration public Dictionary<TKey, TValue>.ValueCollection Values { get; } Property Value Type Description Dictionary.ValueCollection <> Methods | Improve this Doc View Source GetEnumerator() Declaration public Dictionary<TKey, TValue>.Enumerator GetEnumerator() Returns Type Description Dictionary.Enumerator <> Implements ISyncObject"
  },
  "api/Mirror.Tcp.TcpTransport.html": {
    "href": "api/Mirror.Tcp.TcpTransport.html",
    "title": "Class TcpTransport",
    "keywords": "Class TcpTransport Inheritance System.Object Transport TcpTransport Inherited Members Transport.activeTransport Transport.OnClientConnected Transport.OnClientDataReceived Transport.OnClientError Transport.OnClientDisconnected Transport.ClientConnect(Uri) Transport.OnServerConnected Transport.OnServerDataReceived Transport.OnServerError Transport.OnServerDisconnected Transport.Update() Transport.OnApplicationQuit() Namespace : Mirror.Tcp Assembly : doc.dll Syntax public class TcpTransport : Transport Fields | Improve this Doc View Source client Declaration protected Client client Field Value Type Description Client | Improve this Doc View Source NoDelay Declaration public bool NoDelay Field Value Type Description System.Boolean | Improve this Doc View Source port Declaration public int port Field Value Type Description System.Int32 | Improve this Doc View Source server Declaration protected Server server Field Value Type Description Server Methods | Improve this Doc View Source Available() Declaration public override bool Available() Returns Type Description System.Boolean Overrides Transport.Available() | Improve this Doc View Source Awake() Declaration public void Awake() | Improve this Doc View Source ClientConnect(String) Declaration public override void ClientConnect(string address) Parameters Type Name Description System.String address Overrides Transport.ClientConnect(String) | Improve this Doc View Source ClientConnected() Declaration public override bool ClientConnected() Returns Type Description System.Boolean Overrides Transport.ClientConnected() | Improve this Doc View Source ClientDisconnect() Declaration public override void ClientDisconnect() Overrides Transport.ClientDisconnect() | Improve this Doc View Source ClientSend(Int32, ArraySegment<Byte>) Declaration public override bool ClientSend(int channelId, ArraySegment<byte> segment) Parameters Type Name Description System.Int32 channelId ArraySegment < System.Byte > segment Returns Type Description System.Boolean Overrides Transport.ClientSend(Int32, ArraySegment<Byte>) | Improve this Doc View Source GetMaxPacketSize(Int32) Declaration public override int GetMaxPacketSize(int channelId) Parameters Type Name Description System.Int32 channelId Returns Type Description System.Int32 Overrides Transport.GetMaxPacketSize(Int32) | Improve this Doc View Source LateUpdate() Declaration public void LateUpdate() | Improve this Doc View Source ServerActive() Declaration public override bool ServerActive() Returns Type Description System.Boolean Overrides Transport.ServerActive() | Improve this Doc View Source ServerDisconnect(Int32) Declaration public override bool ServerDisconnect(int connectionId) Parameters Type Name Description System.Int32 connectionId Returns Type Description System.Boolean Overrides Transport.ServerDisconnect(Int32) | Improve this Doc View Source ServerGetClientAddress(Int32) Declaration public override string ServerGetClientAddress(int connectionId) Parameters Type Name Description System.Int32 connectionId Returns Type Description System.String Overrides Transport.ServerGetClientAddress(Int32) | Improve this Doc View Source ServerSend(List<Int32>, Int32, ArraySegment<Byte>) Declaration public override bool ServerSend(List<int> connectionIds, int channelId, ArraySegment<byte> segment) Parameters Type Name Description List < System.Int32 > connectionIds System.Int32 channelId ArraySegment < System.Byte > segment Returns Type Description System.Boolean Overrides Transport.ServerSend(List<Int32>, Int32, ArraySegment<Byte>) | Improve this Doc View Source ServerStart() Declaration public override void ServerStart() Overrides Transport.ServerStart() | Improve this Doc View Source ServerStop() Declaration public override void ServerStop() Overrides Transport.ServerStop() | Improve this Doc View Source Shutdown() Declaration public override void Shutdown() Overrides Transport.Shutdown() | Improve this Doc View Source ToString() Declaration public override string ToString() Returns Type Description System.String"
  },
  "api/Mirror.SyncEventAttribute.html": {
    "href": "api/Mirror.SyncEventAttribute.html",
    "title": "Class SyncEventAttribute",
    "keywords": "Class SyncEventAttribute SyncEvents are networked events like ClientRpc's, but instead of calling a function on the game object, they trigger Events instead. Inheritance System.Object SyncEventAttribute Namespace : Mirror Assembly : doc.dll Syntax public class SyncEventAttribute : Attribute Fields | Improve this Doc View Source channel Declaration public int channel Field Value Type Description System.Int32"
  },
  "api/Mirror.NetworkProximityChecker.CheckMethod.html": {
    "href": "api/Mirror.NetworkProximityChecker.CheckMethod.html",
    "title": "Enum NetworkProximityChecker.CheckMethod",
    "keywords": "Enum NetworkProximityChecker.CheckMethod Enumeration of methods to use to check proximity. Namespace : Mirror Assembly : doc.dll Syntax public enum CheckMethod : int Fields Name Description Physics2D Physics3D"
  },
  "api/Telepathy.ThreadExtensions.html": {
    "href": "api/Telepathy.ThreadExtensions.html",
    "title": "Class ThreadExtensions",
    "keywords": "Class ThreadExtensions Inheritance System.Object ThreadExtensions Namespace : Telepathy Assembly : doc.dll Syntax public static class ThreadExtensions : object Methods | Improve this Doc View Source AbortAndJoin(Thread) Declaration public static void AbortAndJoin(this Thread thread) Parameters Type Name Description Thread thread"
  },
  "api/Mirror.NetworkProximityChecker.html": {
    "href": "api/Mirror.NetworkProximityChecker.html",
    "title": "Class NetworkProximityChecker",
    "keywords": "Class NetworkProximityChecker Component that controls visibility of networked objects for players. Any object with this component on it will not be visible to players more than a (configurable) distance away. Inheritance System.Object NetworkBehaviour NetworkProximityChecker Inherited Members NetworkBehaviour.syncMode NetworkBehaviour.syncInterval NetworkBehaviour.isServer NetworkBehaviour.isClient NetworkBehaviour.isLocalPlayer NetworkBehaviour.isServerOnly NetworkBehaviour.isClientOnly NetworkBehaviour.hasAuthority NetworkBehaviour.netId NetworkBehaviour.connectionToServer NetworkBehaviour.connectionToClient NetworkBehaviour.syncVarDirtyBits NetworkBehaviour.getSyncVarHookGuard(UInt64) NetworkBehaviour.setSyncVarHookGuard(UInt64, Boolean) NetworkBehaviour.syncObjects NetworkBehaviour.netIdentity NetworkBehaviour.ComponentIndex NetworkBehaviour.InitSyncObject(ISyncObject) NetworkBehaviour.SendCommandInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeCommand(Int32, NetworkReader) NetworkBehaviour.SendRPCInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.SendTargetRPCInternal(NetworkConnection, Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeRPC(Int32, NetworkReader) NetworkBehaviour.SendEventInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeSyncEvent(Int32, NetworkReader) NetworkBehaviour.RegisterDelegate(Type, String, MirrorInvokeType, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterCommandDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterRpcDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterEventDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.GetRpcHandler(Int32) NetworkBehaviour.SyncVarGameObjectEqual(GameObject, UInt32) NetworkBehaviour.SetSyncVarGameObject(GameObject, GameObject, UInt64, UInt32) NetworkBehaviour.GetSyncVarGameObject(UInt32, GameObject) NetworkBehaviour.SyncVarNetworkIdentityEqual(NetworkIdentity, UInt32) NetworkBehaviour.SetSyncVarNetworkIdentity(NetworkIdentity, NetworkIdentity, UInt64, UInt32) NetworkBehaviour.GetSyncVarNetworkIdentity(UInt32, NetworkIdentity) NetworkBehaviour.SyncVarEqual<T>(T, T) NetworkBehaviour.SetSyncVar<T>(T, T, UInt64) NetworkBehaviour.SetDirtyBit(UInt64) NetworkBehaviour.ClearAllDirtyBits() NetworkBehaviour.OnSerialize(NetworkWriter, Boolean) NetworkBehaviour.OnDeserialize(NetworkReader, Boolean) NetworkBehaviour.SerializeObjectsAll(NetworkWriter) NetworkBehaviour.SerializeObjectsDelta(NetworkWriter) NetworkBehaviour.OnNetworkDestroy() NetworkBehaviour.OnStartServer() NetworkBehaviour.OnStartClient() NetworkBehaviour.OnStartLocalPlayer() NetworkBehaviour.OnStartAuthority() NetworkBehaviour.OnStopAuthority() Namespace : Mirror Assembly : doc.dll Syntax public class NetworkProximityChecker : NetworkBehaviour Fields | Improve this Doc View Source ActualCheckMethod Which method to use for checking proximity of players. Physics3D uses 3D physics to determine proximity. Physics2D uses 2D physics to determine proximity. Declaration public NetworkProximityChecker.CheckMethod ActualCheckMethod Field Value Type Description NetworkProximityChecker.CheckMethod | Improve this Doc View Source CastLayers Select only the Player's layer to avoid unnecessary SphereCasts against the Terrain, etc. ~0 means 'Everything'. Declaration public LayerMask CastLayers Field Value Type Description LayerMask | Improve this Doc View Source ForceHidden Flag to force this object to be hidden for players. If this object is a player object, it will not be hidden for that player. Declaration public bool ForceHidden Field Value Type Description System.Boolean | Improve this Doc View Source VisibilityRange The maximim range that objects will be visible at. Declaration public int VisibilityRange Field Value Type Description System.Int32 | Improve this Doc View Source VisibilityUpdateInterval How often (in seconds) that this object should update the list of observers that can see it. Declaration public float VisibilityUpdateInterval Field Value Type Description System.Single Methods | Improve this Doc View Source OnCheckObserver(NetworkConnection) Called when a new player enters Declaration public override bool OnCheckObserver(NetworkConnection newObserver) Parameters Type Name Description NetworkConnection newObserver Returns Type Description System.Boolean Overrides NetworkBehaviour.OnCheckObserver(NetworkConnection) | Improve this Doc View Source OnRebuildObservers(HashSet<NetworkConnection>, Boolean) Called when a new player enters, and when scene changes occur Declaration public override bool OnRebuildObservers(HashSet<NetworkConnection> observers, bool initial) Parameters Type Name Description HashSet < NetworkConnection > observers List of players to be updated. Modify this set with all the players that can see this object System.Boolean initial True if this is the first time the method is called for this object Returns Type Description System.Boolean True if this component calculated the list of observers Overrides NetworkBehaviour.OnRebuildObservers(HashSet<NetworkConnection>, Boolean) | Improve this Doc View Source OnSetHostVisibility(Boolean) Called when hiding and showing objects on the host. On regular clients, objects simply spawn/despawn. On host, objects need to remain in scene because the host is also the server. In that case, we simply hide/show meshes for the host player. Declaration public override void OnSetHostVisibility(bool visible) Parameters Type Name Description System.Boolean visible Overrides NetworkBehaviour.OnSetHostVisibility(Boolean)"
  },
  "api/Mirror.NetworkRoomManager.PendingPlayer.html": {
    "href": "api/Mirror.NetworkRoomManager.PendingPlayer.html",
    "title": "Struct NetworkRoomManager.PendingPlayer",
    "keywords": "Struct NetworkRoomManager.PendingPlayer Namespace : Mirror Assembly : doc.dll Syntax public struct PendingPlayer Fields | Improve this Doc View Source Conn Declaration public NetworkConnection Conn Field Value Type Description NetworkConnection | Improve this Doc View Source RoomPlayer Declaration public GameObject RoomPlayer Field Value Type Description GameObject"
  },
  "api/Mirror.NetworkTime.html": {
    "href": "api/Mirror.NetworkTime.html",
    "title": "Class NetworkTime",
    "keywords": "Class NetworkTime Synchronize time between the server and the clients Inheritance System.Object NetworkTime Namespace : Mirror Assembly : doc.dll Syntax public static class NetworkTime : object Fields | Improve this Doc View Source PingFrequency how often are we sending ping messages used to calculate network time and RTT Declaration public static float PingFrequency Field Value Type Description System.Single | Improve this Doc View Source PingWindowSize average out the last few results from Ping Declaration public static int PingWindowSize Field Value Type Description System.Int32 Properties | Improve this Doc View Source offset Clock difference in seconds between the client and the server Declaration public static double offset { get; } Property Value Type Description System.Double Remarks Note this value is always 0 at the server | Improve this Doc View Source rtt how long in seconds does it take for a message to go to the server and come back Declaration public static double rtt { get; } Property Value Type Description System.Double | Improve this Doc View Source rttSd Measure the standard deviation of rtt the higher the number, the less accurate rtt is Declaration public static double rttSd { get; } Property Value Type Description System.Double | Improve this Doc View Source rttVar measure variance of rtt the higher the number, the less accurate rtt is Declaration public static double rttVar { get; } Property Value Type Description System.Double | Improve this Doc View Source time The time in seconds since the server started. Declaration public static double time { get; } Property Value Type Description System.Double Remarks Note this value works in the client and the server the value is synchronized accross the network with high accuracy You should not cast this down to a float because the it loses too much accuracy when the server is up for a while I measured the accuracy of float and I got this: for the same day, accuracy is better than 1 ms after 1 day, accuracy goes down to 7 ms after 10 days, accuracy is 61 ms after 30 days , accuracy is 238 ms after 60 days, accuracy is 454 ms in other words, if the server is running for 2 months, and you cast down to float, then the time will jump in 0.4s intervals. | Improve this Doc View Source timeSd standard deviation of time. The higher the variance, the less accurate the time is Declaration public static double timeSd { get; } Property Value Type Description System.Double | Improve this Doc View Source timeVar Measurement of the variance of time. The higher the variance, the less accurate the time is Declaration public static double timeVar { get; } Property Value Type Description System.Double Methods | Improve this Doc View Source Reset() Declaration public static void Reset()"
  },
  "api/Mirror.MultiplexTransport.html": {
    "href": "api/Mirror.MultiplexTransport.html",
    "title": "Class MultiplexTransport",
    "keywords": "Class MultiplexTransport Inheritance System.Object Transport MultiplexTransport Inherited Members Transport.activeTransport Transport.OnClientConnected Transport.OnClientDataReceived Transport.OnClientError Transport.OnClientDisconnected Transport.OnServerConnected Transport.OnServerDataReceived Transport.OnServerError Transport.OnServerDisconnected Transport.Update() Transport.OnApplicationQuit() Namespace : Mirror Assembly : doc.dll Syntax public class MultiplexTransport : Transport Fields | Improve this Doc View Source transports Declaration public Transport[] transports Field Value Type Description Transport [] Methods | Improve this Doc View Source Available() Declaration public override bool Available() Returns Type Description System.Boolean Overrides Transport.Available() | Improve this Doc View Source Awake() Declaration public void Awake() | Improve this Doc View Source ClientConnect(String) Declaration public override void ClientConnect(string address) Parameters Type Name Description System.String address Overrides Transport.ClientConnect(String) | Improve this Doc View Source ClientConnect(Uri) Declaration public override void ClientConnect(Uri uri) Parameters Type Name Description Uri uri Overrides Transport.ClientConnect(Uri) | Improve this Doc View Source ClientConnected() Declaration public override bool ClientConnected() Returns Type Description System.Boolean Overrides Transport.ClientConnected() | Improve this Doc View Source ClientDisconnect() Declaration public override void ClientDisconnect() Overrides Transport.ClientDisconnect() | Improve this Doc View Source ClientSend(Int32, ArraySegment<Byte>) Declaration public override bool ClientSend(int channelId, ArraySegment<byte> segment) Parameters Type Name Description System.Int32 channelId ArraySegment < System.Byte > segment Returns Type Description System.Boolean Overrides Transport.ClientSend(Int32, ArraySegment<Byte>) | Improve this Doc View Source GetMaxPacketSize(Int32) Declaration public override int GetMaxPacketSize(int channelId = 0) Parameters Type Name Description System.Int32 channelId Returns Type Description System.Int32 Overrides Transport.GetMaxPacketSize(Int32) | Improve this Doc View Source ServerActive() Declaration public override bool ServerActive() Returns Type Description System.Boolean Overrides Transport.ServerActive() | Improve this Doc View Source ServerDisconnect(Int32) Declaration public override bool ServerDisconnect(int connectionId) Parameters Type Name Description System.Int32 connectionId Returns Type Description System.Boolean Overrides Transport.ServerDisconnect(Int32) | Improve this Doc View Source ServerGetClientAddress(Int32) Declaration public override string ServerGetClientAddress(int connectionId) Parameters Type Name Description System.Int32 connectionId Returns Type Description System.String Overrides Transport.ServerGetClientAddress(Int32) | Improve this Doc View Source ServerSend(List<Int32>, Int32, ArraySegment<Byte>) Declaration public override bool ServerSend(List<int> connectionIds, int channelId, ArraySegment<byte> segment) Parameters Type Name Description List < System.Int32 > connectionIds System.Int32 channelId ArraySegment < System.Byte > segment Returns Type Description System.Boolean Overrides Transport.ServerSend(List<Int32>, Int32, ArraySegment<Byte>) | Improve this Doc View Source ServerStart() Declaration public override void ServerStart() Overrides Transport.ServerStart() | Improve this Doc View Source ServerStop() Declaration public override void ServerStop() Overrides Transport.ServerStop() | Improve this Doc View Source Shutdown() Declaration public override void Shutdown() Overrides Transport.Shutdown() | Improve this Doc View Source ToString() Declaration public override string ToString() Returns Type Description System.String"
  },
  "api/Mirror.SyncList-1.html": {
    "href": "api/Mirror.SyncList-1.html",
    "title": "Class SyncList<T>",
    "keywords": "Class SyncList<T> Inheritance System.Object SyncList<T> SyncListBool SyncListFloat SyncListInt SyncListString SyncListUInt Implements IReadOnlyList <T> ISyncObject Namespace : Mirror Assembly : doc.dll Syntax public abstract class SyncList<T> : IList<T>, IReadOnlyList<T>, ISyncObject Type Parameters Name Description T Constructors | Improve this Doc View Source SyncList(IEqualityComparer<T>) Declaration protected SyncList(IEqualityComparer<T> comparer = null) Parameters Type Name Description IEqualityComparer <T> comparer | Improve this Doc View Source SyncList(IList<T>, IEqualityComparer<T>) Declaration protected SyncList(IList<T> objects, IEqualityComparer<T> comparer = null) Parameters Type Name Description IList <T> objects IEqualityComparer <T> comparer Properties | Improve this Doc View Source Count Declaration public int Count { get; } Property Value Type Description System.Int32 | Improve this Doc View Source IsDirty Declaration public bool IsDirty { get; } Property Value Type Description System.Boolean | Improve this Doc View Source IsReadOnly Declaration public bool IsReadOnly { get; } Property Value Type Description System.Boolean | Improve this Doc View Source Item[Int32] Declaration public T this[int i] { get; set; } Parameters Type Name Description System.Int32 i Property Value Type Description T Methods | Improve this Doc View Source Add(T) Declaration public void Add(T item) Parameters Type Name Description T item | Improve this Doc View Source Clear() Declaration public void Clear() | Improve this Doc View Source Contains(T) Declaration public bool Contains(T item) Parameters Type Name Description T item Returns Type Description System.Boolean | Improve this Doc View Source CopyTo(T[], Int32) Declaration public void CopyTo(T[] array, int index) Parameters Type Name Description T[] array System.Int32 index | Improve this Doc View Source DeserializeItem(NetworkReader) Declaration protected virtual T DeserializeItem(NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description T | Improve this Doc View Source FindIndex(Predicate<T>) Declaration public int FindIndex(Predicate<T> match) Parameters Type Name Description Predicate <T> match Returns Type Description System.Int32 | Improve this Doc View Source Flush() Declaration public void Flush() | Improve this Doc View Source GetEnumerator() Declaration public SyncList<T>.Enumerator GetEnumerator() Returns Type Description SyncList.Enumerator <> | Improve this Doc View Source IndexOf(T) Declaration public int IndexOf(T item) Parameters Type Name Description T item Returns Type Description System.Int32 | Improve this Doc View Source Insert(Int32, T) Declaration public void Insert(int index, T item) Parameters Type Name Description System.Int32 index T item | Improve this Doc View Source OnDeserializeAll(NetworkReader) Declaration public void OnDeserializeAll(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source OnDeserializeDelta(NetworkReader) Declaration public void OnDeserializeDelta(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source OnSerializeAll(NetworkWriter) Declaration public void OnSerializeAll(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer | Improve this Doc View Source OnSerializeDelta(NetworkWriter) Declaration public void OnSerializeDelta(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer | Improve this Doc View Source Remove(T) Declaration public bool Remove(T item) Parameters Type Name Description T item Returns Type Description System.Boolean | Improve this Doc View Source RemoveAt(Int32) Declaration public void RemoveAt(int index) Parameters Type Name Description System.Int32 index | Improve this Doc View Source SerializeItem(NetworkWriter, T) Declaration protected virtual void SerializeItem(NetworkWriter writer, T item) Parameters Type Name Description NetworkWriter writer T item Events | Improve this Doc View Source Callback Declaration public event SyncList<T>.SyncListChanged Callback Event Type Type Description SyncList.SyncListChanged <> Implements IReadOnlyList<> ISyncObject"
  },
  "api/Mirror.SyncListInt.html": {
    "href": "api/Mirror.SyncListInt.html",
    "title": "Class SyncListInt",
    "keywords": "Class SyncListInt Inheritance System.Object SyncList < System.Int32 > SyncListInt Implements IReadOnlyList < System.Int32 > ISyncObject Inherited Members SyncList<Int32>.Count SyncList<Int32>.IsReadOnly SyncList<Int32>.Callback SyncList<Int32>.IsDirty SyncList<Int32>.Flush() SyncList<Int32>.OnSerializeAll(NetworkWriter) SyncList<Int32>.OnSerializeDelta(NetworkWriter) SyncList<Int32>.OnDeserializeAll(NetworkReader) SyncList<Int32>.OnDeserializeDelta(NetworkReader) SyncList<Int32>.Add(Int32) SyncList<Int32>.Clear() SyncList<Int32>.Contains(Int32) SyncList<Int32>.CopyTo(Int32[], Int32) SyncList<Int32>.IndexOf(Int32) SyncList<Int32>.FindIndex(Predicate<Int32>) SyncList<Int32>.Insert(Int32, Int32) SyncList<Int32>.Remove(Int32) SyncList<Int32>.RemoveAt(Int32) SyncList<Int32>.Item[Int32] SyncList<Int32>.GetEnumerator() Namespace : Mirror Assembly : doc.dll Syntax public class SyncListInt : SyncList<int>, IReadOnlyList<int>, ISyncObject Methods | Improve this Doc View Source DeserializeItem(NetworkReader) Declaration protected override int DeserializeItem(NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description System.Int32 Overrides Mirror.SyncList<System.Int32>.DeserializeItem(Mirror.NetworkReader) | Improve this Doc View Source SerializeItem(NetworkWriter, Int32) Declaration protected override void SerializeItem(NetworkWriter writer, int item) Parameters Type Name Description NetworkWriter writer System.Int32 item Overrides Mirror.SyncList<System.Int32>.SerializeItem(Mirror.NetworkWriter, System.Int32) Implements IReadOnlyList<> ISyncObject"
  },
  "api/Mirror.SyncListBool.html": {
    "href": "api/Mirror.SyncListBool.html",
    "title": "Class SyncListBool",
    "keywords": "Class SyncListBool Inheritance System.Object SyncList < System.Boolean > SyncListBool Implements IReadOnlyList < System.Boolean > ISyncObject Inherited Members SyncList<Boolean>.Count SyncList<Boolean>.IsReadOnly SyncList<Boolean>.Callback SyncList<Boolean>.IsDirty SyncList<Boolean>.Flush() SyncList<Boolean>.OnSerializeAll(NetworkWriter) SyncList<Boolean>.OnSerializeDelta(NetworkWriter) SyncList<Boolean>.OnDeserializeAll(NetworkReader) SyncList<Boolean>.OnDeserializeDelta(NetworkReader) SyncList<Boolean>.Add(Boolean) SyncList<Boolean>.Clear() SyncList<Boolean>.Contains(Boolean) SyncList<Boolean>.CopyTo(Boolean[], Int32) SyncList<Boolean>.IndexOf(Boolean) SyncList<Boolean>.FindIndex(Predicate<Boolean>) SyncList<Boolean>.Insert(Int32, Boolean) SyncList<Boolean>.Remove(Boolean) SyncList<Boolean>.RemoveAt(Int32) SyncList<Boolean>.Item[Int32] SyncList<Boolean>.GetEnumerator() Namespace : Mirror Assembly : doc.dll Syntax public class SyncListBool : SyncList<bool>, IReadOnlyList<bool>, ISyncObject Methods | Improve this Doc View Source DeserializeItem(NetworkReader) Declaration protected override bool DeserializeItem(NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description System.Boolean Overrides Mirror.SyncList<System.Boolean>.DeserializeItem(Mirror.NetworkReader) | Improve this Doc View Source SerializeItem(NetworkWriter, Boolean) Declaration protected override void SerializeItem(NetworkWriter writer, bool item) Parameters Type Name Description NetworkWriter writer System.Boolean item Overrides Mirror.SyncList<System.Boolean>.SerializeItem(Mirror.NetworkWriter, System.Boolean) Implements IReadOnlyList<> ISyncObject"
  },
  "api/Mirror.NetworkTransform.html": {
    "href": "api/Mirror.NetworkTransform.html",
    "title": "Class NetworkTransform",
    "keywords": "Class NetworkTransform Inheritance System.Object NetworkBehaviour NetworkTransformBase NetworkTransform Inherited Members NetworkTransformBase.clientAuthority NetworkTransformBase.OnSerialize(NetworkWriter, Boolean) NetworkTransformBase.OnDeserialize(NetworkReader, Boolean) NetworkBehaviour.syncMode NetworkBehaviour.syncInterval NetworkBehaviour.isServer NetworkBehaviour.isClient NetworkBehaviour.isLocalPlayer NetworkBehaviour.isServerOnly NetworkBehaviour.isClientOnly NetworkBehaviour.hasAuthority NetworkBehaviour.netId NetworkBehaviour.connectionToServer NetworkBehaviour.connectionToClient NetworkBehaviour.syncVarDirtyBits NetworkBehaviour.getSyncVarHookGuard(UInt64) NetworkBehaviour.setSyncVarHookGuard(UInt64, Boolean) NetworkBehaviour.syncObjects NetworkBehaviour.netIdentity NetworkBehaviour.ComponentIndex NetworkBehaviour.InitSyncObject(ISyncObject) NetworkBehaviour.SendCommandInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeCommand(Int32, NetworkReader) NetworkBehaviour.SendRPCInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.SendTargetRPCInternal(NetworkConnection, Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeRPC(Int32, NetworkReader) NetworkBehaviour.SendEventInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeSyncEvent(Int32, NetworkReader) NetworkBehaviour.RegisterDelegate(Type, String, MirrorInvokeType, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterCommandDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterRpcDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterEventDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.GetRpcHandler(Int32) NetworkBehaviour.SyncVarGameObjectEqual(GameObject, UInt32) NetworkBehaviour.SetSyncVarGameObject(GameObject, GameObject, UInt64, UInt32) NetworkBehaviour.GetSyncVarGameObject(UInt32, GameObject) NetworkBehaviour.SyncVarNetworkIdentityEqual(NetworkIdentity, UInt32) NetworkBehaviour.SetSyncVarNetworkIdentity(NetworkIdentity, NetworkIdentity, UInt64, UInt32) NetworkBehaviour.GetSyncVarNetworkIdentity(UInt32, NetworkIdentity) NetworkBehaviour.SyncVarEqual<T>(T, T) NetworkBehaviour.SetSyncVar<T>(T, T, UInt64) NetworkBehaviour.SetDirtyBit(UInt64) NetworkBehaviour.ClearAllDirtyBits() NetworkBehaviour.SerializeObjectsAll(NetworkWriter) NetworkBehaviour.SerializeObjectsDelta(NetworkWriter) NetworkBehaviour.OnNetworkDestroy() NetworkBehaviour.OnStartServer() NetworkBehaviour.OnStartClient() NetworkBehaviour.OnStartLocalPlayer() NetworkBehaviour.OnStartAuthority() NetworkBehaviour.OnStopAuthority() NetworkBehaviour.OnRebuildObservers(HashSet<NetworkConnection>, Boolean) NetworkBehaviour.OnSetHostVisibility(Boolean) NetworkBehaviour.OnCheckObserver(NetworkConnection) Namespace : Mirror Assembly : doc.dll Syntax public class NetworkTransform : NetworkTransformBase Properties | Improve this Doc View Source TargetComponent Declaration protected override Transform TargetComponent { get; } Property Value Type Description Transform Overrides NetworkTransformBase.TargetComponent"
  },
  "api/Telepathy.SafeQueue-1.html": {
    "href": "api/Telepathy.SafeQueue-1.html",
    "title": "Class SafeQueue<T>",
    "keywords": "Class SafeQueue<T> Inheritance System.Object SafeQueue<T> Namespace : Telepathy Assembly : doc.dll Syntax public class SafeQueue<T> : object Type Parameters Name Description T Properties | Improve this Doc View Source Count Declaration public int Count { get; } Property Value Type Description System.Int32 Methods | Improve this Doc View Source Clear() Declaration public void Clear() | Improve this Doc View Source Enqueue(T) Declaration public void Enqueue(T item) Parameters Type Name Description T item | Improve this Doc View Source TryDequeue(out T) Declaration public bool TryDequeue(out T result) Parameters Type Name Description T result Returns Type Description System.Boolean | Improve this Doc View Source TryDequeueAll(out T[]) Declaration public bool TryDequeueAll(out T[] result) Parameters Type Name Description T[] result Returns Type Description System.Boolean"
  },
  "api/Mirror.NetworkDiagnostics.html": {
    "href": "api/Mirror.NetworkDiagnostics.html",
    "title": "Class NetworkDiagnostics",
    "keywords": "Class NetworkDiagnostics Provides profiling information from mirror A profiler can subscribe to these events and present the data in a friendly way to the user Inheritance System.Object NetworkDiagnostics Namespace : Mirror Assembly : doc.dll Syntax public static class NetworkDiagnostics : object Events | Improve this Doc View Source InMessageEvent Event that gets raised when Mirror receives a message Subscribe to this if you want to profile the network Declaration public static event Action<NetworkDiagnostics.MessageInfo> InMessageEvent Event Type Type Description Action < NetworkDiagnostics.MessageInfo > | Improve this Doc View Source OutMessageEvent Event that gets raised when Mirror sends a message Subscribe to this if you want to diagnose the network Declaration public static event Action<NetworkDiagnostics.MessageInfo> OutMessageEvent Event Type Type Description Action < NetworkDiagnostics.MessageInfo >"
  },
  "api/Mirror.RemovePlayerMessage.html": {
    "href": "api/Mirror.RemovePlayerMessage.html",
    "title": "Struct RemovePlayerMessage",
    "keywords": "Struct RemovePlayerMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct RemovePlayerMessage : IMessageBase Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.NetworkRoomManager.html": {
    "href": "api/Mirror.NetworkRoomManager.html",
    "title": "Class NetworkRoomManager",
    "keywords": "Class NetworkRoomManager This is a specialized NetworkManager that includes a networked room. Inheritance System.Object NetworkManager NetworkRoomManager Inherited Members NetworkManager.dontDestroyOnLoad NetworkManager.runInBackground NetworkManager.startOnHeadless NetworkManager.serverTickRate NetworkManager.showDebugMessages NetworkManager.offlineScene NetworkManager.onlineScene NetworkManager.transport NetworkManager.networkAddress NetworkManager.maxConnections NetworkManager.numPlayers NetworkManager.authenticator NetworkManager.playerPrefab NetworkManager.autoCreatePlayer NetworkManager.playerSpawnMethod NetworkManager.spawnPrefabs NetworkManager.singleton NetworkManager.isNetworkActive NetworkManager.clientLoadedScene NetworkManager.isHeadless NetworkManager.mode NetworkManager.Awake() NetworkManager.Start() NetworkManager.LateUpdate() NetworkManager.StartServer() NetworkManager.StartClient() NetworkManager.StartClient(Uri) NetworkManager.StartHost() NetworkManager.StopHost() NetworkManager.StopServer() NetworkManager.StopClient() NetworkManager.OnApplicationQuit() NetworkManager.ConfigureServerFrameRate() NetworkManager.Shutdown() NetworkManager.OnDestroy() NetworkManager.networkSceneName NetworkManager.loadingSceneAsync NetworkManager.startPositionIndex NetworkManager.startPositions NetworkManager.RegisterStartPosition(Transform) NetworkManager.UnRegisterStartPosition(Transform) NetworkManager.OnServerAddPlayer(NetworkConnection, AddPlayerMessage) NetworkManager.GetStartPosition() NetworkManager.OnServerRemovePlayer(NetworkConnection, NetworkIdentity) NetworkManager.OnServerError(NetworkConnection, Int32) NetworkManager.OnServerChangeScene(String) NetworkManager.OnClientError(NetworkConnection, Int32) NetworkManager.OnClientNotReady(NetworkConnection) NetworkManager.OnClientChangeScene(String, SceneOperation, Boolean) Namespace : Mirror Assembly : doc.dll Syntax public class NetworkRoomManager : NetworkManager Remarks The room has slots that track the joined players, and a maximum player count that is enforced. It requires that the NetworkRoomPlayer component be on the room player objects. NetworkRoomManager is derived from NetworkManager, and so it implements many of the virtual functions provided by the NetworkManager class. To avoid accidentally replacing functionality of the NetworkRoomManager, there are new virtual functions on the NetworkRoomManager that begin with \"OnRoom\". These should be used on classes derived from NetworkRoomManager instead of the virtual functions on NetworkManager. The OnRoom*() functions have empty implementations on the NetworkRoomManager base class, so the base class functions do not have to be called. Fields | Improve this Doc View Source AllPlayersReady True when all players have submitted a Ready message Declaration public bool AllPlayersReady Field Value Type Description System.Boolean | Improve this Doc View Source GameplayScene The scene to use for the playing the game from the room. This is similar to the onlineScene of the NetworkManager. Declaration public string GameplayScene Field Value Type Description System.String | Improve this Doc View Source PendingPlayers List of players that are in the Room Declaration public List<NetworkRoomManager.PendingPlayer> PendingPlayers Field Value Type Description List < NetworkRoomManager.PendingPlayer > | Improve this Doc View Source RoomScene The scene to use for the room. This is similar to the offlineScene of the NetworkManager. Declaration public string RoomScene Field Value Type Description System.String | Improve this Doc View Source RoomSlots These slots track players that enter the room. The slotId on players is global to the game - across all players. Declaration public List<NetworkRoomPlayer> RoomSlots Field Value Type Description List < NetworkRoomPlayer > Methods | Improve this Doc View Source CheckReadyToBegin() CheckReadyToBegin checks all of the players in the room to see if their readyToBegin flag is set. If all of the players are ready, then the server switches from the RoomScene to the PlayScene - essentially starting the game. This is called automatically in response to NetworkRoomPlayer.SendReadyToBeginMessage(). Declaration public void CheckReadyToBegin() | Improve this Doc View Source OnClientConnect(NetworkConnection) Called on the client when connected to a server. The default implementation of this function sets the client as ready and adds a player. Override the function to dictate what happens when the client connects. Declaration public override void OnClientConnect(NetworkConnection conn) Parameters Type Name Description NetworkConnection conn Connection to the server. Overrides NetworkManager.OnClientConnect(NetworkConnection) | Improve this Doc View Source OnClientDisconnect(NetworkConnection) Called on clients when disconnected from a server. This is called on the client when it disconnects from the server. Override this function to decide what happens when the client disconnects. Declaration public override void OnClientDisconnect(NetworkConnection conn) Parameters Type Name Description NetworkConnection conn Connection to the server. Overrides NetworkManager.OnClientDisconnect(NetworkConnection) | Improve this Doc View Source OnClientSceneChanged(NetworkConnection) Called on clients when a scene has completed loaded, when the scene load was initiated by the server. Scene changes can cause player objects to be destroyed. The default implementation of OnClientSceneChanged in the NetworkManager is to add a player object for the connection if no player object exists. Declaration public override void OnClientSceneChanged(NetworkConnection conn) Parameters Type Name Description NetworkConnection conn Connection of the client Overrides NetworkManager.OnClientSceneChanged(NetworkConnection) | Improve this Doc View Source OnGUI() virtual so inheriting classes can roll their own Declaration public virtual void OnGUI() | Improve this Doc View Source OnRoomClientAddPlayerFailed() Called on the client when adding a player to the room fails. This could be because the room is full, or the connection is not allowed to have more players. Declaration public virtual void OnRoomClientAddPlayerFailed() | Improve this Doc View Source OnRoomClientConnect(NetworkConnection) This is called on the client when it connects to server. Declaration public virtual void OnRoomClientConnect(NetworkConnection conn) Parameters Type Name Description NetworkConnection conn The connection that connected. | Improve this Doc View Source OnRoomClientDisconnect(NetworkConnection) This is called on the client when disconnected from a server. Declaration public virtual void OnRoomClientDisconnect(NetworkConnection conn) Parameters Type Name Description NetworkConnection conn The connection that disconnected. | Improve this Doc View Source OnRoomClientEnter() This is a hook to allow custom behaviour when the game client enters the room. Declaration public virtual void OnRoomClientEnter() | Improve this Doc View Source OnRoomClientExit() This is a hook to allow custom behaviour when the game client exits the room. Declaration public virtual void OnRoomClientExit() | Improve this Doc View Source OnRoomClientSceneChanged(NetworkConnection) This is called on the client when the client is finished loading a new networked scene. Declaration public virtual void OnRoomClientSceneChanged(NetworkConnection conn) Parameters Type Name Description NetworkConnection conn The connection that finished loading a new networked scene. | Improve this Doc View Source OnRoomServerConnect(NetworkConnection) This is called on the server when a new client connects to the server. Declaration public virtual void OnRoomServerConnect(NetworkConnection conn) Parameters Type Name Description NetworkConnection conn The new connection. | Improve this Doc View Source OnRoomServerCreateGamePlayer(NetworkConnection, GameObject) This allows customization of the creation of the GamePlayer object on the server. By default the gamePlayerPrefab is used to create the game-player, but this function allows that behaviour to be customized. The object returned from the function will be used to replace the room-player on the connection. Declaration public virtual GameObject OnRoomServerCreateGamePlayer(NetworkConnection conn, GameObject roomPlayer) Parameters Type Name Description NetworkConnection conn The connection the player object is for. GameObject roomPlayer The room player object for this connection. Returns Type Description GameObject A new GamePlayer object. | Improve this Doc View Source OnRoomServerCreateRoomPlayer(NetworkConnection) This allows customization of the creation of the room-player object on the server. By default the roomPlayerPrefab is used to create the room-player, but this function allows that behaviour to be customized. Declaration public virtual GameObject OnRoomServerCreateRoomPlayer(NetworkConnection conn) Parameters Type Name Description NetworkConnection conn The connection the player object is for. Returns Type Description GameObject The new room-player object. | Improve this Doc View Source OnRoomServerDisconnect(NetworkConnection) This is called on the server when a client disconnects. Declaration public virtual void OnRoomServerDisconnect(NetworkConnection conn) Parameters Type Name Description NetworkConnection conn The connection that disconnected. | Improve this Doc View Source OnRoomServerPlayersReady() This is called on the server when all the players in the room are ready. The default implementation of this function uses ServerChangeScene() to switch to the game player scene. By implementing this callback you can customize what happens when all the players in the room are ready, such as adding a countdown or a confirmation for a group leader. Declaration public virtual void OnRoomServerPlayersReady() | Improve this Doc View Source OnRoomServerSceneChanged(String) This is called on the server when a networked scene finishes loading. Declaration public virtual void OnRoomServerSceneChanged(string sceneName) Parameters Type Name Description System.String sceneName Name of the new scene. | Improve this Doc View Source OnRoomServerSceneLoadedForPlayer(GameObject, GameObject) This is called on the server when it is told that a client has finished switching from the room scene to a game player scene. When switching from the room, the room-player is replaced with a game-player object. This callback function gives an opportunity to apply state from the room-player to the game-player object. Declaration public virtual bool OnRoomServerSceneLoadedForPlayer(GameObject roomPlayer, GameObject gamePlayer) Parameters Type Name Description GameObject roomPlayer The room player object. GameObject gamePlayer The game player object. Returns Type Description System.Boolean False to not allow this player to replace the room player. | Improve this Doc View Source OnRoomStartClient() This is called on the client when a client is started. Declaration public virtual void OnRoomStartClient() | Improve this Doc View Source OnRoomStartHost() This is called on the host when a host is started. Declaration public virtual void OnRoomStartHost() | Improve this Doc View Source OnRoomStartServer() This is called on the server when the server is started - including when a host is started. Declaration public virtual void OnRoomStartServer() | Improve this Doc View Source OnRoomStopClient() This is called on the client when the client stops. Declaration public virtual void OnRoomStopClient() | Improve this Doc View Source OnRoomStopHost() This is called on the host when the host is stopped. Declaration public virtual void OnRoomStopHost() | Improve this Doc View Source OnServerAddPlayer(NetworkConnection) Called on the server when a client adds a new player with ClientScene.AddPlayer. The default implementation for this function creates a new player object from the playerPrefab. Declaration public override void OnServerAddPlayer(NetworkConnection conn) Parameters Type Name Description NetworkConnection conn Connection from client. Overrides NetworkManager.OnServerAddPlayer(NetworkConnection) | Improve this Doc View Source OnServerConnect(NetworkConnection) Called on the server when a new client connects. Unity calls this on the Server when a Client connects to the Server. Use an override to tell the NetworkManager what to do when a client connects to the server. Declaration public override void OnServerConnect(NetworkConnection conn) Parameters Type Name Description NetworkConnection conn Connection from client. Overrides NetworkManager.OnServerConnect(NetworkConnection) | Improve this Doc View Source OnServerDisconnect(NetworkConnection) Called on the server when a client disconnects. This is called on the Server when a Client disconnects from the Server. Use an override to decide what should happen when a disconnection is detected. Declaration public override void OnServerDisconnect(NetworkConnection conn) Parameters Type Name Description NetworkConnection conn Connection from client. Overrides NetworkManager.OnServerDisconnect(NetworkConnection) | Improve this Doc View Source OnServerReady(NetworkConnection) Called on the server when a client is ready. The default implementation of this function calls NetworkServer.SetClientReady() to continue the network setup process. Declaration public override void OnServerReady(NetworkConnection conn) Parameters Type Name Description NetworkConnection conn Connection from client. Overrides NetworkManager.OnServerReady(NetworkConnection) | Improve this Doc View Source OnServerSceneChanged(String) Called on the server when a scene is completed loaded, when the scene load was initiated by the server with ServerChangeScene(). Declaration public override void OnServerSceneChanged(string sceneName) Parameters Type Name Description System.String sceneName The name of the new scene. Overrides NetworkManager.OnServerSceneChanged(String) | Improve this Doc View Source OnStartClient() This is invoked when the client is started. Declaration public override void OnStartClient() Overrides NetworkManager.OnStartClient() | Improve this Doc View Source OnStartHost() This is invoked when a host is started. StartHost has multiple signatures, but they all cause this hook to be called. Declaration public override void OnStartHost() Overrides NetworkManager.OnStartHost() | Improve this Doc View Source OnStartServer() This is invoked when a server is started - including when a host is started. StartServer has multiple signatures, but they all cause this hook to be called. Declaration public override void OnStartServer() Overrides NetworkManager.OnStartServer() | Improve this Doc View Source OnStopClient() This is called when a client is stopped. Declaration public override void OnStopClient() Overrides NetworkManager.OnStopClient() | Improve this Doc View Source OnStopHost() This is called when a host is stopped. Declaration public override void OnStopHost() Overrides NetworkManager.OnStopHost() | Improve this Doc View Source OnStopServer() This is called when a server is stopped - including when a host is stopped. Declaration public override void OnStopServer() Overrides NetworkManager.OnStopServer() | Improve this Doc View Source OnValidate() Declaration public override void OnValidate() Overrides NetworkManager.OnValidate() | Improve this Doc View Source ServerChangeScene(String) This causes the server to switch scenes and sets the networkSceneName. Clients that connect to this server will automatically switch to this scene. This is called autmatically if onlineScene or offlineScene are set, but it can be called from user code to switch scenes again while the game is in progress. This automatically sets clients to be not-ready. The clients must call NetworkClient.Ready() again to participate in the new scene. Declaration public override void ServerChangeScene(string sceneName) Parameters Type Name Description System.String sceneName Overrides NetworkManager.ServerChangeScene(String)"
  },
  "api/Mirror.NetworkPongMessage.html": {
    "href": "api/Mirror.NetworkPongMessage.html",
    "title": "Struct NetworkPongMessage",
    "keywords": "Struct NetworkPongMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct NetworkPongMessage : IMessageBase Fields | Improve this Doc View Source clientTime Declaration public double clientTime Field Value Type Description System.Double | Improve this Doc View Source serverTime Declaration public double serverTime Field Value Type Description System.Double Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.Websocket.html": {
    "href": "api/Mirror.Websocket.html",
    "title": "Namespace Mirror.Websocket",
    "keywords": "Namespace Mirror.Websocket Classes Client Server Server.SslConfiguration WebsocketTransport"
  },
  "api/Mirror.StringHash.html": {
    "href": "api/Mirror.StringHash.html",
    "title": "Class StringHash",
    "keywords": "Class StringHash Inheritance System.Object StringHash Namespace : Mirror Assembly : doc.dll Syntax public static class StringHash : object Methods | Improve this Doc View Source GetStableHashCode(String) Declaration public static int GetStableHashCode(this string text) Parameters Type Name Description System.String text Returns Type Description System.Int32"
  },
  "api/Mirror.NetworkBehaviour.Invoker.html": {
    "href": "api/Mirror.NetworkBehaviour.Invoker.html",
    "title": "Class NetworkBehaviour.Invoker",
    "keywords": "Class NetworkBehaviour.Invoker Inheritance System.Object NetworkBehaviour.Invoker Namespace : Mirror Assembly : doc.dll Syntax protected class Invoker : object Fields | Improve this Doc View Source invokeClass Declaration public Type invokeClass Field Value Type Description Type | Improve this Doc View Source invokeFunction Declaration public NetworkBehaviour.CmdDelegate invokeFunction Field Value Type Description NetworkBehaviour.CmdDelegate | Improve this Doc View Source invokeType Declaration public MirrorInvokeType invokeType Field Value Type Description MirrorInvokeType"
  },
  "api/Mirror.ObjectSpawnStartedMessage.html": {
    "href": "api/Mirror.ObjectSpawnStartedMessage.html",
    "title": "Struct ObjectSpawnStartedMessage",
    "keywords": "Struct ObjectSpawnStartedMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct ObjectSpawnStartedMessage : IMessageBase Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.SceneAttribute.html": {
    "href": "api/Mirror.SceneAttribute.html",
    "title": "Class SceneAttribute",
    "keywords": "Class SceneAttribute Converts a string property into a Scene property in the inspector Inheritance System.Object SceneAttribute Namespace : Mirror Assembly : doc.dll Syntax public class SceneAttribute : PropertyAttribute"
  },
  "api/Mirror.ServerDataReceivedEvent.html": {
    "href": "api/Mirror.ServerDataReceivedEvent.html",
    "title": "Class ServerDataReceivedEvent",
    "keywords": "Class ServerDataReceivedEvent Inheritance System.Object ServerDataReceivedEvent Namespace : Mirror Assembly : doc.dll Syntax public class ServerDataReceivedEvent : UnityEvent<int, ArraySegment<byte>, int>"
  },
  "api/Mirror.ExponentialMovingAverage.html": {
    "href": "api/Mirror.ExponentialMovingAverage.html",
    "title": "Class ExponentialMovingAverage",
    "keywords": "Class ExponentialMovingAverage Inheritance System.Object ExponentialMovingAverage Namespace : Mirror Assembly : doc.dll Syntax public class ExponentialMovingAverage : object Constructors | Improve this Doc View Source ExponentialMovingAverage(Int32) Declaration public ExponentialMovingAverage(int n) Parameters Type Name Description System.Int32 n Properties | Improve this Doc View Source Value Declaration public double Value { get; } Property Value Type Description System.Double | Improve this Doc View Source Var Declaration public double Var { get; } Property Value Type Description System.Double Methods | Improve this Doc View Source Add(Double) Declaration public void Add(double newValue) Parameters Type Name Description System.Double newValue"
  },
  "api/Mirror.NetworkReaderExtensions.html": {
    "href": "api/Mirror.NetworkReaderExtensions.html",
    "title": "Class NetworkReaderExtensions",
    "keywords": "Class NetworkReaderExtensions Inheritance System.Object NetworkReaderExtensions Namespace : Mirror Assembly : doc.dll Syntax public static class NetworkReaderExtensions : object Methods | Improve this Doc View Source ReadBoolean(NetworkReader) Declaration public static bool ReadBoolean(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description System.Boolean | Improve this Doc View Source ReadByte(NetworkReader) Declaration public static byte ReadByte(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description System.Byte | Improve this Doc View Source ReadBytes(NetworkReader, Int32) Declaration public static byte[] ReadBytes(this NetworkReader reader, int count) Parameters Type Name Description NetworkReader reader System.Int32 count Returns Type Description System.Byte [] | Improve this Doc View Source ReadBytesAndSize(NetworkReader) Declaration public static byte[] ReadBytesAndSize(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description System.Byte [] | Improve this Doc View Source ReadBytesAndSizeSegment(NetworkReader) Declaration public static ArraySegment<byte> ReadBytesAndSizeSegment(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description ArraySegment < System.Byte > | Improve this Doc View Source ReadChar(NetworkReader) Declaration public static char ReadChar(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description System.Char | Improve this Doc View Source ReadColor(NetworkReader) Declaration public static Color ReadColor(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Color | Improve this Doc View Source ReadColor32(NetworkReader) Declaration public static Color32 ReadColor32(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Color32 | Improve this Doc View Source ReadDecimal(NetworkReader) Declaration public static decimal ReadDecimal(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description System.Decimal | Improve this Doc View Source ReadDouble(NetworkReader) Declaration public static double ReadDouble(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description System.Double | Improve this Doc View Source ReadGameObject(NetworkReader) Declaration public static GameObject ReadGameObject(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description GameObject | Improve this Doc View Source ReadGuid(NetworkReader) Declaration public static Guid ReadGuid(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Guid | Improve this Doc View Source ReadInt16(NetworkReader) Declaration public static short ReadInt16(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description System.Int16 | Improve this Doc View Source ReadInt32(NetworkReader) Declaration public static int ReadInt32(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description System.Int32 | Improve this Doc View Source ReadInt64(NetworkReader) Declaration public static long ReadInt64(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description System.Int64 | Improve this Doc View Source ReadMatrix4x4(NetworkReader) Declaration public static Matrix4x4 ReadMatrix4x4(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Matrix4x4 | Improve this Doc View Source ReadNetworkIdentity(NetworkReader) Declaration public static NetworkIdentity ReadNetworkIdentity(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description NetworkIdentity | Improve this Doc View Source ReadPackedInt32(NetworkReader) Declaration public static int ReadPackedInt32(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description System.Int32 | Improve this Doc View Source ReadPackedInt64(NetworkReader) Declaration public static long ReadPackedInt64(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description System.Int64 | Improve this Doc View Source ReadPackedUInt32(NetworkReader) Declaration public static uint ReadPackedUInt32(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description System.UInt32 | Improve this Doc View Source ReadPackedUInt64(NetworkReader) Declaration public static ulong ReadPackedUInt64(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description System.UInt64 | Improve this Doc View Source ReadPlane(NetworkReader) Declaration public static Plane ReadPlane(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Plane | Improve this Doc View Source ReadQuaternion(NetworkReader) Declaration public static Quaternion ReadQuaternion(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Quaternion | Improve this Doc View Source ReadRay(NetworkReader) Declaration public static Ray ReadRay(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Ray | Improve this Doc View Source ReadRect(NetworkReader) Declaration public static Rect ReadRect(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Rect | Improve this Doc View Source ReadSByte(NetworkReader) Declaration public static sbyte ReadSByte(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description System.SByte | Improve this Doc View Source ReadSingle(NetworkReader) Declaration public static float ReadSingle(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description System.Single | Improve this Doc View Source ReadString(NetworkReader) Declaration public static string ReadString(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description System.String | Improve this Doc View Source ReadTransform(NetworkReader) Declaration public static Transform ReadTransform(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Transform | Improve this Doc View Source ReadUInt16(NetworkReader) Declaration public static ushort ReadUInt16(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description System.UInt16 | Improve this Doc View Source ReadUInt32(NetworkReader) Declaration public static uint ReadUInt32(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description System.UInt32 | Improve this Doc View Source ReadUInt64(NetworkReader) Declaration public static ulong ReadUInt64(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description System.UInt64 | Improve this Doc View Source ReadVector2(NetworkReader) Declaration public static Vector2 ReadVector2(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Vector2 | Improve this Doc View Source ReadVector2Int(NetworkReader) Declaration public static Vector2Int ReadVector2Int(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Vector2Int | Improve this Doc View Source ReadVector3(NetworkReader) Declaration public static Vector3 ReadVector3(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Vector3 | Improve this Doc View Source ReadVector3Int(NetworkReader) Declaration public static Vector3Int ReadVector3Int(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Vector3Int | Improve this Doc View Source ReadVector4(NetworkReader) Declaration public static Vector4 ReadVector4(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Vector4"
  },
  "api/Mirror.SyncIDictionary-2.Operation.html": {
    "href": "api/Mirror.SyncIDictionary-2.Operation.html",
    "title": "Enum SyncIDictionary<TKey, TValue>.Operation",
    "keywords": "Enum SyncIDictionary<TKey, TValue>.Operation Namespace : Mirror Assembly : doc.dll Syntax public enum Operation : byte Fields Name Description OP_ADD OP_CLEAR OP_DIRTY OP_REMOVE OP_SET"
  },
  "api/Mirror.NetworkClient.html": {
    "href": "api/Mirror.NetworkClient.html",
    "title": "Class NetworkClient",
    "keywords": "Class NetworkClient This is a network client class used by the networking system. It contains a NetworkConnection that is used to connect to a network server. The NetworkClient handle connection state, messages handlers, and connection configuration. There can be many NetworkClient instances in a process at a time, but only one that is connected to a game server ( NetworkServer ) that uses spawned objects. NetworkClient has an internal update function where it handles events from the transport layer. This includes asynchronous connect events, disconnect events and incoming data from a server. The NetworkManager has a NetworkClient instance that it uses for games that it starts, but the NetworkClient may be used by itself. Inheritance System.Object NetworkClient Namespace : Mirror Assembly : doc.dll Syntax public static class NetworkClient : object Properties | Improve this Doc View Source active active is true while a client is connecting/connected (= while the network is active) Declaration public static bool active { get; } Property Value Type Description System.Boolean | Improve this Doc View Source connection The NetworkConnection object this client is using. Declaration public static NetworkConnection connection { get; } Property Value Type Description NetworkConnection | Improve this Doc View Source isConnected This gives the current connection status of the client. Declaration public static bool isConnected { get; } Property Value Type Description System.Boolean | Improve this Doc View Source isLocalClient NetworkClient can connect to local server in host mode too Declaration public static bool isLocalClient { get; } Property Value Type Description System.Boolean | Improve this Doc View Source serverIp The IP address of the server that this client is connected to. This will be empty if the client has not connected yet. Declaration public static string serverIp { get; } Property Value Type Description System.String Methods | Improve this Doc View Source Connect(String) Connect client to a NetworkServer instance. Declaration public static void Connect(string address) Parameters Type Name Description System.String address | Improve this Doc View Source Connect(Uri) Connect client to a NetworkServer instance. Declaration public static void Connect(Uri uri) Parameters Type Name Description Uri uri Address of the server to connect to | Improve this Doc View Source Disconnect() Disconnect from server. The disconnect message will be invoked. Declaration public static void Disconnect() | Improve this Doc View Source RegisterHandler<T>(Action<T>, Boolean) Register a handler for a particular message type. There are several system message types which you can add handlers for. You can also add your own message types. Declaration public static void RegisterHandler<T>(Action<T> handler, bool requireAuthentication = true) where T : IMessageBase, new() Parameters Type Name Description Action <T> handler System.Boolean requireAuthentication true if the message requires an authenticated connection Type Parameters Name Description T The message type to unregister. | Improve this Doc View Source RegisterHandler<T>(Action<NetworkConnectionToServer, T>, Boolean) Register a handler for a particular message type. There are several system message types which you can add handlers for. You can also add your own message types. Declaration public static void RegisterHandler<T>(Action<NetworkConnectionToServer, T> handler, bool requireAuthentication = true) where T : IMessageBase, new() Parameters Type Name Description Action < NetworkConnectionToServer , T> handler System.Boolean requireAuthentication true if the message requires an authenticated connection Type Parameters Name Description T The message type to unregister. | Improve this Doc View Source Send<T>(T, Int32) This sends a network message with a message Id to the server. This message is sent on channel zero, which by default is the reliable channel. The message must be an instance of a class derived from MessageBase. The message id passed to Send() is used to identify the handler function to invoke on the server when the message is received. Declaration public static bool Send<T>(T message, int channelId = null) where T : IMessageBase Parameters Type Name Description T message System.Int32 channelId Returns Type Description System.Boolean True if message was sent. Type Parameters Name Description T The message type to unregister. | Improve this Doc View Source Shutdown() Shut down a client. This should be done when a client is no longer going to be used. Declaration public static void Shutdown() | Improve this Doc View Source UnregisterHandler<T>() Unregisters a network message handler. Declaration public static void UnregisterHandler<T>() where T : IMessageBase Type Parameters Name Description T The message type to unregister."
  },
  "api/Mirror.UnityEventInt.html": {
    "href": "api/Mirror.UnityEventInt.html",
    "title": "Class UnityEventInt",
    "keywords": "Class UnityEventInt Inheritance System.Object UnityEventInt Namespace : Mirror Assembly : doc.dll Syntax public class UnityEventInt : UnityEvent<int>"
  },
  "api/Mirror.NetworkConnectionToServer.html": {
    "href": "api/Mirror.NetworkConnectionToServer.html",
    "title": "Class NetworkConnectionToServer",
    "keywords": "Class NetworkConnectionToServer Inheritance System.Object NetworkConnection NetworkConnectionToServer Inherited Members NetworkConnection.connectionId NetworkConnection.isAuthenticated NetworkConnection.authenticationData NetworkConnection.isReady NetworkConnection.lastMessageTime NetworkConnection.identity NetworkConnection.clientOwnedObjects NetworkConnection.logNetworkMessages NetworkConnection.Dispose() NetworkConnection.Dispose(Boolean) NetworkConnection.Send<T>(T, Int32) NetworkConnection.ValidatePacketSize(ArraySegment<Byte>, Int32) NetworkConnection.ToString() NetworkConnection.InvokeHandler<T>(T, Int32) Namespace : Mirror Assembly : doc.dll Syntax public class NetworkConnectionToServer : NetworkConnection Properties | Improve this Doc View Source address Declaration public override string address { get; } Property Value Type Description System.String Overrides NetworkConnection.address Methods | Improve this Doc View Source Disconnect() Disconnects this connection. Declaration public override void Disconnect() Overrides NetworkConnection.Disconnect()"
  },
  "api/Mirror.ClientDataReceivedEvent.html": {
    "href": "api/Mirror.ClientDataReceivedEvent.html",
    "title": "Class ClientDataReceivedEvent",
    "keywords": "Class ClientDataReceivedEvent Inheritance System.Object ClientDataReceivedEvent Namespace : Mirror Assembly : doc.dll Syntax public class ClientDataReceivedEvent : UnityEvent<ArraySegment<byte>, int>"
  },
  "api/Mirror.UnityEventIntException.html": {
    "href": "api/Mirror.UnityEventIntException.html",
    "title": "Class UnityEventIntException",
    "keywords": "Class UnityEventIntException Inheritance System.Object UnityEventIntException Namespace : Mirror Assembly : doc.dll Syntax public class UnityEventIntException : UnityEvent<int, Exception>"
  },
  "api/Mirror.MessageBase.html": {
    "href": "api/Mirror.MessageBase.html",
    "title": "Class MessageBase",
    "keywords": "Class MessageBase Inheritance System.Object MessageBase Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public abstract class MessageBase : object, IMessageBase Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public virtual void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public virtual void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.NetworkWriter.html": {
    "href": "api/Mirror.NetworkWriter.html",
    "title": "Class NetworkWriter",
    "keywords": "Class NetworkWriter Inheritance System.Object NetworkWriter Namespace : Mirror Assembly : doc.dll Syntax public class NetworkWriter : object Fields | Improve this Doc View Source MaxStringLength Declaration public const int MaxStringLength = null Field Value Type Description System.Int32 Properties | Improve this Doc View Source Position Declaration public int Position { get; set; } Property Value Type Description System.Int32 Methods | Improve this Doc View Source SetLength(Int64) Declaration public void SetLength(long value) Parameters Type Name Description System.Int64 value | Improve this Doc View Source ToArray() Declaration public byte[] ToArray() Returns Type Description System.Byte [] | Improve this Doc View Source ToArraySegment() Declaration public ArraySegment<byte> ToArraySegment() Returns Type Description ArraySegment < System.Byte > | Improve this Doc View Source WriteByte(Byte) Declaration public void WriteByte(byte value) Parameters Type Name Description System.Byte value | Improve this Doc View Source WriteBytes(Byte[], Int32, Int32) Declaration public void WriteBytes(byte[] buffer, int offset, int count) Parameters Type Name Description System.Byte [] buffer System.Int32 offset System.Int32 count | Improve this Doc View Source WriteInt32(Int32) Declaration public void WriteInt32(int value) Parameters Type Name Description System.Int32 value | Improve this Doc View Source WriteInt64(Int64) Declaration public void WriteInt64(long value) Parameters Type Name Description System.Int64 value | Improve this Doc View Source WriteUInt32(UInt32) Declaration public void WriteUInt32(uint value) Parameters Type Name Description System.UInt32 value | Improve this Doc View Source WriteUInt64(UInt64) Declaration public void WriteUInt64(ulong value) Parameters Type Name Description System.UInt64 value Extension Methods NetworkWriterExtensions.WriteByte(NetworkWriter, Byte) NetworkWriterExtensions.WriteSByte(NetworkWriter, SByte) NetworkWriterExtensions.WriteChar(NetworkWriter, Char) NetworkWriterExtensions.WriteBoolean(NetworkWriter, Boolean) NetworkWriterExtensions.WriteUInt16(NetworkWriter, UInt16) NetworkWriterExtensions.WriteInt16(NetworkWriter, Int16) NetworkWriterExtensions.WriteSingle(NetworkWriter, Single) NetworkWriterExtensions.WriteDouble(NetworkWriter, Double) NetworkWriterExtensions.WriteDecimal(NetworkWriter, Decimal) NetworkWriterExtensions.WriteString(NetworkWriter, String) NetworkWriterExtensions.WriteBytesAndSize(NetworkWriter, Byte[], Int32, Int32) NetworkWriterExtensions.WriteBytesAndSize(NetworkWriter, Byte[]) NetworkWriterExtensions.WriteBytesAndSizeSegment(NetworkWriter, ArraySegment<Byte>) NetworkWriterExtensions.WritePackedInt32(NetworkWriter, Int32) NetworkWriterExtensions.WritePackedUInt32(NetworkWriter, UInt32) NetworkWriterExtensions.WritePackedInt64(NetworkWriter, Int64) NetworkWriterExtensions.WritePackedUInt64(NetworkWriter, UInt64) NetworkWriterExtensions.WriteVector2(NetworkWriter, Vector2) NetworkWriterExtensions.WriteVector3(NetworkWriter, Vector3) NetworkWriterExtensions.WriteVector4(NetworkWriter, Vector4) NetworkWriterExtensions.WriteVector2Int(NetworkWriter, Vector2Int) NetworkWriterExtensions.WriteVector3Int(NetworkWriter, Vector3Int) NetworkWriterExtensions.WriteColor(NetworkWriter, Color) NetworkWriterExtensions.WriteColor32(NetworkWriter, Color32) NetworkWriterExtensions.WriteQuaternion(NetworkWriter, Quaternion) NetworkWriterExtensions.WriteRect(NetworkWriter, Rect) NetworkWriterExtensions.WritePlane(NetworkWriter, Plane) NetworkWriterExtensions.WriteRay(NetworkWriter, Ray) NetworkWriterExtensions.WriteMatrix4x4(NetworkWriter, Matrix4x4) NetworkWriterExtensions.WriteGuid(NetworkWriter, Guid) NetworkWriterExtensions.WriteNetworkIdentity(NetworkWriter, NetworkIdentity) NetworkWriterExtensions.WriteTransform(NetworkWriter, Transform) NetworkWriterExtensions.WriteGameObject(NetworkWriter, GameObject) NetworkWriterExtensions.Write<T>(NetworkWriter, T)"
  },
  "api/Mirror.NetworkServer.html": {
    "href": "api/Mirror.NetworkServer.html",
    "title": "Class NetworkServer",
    "keywords": "Class NetworkServer The NetworkServer. Inheritance System.Object NetworkServer Namespace : Mirror Assembly : doc.dll Syntax public static class NetworkServer : object Remarks NetworkServer handles remote connections from remote clients via a NetworkServerSimple instance, and also has a local connection for a local client. The NetworkServer is a singleton. It has static convenience functions such as NetworkServer.SendToAll() and NetworkServer.Spawn() which automatically use the singleton instance. The NetworkManager uses the NetworkServer, but it can be used without the NetworkManager. The set of networked objects that have been spawned is managed by NetworkServer. Objects are spawned with NetworkServer.Spawn() which adds them to this set, and makes them be created on clients. Spawned objects are removed automatically when they are destroyed, or than they can be removed from the spawned set by calling NetworkServer.UnSpawn() - this does not destroy the object. There are a number of internal messages used by NetworkServer, these are setup when NetworkServer.Listen() is called. Fields | Improve this Doc View Source connections A list of local connections on the server. Declaration public static Dictionary<int, NetworkConnectionToClient> connections Field Value Type Description Dictionary < System.Int32 , NetworkConnectionToClient > | Improve this Doc View Source dontListen If you enable this, the server will not listen for incoming connections on the regular network port. This can be used if the game is running in host mode and does not want external players to be able to connect - making it like a single-player game. Also this can be useful when using AddExternalConnection(). Declaration public static bool dontListen Field Value Type Description System.Boolean Properties | Improve this Doc View Source active Checks if the server has been started. This will be true after NetworkServer.Listen() has been called. Declaration public static bool active { get; } Property Value Type Description System.Boolean | Improve this Doc View Source localClientActive True is a local client is currently active on the server. This will be true for \"Hosts\" on hosted server games. Declaration public static bool localClientActive { get; } Property Value Type Description System.Boolean | Improve this Doc View Source localConnection The connection to the host mode client (if any). Declaration public static NetworkConnectionToClient localConnection { get; } Property Value Type Description NetworkConnectionToClient Methods | Improve this Doc View Source AddConnection(NetworkConnectionToClient) This accepts a network connection and adds it to the server. This connection will use the callbacks registered with the server. Declaration public static bool AddConnection(NetworkConnectionToClient conn) Parameters Type Name Description NetworkConnectionToClient conn Network connection to add. Returns Type Description System.Boolean True if added. | Improve this Doc View Source AddPlayerForConnection(NetworkConnection, GameObject) When an AddPlayer message handler has received a request from a player, the server calls this to associate the player object with the connection. When a player is added for a connection, the client for that connection is made ready automatically. The player object is automatically spawned, so you do not need to call NetworkServer.Spawn for that object. This function is used for \"adding\" a player, not for \"replacing\" the player on a connection. If there is already a player on this playerControllerId for this connection, this will fail. Declaration public static bool AddPlayerForConnection(NetworkConnection conn, GameObject player) Parameters Type Name Description NetworkConnection conn Connection which is adding the player. GameObject player Player object spawned for the player. Returns Type Description System.Boolean | Improve this Doc View Source AddPlayerForConnection(NetworkConnection, GameObject, Guid) When an AddPlayer message handler has received a request from a player, the server calls this to associate the player object with the connection. When a player is added for a connection, the client for that connection is made ready automatically. The player object is automatically spawned, so you do not need to call NetworkServer.Spawn for that object. This function is used for \"adding\" a player, not for \"replacing\" the player on a connection. If there is already a player on this playerControllerId for this connection, this will fail. Declaration public static bool AddPlayerForConnection(NetworkConnection conn, GameObject player, Guid assetId) Parameters Type Name Description NetworkConnection conn Connection which is adding the player. GameObject player Player object spawned for the player. Guid assetId Returns Type Description System.Boolean | Improve this Doc View Source ClearHandlers() Clear all registered callback handlers. Declaration public static void ClearHandlers() | Improve this Doc View Source Destroy(GameObject) Destroys this object and corresponding objects on all clients. In some cases it is useful to remove an object but not delete it on the server. For that, use NetworkServer.UnSpawn() instead of NetworkServer.Destroy(). Declaration public static void Destroy(GameObject obj) Parameters Type Name Description GameObject obj Game object to destroy. | Improve this Doc View Source DestroyPlayerForConnection(NetworkConnection) This destroys all the player objects associated with a NetworkConnections on a server. This is used when a client disconnects, to remove the players for that client. This also destroys non-player objects that have client authority set for this connection. Declaration public static void DestroyPlayerForConnection(NetworkConnection conn) Parameters Type Name Description NetworkConnection conn The connections object to clean up for. | Improve this Doc View Source DisconnectAll() Disconnect all currently connected clients, including the local connection. This can only be called on the server. Clients will receive the Disconnect message. Declaration public static void DisconnectAll() | Improve this Doc View Source DisconnectAllConnections() Disconnect all currently connected clients except the local connection. This can only be called on the server. Clients will receive the Disconnect message. Declaration public static void DisconnectAllConnections() | Improve this Doc View Source Listen(Int32) Start the server, setting the maximum number of connections. Declaration public static void Listen(int maxConns) Parameters Type Name Description System.Int32 maxConns Maximum number of allowed connections | Improve this Doc View Source RegisterHandler<T>(Action<T>, Boolean) Register a handler for a particular message type. There are several system message types which you can add handlers for. You can also add your own message types. Declaration public static void RegisterHandler<T>(Action<T> handler, bool requireAuthentication = true) where T : IMessageBase, new() Parameters Type Name Description Action <T> handler Function handler which will be invoked for when this message type is received. System.Boolean requireAuthentication True if the message requires an authenticated connection Type Parameters Name Description T Message type | Improve this Doc View Source RegisterHandler<T>(Action<NetworkConnectionToClient, T>, Boolean) Register a handler for a particular message type. There are several system message types which you can add handlers for. You can also add your own message types. Declaration public static void RegisterHandler<T>(Action<NetworkConnectionToClient, T> handler, bool requireAuthentication = true) where T : IMessageBase, new() Parameters Type Name Description Action < NetworkConnectionToClient , T> handler Function handler which will be invoked for when this message type is received. System.Boolean requireAuthentication True if the message requires an authenticated connection Type Parameters Name Description T Message type | Improve this Doc View Source RemoveConnection(Int32) This removes an external connection added with AddExternalConnection(). Declaration public static bool RemoveConnection(int connectionId) Parameters Type Name Description System.Int32 connectionId The id of the connection to remove. Returns Type Description System.Boolean True if the removal succeeded | Improve this Doc View Source ReplacePlayerForConnection(NetworkConnection, GameObject, Guid, Boolean) This replaces the player object for a connection with a different player object. The old player object is not destroyed. If a connection already has a player object, this can be used to replace that object with a different player object. This does NOT change the ready state of the connection, so it can safely be used while changing scenes. Declaration public static bool ReplacePlayerForConnection(NetworkConnection conn, GameObject player, Guid assetId, bool keepAuthority = false) Parameters Type Name Description NetworkConnection conn Connection which is adding the player. GameObject player Player object spawned for the player. Guid assetId System.Boolean keepAuthority Does the previous player remain attached to this connection? Returns Type Description System.Boolean | Improve this Doc View Source ReplacePlayerForConnection(NetworkConnection, GameObject, Boolean) This replaces the player object for a connection with a different player object. The old player object is not destroyed. If a connection already has a player object, this can be used to replace that object with a different player object. This does NOT change the ready state of the connection, so it can safely be used while changing scenes. Declaration public static bool ReplacePlayerForConnection(NetworkConnection conn, GameObject player, bool keepAuthority = false) Parameters Type Name Description NetworkConnection conn Connection which is adding the player. GameObject player Player object spawned for the player. System.Boolean keepAuthority Does the previous player remain attached to this connection? Returns Type Description System.Boolean | Improve this Doc View Source Reset() Reset the NetworkServer singleton. Declaration public static void Reset() | Improve this Doc View Source SendToAll<T>(T, Int32) Send a message structure with the given type number to all connected clients. This applies to clients that are ready and not-ready. Declaration public static bool SendToAll<T>(T msg, int channelId = null) where T : IMessageBase Parameters Type Name Description T msg Message structure. System.Int32 channelId Transport channel to use Returns Type Description System.Boolean Type Parameters Name Description T Message type. | Improve this Doc View Source SendToClientOfPlayer<T>(NetworkIdentity, T) send this message to the player only Declaration public static void SendToClientOfPlayer<T>(NetworkIdentity identity, T msg) where T : IMessageBase Parameters Type Name Description NetworkIdentity identity T msg Type Parameters Name Description T Message type | Improve this Doc View Source SendToReady<T>(NetworkIdentity, T, Boolean, Int32) Send a message structure with the given type number to only clients which are ready. See Networking.NetworkClient.Ready. Declaration public static bool SendToReady<T>(NetworkIdentity identity, T msg, bool includeOwner = true, int channelId = null) where T : IMessageBase Parameters Type Name Description NetworkIdentity identity T msg Message structure. System.Boolean includeOwner Send to observers including self.. System.Int32 channelId Transport channel to use Returns Type Description System.Boolean Type Parameters Name Description T Message type. | Improve this Doc View Source SendToReady<T>(NetworkIdentity, T, Int32) Send a message structure with the given type number to only clients which are ready. See Networking.NetworkClient.Ready. Declaration public static bool SendToReady<T>(NetworkIdentity identity, T msg, int channelId = null) where T : IMessageBase Parameters Type Name Description NetworkIdentity identity T msg Message structure. System.Int32 channelId Transport channel to use Returns Type Description System.Boolean Type Parameters Name Description T Message type. | Improve this Doc View Source SetAllClientsNotReady() Marks all connected clients as no longer ready. All clients will no longer be sent state synchronization updates. The player's clients can call ClientManager.Ready() again to re-enter the ready state. This is useful when switching scenes. Declaration public static void SetAllClientsNotReady() | Improve this Doc View Source SetClientNotReady(NetworkConnection) Sets the client of the connection to be not-ready. Clients that are not ready do not receive spawned objects or state synchronization updates. They client can be made ready again by calling SetClientReady(). Declaration public static void SetClientNotReady(NetworkConnection conn) Parameters Type Name Description NetworkConnection conn The connection of the client to make not ready. | Improve this Doc View Source SetClientReady(NetworkConnection) Sets the client to be ready. When a client has signaled that it is ready, this method tells the server that the client is ready to receive spawned objects and state synchronization updates. This is usually called in a handler for the SYSTEM_READY message. If there is not specific action a game needs to take for this message, relying on the default ready handler function is probably fine, so this call wont be needed. Declaration public static void SetClientReady(NetworkConnection conn) Parameters Type Name Description NetworkConnection conn The connection of the client to make ready. | Improve this Doc View Source Shutdown() This shuts down the server and disconnects all clients. Declaration public static void Shutdown() | Improve this Doc View Source Spawn(GameObject, GameObject) This spawns an object like NetworkServer.Spawn() but also assigns Client Authority to the specified client. This is the same as calling NetworkIdentity.AssignClientAuthority on the spawned object. Declaration public static void Spawn(GameObject obj, GameObject player) Parameters Type Name Description GameObject obj The object to spawn. GameObject player The player object to set Client Authority to. | Improve this Doc View Source Spawn(GameObject, Guid, NetworkConnection) This spawns an object like NetworkServer.Spawn() but also assigns Client Authority to the specified client. This is the same as calling NetworkIdentity.AssignClientAuthority on the spawned object. Declaration public static void Spawn(GameObject obj, Guid assetId, NetworkConnection ownerConnection = null) Parameters Type Name Description GameObject obj The object to spawn. Guid assetId The assetId of the object to spawn. Used for custom spawn handlers. NetworkConnection ownerConnection The connection that has authority over the object | Improve this Doc View Source Spawn(GameObject, NetworkConnection) Spawn the given game object on all clients which are ready. This will cause a new object to be instantiated from the registered prefab, or from a custom spawn function. Declaration public static void Spawn(GameObject obj, NetworkConnection ownerConnection = null) Parameters Type Name Description GameObject obj Game object with NetworkIdentity to spawn. NetworkConnection ownerConnection The connection that has authority over the object | Improve this Doc View Source SpawnObjects() This causes NetworkIdentity objects in a scene to be spawned on a server. NetworkIdentity objects in a scene are disabled by default. Calling SpawnObjects() causes these scene objects to be enabled and spawned. It is like calling NetworkServer.Spawn() for each of them. Declaration public static bool SpawnObjects() Returns Type Description System.Boolean Success if objects where spawned. | Improve this Doc View Source SpawnWithClientAuthority(GameObject, GameObject) Obsolete: Use Spawn(GameObject, GameObject) instead. Declaration public static bool SpawnWithClientAuthority(GameObject obj, GameObject player) Parameters Type Name Description GameObject obj GameObject player Returns Type Description System.Boolean | Improve this Doc View Source SpawnWithClientAuthority(GameObject, Guid, NetworkConnection) Use Spawn(GameObject, Guid, NetworkConnection) instead Declaration public static bool SpawnWithClientAuthority(GameObject obj, Guid assetId, NetworkConnection ownerConnection) Parameters Type Name Description GameObject obj Guid assetId NetworkConnection ownerConnection Returns Type Description System.Boolean | Improve this Doc View Source SpawnWithClientAuthority(GameObject, NetworkConnection) Use Spawn(GameObject, NetworkConnection) instead Declaration public static bool SpawnWithClientAuthority(GameObject obj, NetworkConnection ownerConnection) Parameters Type Name Description GameObject obj NetworkConnection ownerConnection Returns Type Description System.Boolean | Improve this Doc View Source UnregisterHandler<T>() Unregisters a handler for a particular message type. Declaration public static void UnregisterHandler<T>() where T : IMessageBase Type Parameters Name Description T Message type | Improve this Doc View Source UnSpawn(GameObject) This takes an object that has been spawned and un-spawns it. The object will be removed from clients that it was spawned on, or the custom spawn handler function on the client will be called for the object. Unlike when calling NetworkServer.Destroy(), on the server the object will NOT be destroyed. This allows the server to re-use the object, even spawn it again later. Declaration public static void UnSpawn(GameObject obj) Parameters Type Name Description GameObject obj The spawned object to be unspawned."
  },
  "api/Mirror.SyncSet-1.Operation.html": {
    "href": "api/Mirror.SyncSet-1.Operation.html",
    "title": "Enum SyncSet<T>.Operation",
    "keywords": "Enum SyncSet<T>.Operation Namespace : Mirror Assembly : doc.dll Syntax public enum Operation : byte Fields Name Description OP_ADD OP_CLEAR OP_REMOVE"
  },
  "api/Mirror.Tcp.Client.html": {
    "href": "api/Mirror.Tcp.Client.html",
    "title": "Class Client",
    "keywords": "Class Client Inheritance System.Object Common Client Inherited Members Common.BytesToInt(Byte[]) Common.WriteSize(Int32, Byte[]) Common.SendMessage(NetworkStream, ArraySegment<Byte>) Common.SendMessage(NetworkStream, MemoryStream) Common.ReadMessageAsync(Stream) Namespace : Mirror.Tcp Assembly : doc.dll Syntax public class Client : Common Fields | Improve this Doc View Source client Declaration public TcpClient client Field Value Type Description TcpClient | Improve this Doc View Source NoDelay Declaration public bool NoDelay Field Value Type Description System.Boolean Properties | Improve this Doc View Source Connecting Declaration public bool Connecting { get; set; } Property Value Type Description System.Boolean | Improve this Doc View Source IsConnected Declaration public bool IsConnected { get; set; } Property Value Type Description System.Boolean Methods | Improve this Doc View Source Connect(String, Int32) Declaration public Task Connect(string host, int port) Parameters Type Name Description System.String host System.Int32 port Returns Type Description Task | Improve this Doc View Source Disconnect() Declaration public void Disconnect() | Improve this Doc View Source SendAsync(ArraySegment<Byte>) Declaration public Task SendAsync(ArraySegment<byte> data) Parameters Type Name Description ArraySegment < System.Byte > data Returns Type Description Task | Improve this Doc View Source ToString() Declaration public override string ToString() Returns Type Description System.String Events | Improve this Doc View Source Connected Declaration public event Action Connected Event Type Type Description Action | Improve this Doc View Source Disconnected Declaration public event Action Disconnected Event Type Type Description Action | Improve this Doc View Source ReceivedData Declaration public event Action<byte[]> ReceivedData Event Type Type Description Action < System.Byte []> | Improve this Doc View Source ReceivedError Declaration public event Action<Exception> ReceivedError Event Type Type Description Action < Exception >"
  },
  "api/Mirror.SyncList-1.Operation.html": {
    "href": "api/Mirror.SyncList-1.Operation.html",
    "title": "Enum SyncList<T>.Operation",
    "keywords": "Enum SyncList<T>.Operation Namespace : Mirror Assembly : doc.dll Syntax public enum Operation : byte Fields Name Description OP_ADD OP_CLEAR OP_DIRTY OP_INSERT OP_REMOVE OP_REMOVEAT OP_SET"
  },
  "api/Mirror.Version.html": {
    "href": "api/Mirror.Version.html",
    "title": "Enum Version",
    "keywords": "Enum Version Namespace : Mirror Assembly : doc.dll Syntax public enum Version : int Fields Name Description Current"
  },
  "api/Mirror.MirrorInvokeType.html": {
    "href": "api/Mirror.MirrorInvokeType.html",
    "title": "Enum MirrorInvokeType",
    "keywords": "Enum MirrorInvokeType Namespace : Mirror Assembly : doc.dll Syntax public enum MirrorInvokeType : int Fields Name Description ClientRpc Command SyncEvent"
  },
  "api/Telepathy.Server.html": {
    "href": "api/Telepathy.Server.html",
    "title": "Class Server",
    "keywords": "Class Server Inheritance System.Object Common Server Inherited Members Common.receiveQueue Common.ReceiveQueueCount Common.messageQueueSizeWarning Common.GetNextMessage(Message) Common.NoDelay Common.MaxMessageSize Common.SendTimeout Common.SendMessagesBlocking(NetworkStream, Byte[][]) Common.ReadMessageBlocking(NetworkStream, Int32, Byte[]) Common.ReceiveLoop(Int32, TcpClient, ConcurrentQueue<Message>, Int32) Common.SendLoop(Int32, TcpClient, SafeQueue<Byte[]>, ManualResetEvent) Namespace : Telepathy Assembly : doc.dll Syntax public class Server : Common Fields | Improve this Doc View Source listener Declaration public TcpListener listener Field Value Type Description TcpListener Properties | Improve this Doc View Source Active Declaration public bool Active { get; } Property Value Type Description System.Boolean Methods | Improve this Doc View Source Disconnect(Int32) Declaration public bool Disconnect(int connectionId) Parameters Type Name Description System.Int32 connectionId Returns Type Description System.Boolean | Improve this Doc View Source GetClientAddress(Int32) Declaration public string GetClientAddress(int connectionId) Parameters Type Name Description System.Int32 connectionId Returns Type Description System.String | Improve this Doc View Source NextConnectionId() Declaration public int NextConnectionId() Returns Type Description System.Int32 | Improve this Doc View Source Send(Int32, Byte[]) Declaration public bool Send(int connectionId, byte[] data) Parameters Type Name Description System.Int32 connectionId System.Byte [] data Returns Type Description System.Boolean | Improve this Doc View Source Start(Int32) Declaration public bool Start(int port) Parameters Type Name Description System.Int32 port Returns Type Description System.Boolean | Improve this Doc View Source Stop() Declaration public void Stop()"
  },
  "api/Mirror.UnSpawnDelegate.html": {
    "href": "api/Mirror.UnSpawnDelegate.html",
    "title": "Delegate UnSpawnDelegate",
    "keywords": "Delegate UnSpawnDelegate Namespace : Mirror Assembly : doc.dll Syntax public delegate void UnSpawnDelegate(GameObject spawned); Parameters Type Name Description GameObject spawned"
  },
  "api/Mirror.NetworkIdentity.html": {
    "href": "api/Mirror.NetworkIdentity.html",
    "title": "Class NetworkIdentity",
    "keywords": "Class NetworkIdentity The NetworkIdentity identifies objects across the network, between server and clients. Its primary data is a NetworkInstanceId which is allocated by the server and then set on clients. This is used in network communications to be able to lookup game objects on different machines. Inheritance System.Object NetworkIdentity Namespace : Mirror Assembly : doc.dll Syntax public sealed class NetworkIdentity : MonoBehaviour Remarks The NetworkIdentity is used to synchronize information in the object with the network. Only the server should create instances of objects which have NetworkIdentity as otherwise they will not be properly connected to the system. For complex objects with a hierarchy of subcomponents, the NetworkIdentity must be on the root of the hierarchy. It is not supported to have multiple NetworkIdentity components on subcomponents of a hierarchy. NetworkBehaviour scripts require a NetworkIdentity on the game object to be able to function. The NetworkIdentity manages the dirty state of the NetworkBehaviours of the object. When it discovers that NetworkBehaviours are dirty, it causes an update packet to be created and sent to clients. The flow for serialization updates managed by the NetworkIdentity is: * Each NetworkBehaviour has a dirty mask. This mask is available inside OnSerialize as syncVarDirtyBits * Each SyncVar in a NetworkBehaviour script is assigned a bit in the dirty mask. * Changing the value of SyncVars causes the bit for that SyncVar to be set in the dirty mask * Alternatively, calling SetDirtyBit() writes directly to the dirty mask * NetworkIdentity objects are checked on the server as part of it's update loop * If any NetworkBehaviours on a NetworkIdentity are dirty, then an UpdateVars packet is created for that object * The UpdateVars packet is populated by calling OnSerialize on each NetworkBehaviour on the object * NetworkBehaviours that are NOT dirty write a zero to the packet for their dirty bits * NetworkBehaviours that are dirty write their dirty mask, then the values for the SyncVars that have changed * If OnSerialize returns true for a NetworkBehaviour, the dirty mask is reset for that NetworkBehaviour, so it will not send again until its value changes. * The UpdateVars packet is sent to ready clients that are observing the object On the client: * an UpdateVars packet is received for an object * The OnDeserialize function is called for each NetworkBehaviour script on the object * Each NetworkBehaviour script on the object reads a dirty mask. * If the dirty mask for a NetworkBehaviour is zero, the OnDeserialize functions returns without reading any more * If the dirty mask is non-zero value, then the OnDeserialize function reads the values for the SyncVars that correspond to the dirty bits that are set * If there are SyncVar hook functions, those are invoked with the value read from the stream. Fields | Improve this Doc View Source clientAuthorityCallback A callback that can be populated to be notified when the client-authority state of objects changes. Whenever an object is spawned using SpawnWithClientAuthority, or the client authority status of an object is changed with AssignClientAuthority or RemoveClientAuthority, then this callback will be invoked. This callback is only invoked on the server. Declaration public static NetworkIdentity.ClientAuthorityCallback clientAuthorityCallback Field Value Type Description NetworkIdentity.ClientAuthorityCallback | Improve this Doc View Source observers The set of network connections (players) that can see this object. null until OnStartServer was called. this is necessary for SendTo* to work properly in server-only mode. Declaration public Dictionary<int, NetworkConnection> observers Field Value Type Description Dictionary < System.Int32 , NetworkConnection > | Improve this Doc View Source serverOnly Flag to make this object only exist when the game is running as a server (or host). Declaration public bool serverOnly Field Value Type Description System.Boolean | Improve this Doc View Source spawned All spawned NetworkIdentities by netId. Available on server and client. Declaration public static readonly Dictionary<uint, NetworkIdentity> spawned Field Value Type Description Dictionary < System.UInt32 , NetworkIdentity > Properties | Improve this Doc View Source assetId Unique identifier used to find the source assets when server spawns the on clients. Declaration public Guid assetId { get; } Property Value Type Description Guid | Improve this Doc View Source clientAuthorityOwner Obsolete: Use connectionToClient instead Declaration public NetworkConnectionToClient clientAuthorityOwner { get; } Property Value Type Description NetworkConnectionToClient | Improve this Doc View Source connectionToClient The NetworkConnection associated with this NetworkIdentity This is valid for player and other owned objects in the server. Use it to return details such as the connection's identity, IP address and ready status. Declaration public NetworkConnectionToClient connectionToClient { get; } Property Value Type Description NetworkConnectionToClient | Improve this Doc View Source connectionToServer The NetworkConnection associated with this NetworkIdentity. This is only valid for player objects on a local client. Declaration public NetworkConnection connectionToServer { get; } Property Value Type Description NetworkConnection | Improve this Doc View Source hasAuthority This returns true if this object is the authoritative player object on the client. This value is determined at runtime. For most objects, authority is held by the server. For objects that had their authority set by AssignClientAuthority on the server, this will be true on the client that owns the object. NOT on other clients. Declaration public bool hasAuthority { get; } Property Value Type Description System.Boolean | Improve this Doc View Source isClient Returns true if running as a client and this object was spawned by a server. Declaration public bool isClient { get; } Property Value Type Description System.Boolean | Improve this Doc View Source isLocalPlayer This returns true if this object is the one that represents the player on the local machine. This is set when the server has spawned an object for this particular client. Declaration public bool isLocalPlayer { get; } Property Value Type Description System.Boolean | Improve this Doc View Source isServer Returns true if NetworkServer.active and server is not stopped. Declaration public bool isServer { get; } Property Value Type Description System.Boolean | Improve this Doc View Source netId Unique identifier for this particular object instance, used for tracking objects between networked clients and the server. This is a unique identifier for this particular GameObject instance. Use it to track GameObjects between networked clients and the server. Declaration public uint netId { get; } Property Value Type Description System.UInt32 | Improve this Doc View Source NetworkBehaviours Declaration public NetworkBehaviour[] NetworkBehaviours { get; } Property Value Type Description NetworkBehaviour [] | Improve this Doc View Source sceneId A unique identifier for NetworkIdentity objects within a scene. This is used for spawning scene objects on clients. Declaration public ulong sceneId { get; } Property Value Type Description System.UInt64 Methods | Improve this Doc View Source AssignClientAuthority(NetworkConnection) Assign control of an object to a client via the client's NetworkConnection This causes hasAuthority to be set on the client that owns the object, and NetworkBehaviour.OnStartAuthority will be called on that client. This object then will be in the NetworkConnection.clientOwnedObjects list for the connection. Authority can be removed with RemoveClientAuthority. Only one client can own an object at any time. This does not need to be called for player objects, as their authority is setup automatically. Declaration public bool AssignClientAuthority(NetworkConnection conn) Parameters Type Name Description NetworkConnection conn The connection of the client to assign authority to. Returns Type Description System.Boolean True if authority was assigned. | Improve this Doc View Source GetSceneIdenity(UInt64) Declaration public static NetworkIdentity GetSceneIdenity(ulong id) Parameters Type Name Description System.UInt64 id Returns Type Description NetworkIdentity | Improve this Doc View Source RebuildObservers(Boolean) This causes the set of players that can see this object to be rebuild. The OnRebuildObservers callback function will be invoked on each NetworkBehaviour. Declaration public void RebuildObservers(bool initialize) Parameters Type Name Description System.Boolean initialize True if this is the first time. | Improve this Doc View Source RemoveClientAuthority() Removes ownership for an object. This applies to objects that had authority set by AssignClientAuthority, or Spawn(GameObject, NetworkConnection) with a NetworkConnection parameter included. Authority cannot be removed for player objects. Declaration public void RemoveClientAuthority() | Improve this Doc View Source ResetNextNetworkId() Resets nextNetworkId = 1 Declaration public static void ResetNextNetworkId()"
  },
  "api/Mirror.SpawnDelegate.html": {
    "href": "api/Mirror.SpawnDelegate.html",
    "title": "Delegate SpawnDelegate",
    "keywords": "Delegate SpawnDelegate Namespace : Mirror Assembly : doc.dll Syntax public delegate GameObject SpawnDelegate(Vector3 position, Guid assetId); Parameters Type Name Description Vector3 position Guid assetId Returns Type Description GameObject"
  },
  "api/Mirror.SceneMessage.html": {
    "href": "api/Mirror.SceneMessage.html",
    "title": "Struct SceneMessage",
    "keywords": "Struct SceneMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct SceneMessage : IMessageBase Fields | Improve this Doc View Source customHandling Declaration public bool customHandling Field Value Type Description System.Boolean | Improve this Doc View Source sceneName Declaration public string sceneName Field Value Type Description System.String | Improve this Doc View Source sceneOperation Declaration public SceneOperation sceneOperation Field Value Type Description SceneOperation Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Telepathy.Logger.html": {
    "href": "api/Telepathy.Logger.html",
    "title": "Class Logger",
    "keywords": "Class Logger Inheritance System.Object Logger Namespace : Telepathy Assembly : doc.dll Syntax public static class Logger : object Fields | Improve this Doc View Source Log Declaration public static Action<string> Log Field Value Type Description Action < System.String > | Improve this Doc View Source LogError Declaration public static Action<string> LogError Field Value Type Description Action < System.String > | Improve this Doc View Source LogWarning Declaration public static Action<string> LogWarning Field Value Type Description Action < System.String >"
  },
  "api/Mirror.MessagePacker.html": {
    "href": "api/Mirror.MessagePacker.html",
    "title": "Class MessagePacker",
    "keywords": "Class MessagePacker Inheritance System.Object MessagePacker Namespace : Mirror Assembly : doc.dll Syntax public static class MessagePacker : object Methods | Improve this Doc View Source GetId(Type) Declaration public static int GetId(Type type) Parameters Type Name Description Type type Returns Type Description System.Int32 | Improve this Doc View Source GetId<T>() Declaration public static int GetId<T>() where T : IMessageBase Returns Type Description System.Int32 Type Parameters Name Description T | Improve this Doc View Source Pack<T>(T) Declaration public static byte[] Pack<T>(T message) where T : IMessageBase Parameters Type Name Description T message Returns Type Description System.Byte [] Type Parameters Name Description T | Improve this Doc View Source Pack<T>(T, NetworkWriter) Declaration public static void Pack<T>(T message, NetworkWriter writer) where T : IMessageBase Parameters Type Name Description T message NetworkWriter writer Type Parameters Name Description T | Improve this Doc View Source Unpack<T>(ArraySegment<Byte>) Declaration public static T Unpack<T>(ArraySegment<byte> data) where T : IMessageBase, new() Parameters Type Name Description ArraySegment < System.Byte > data Returns Type Description T Type Parameters Name Description T | Improve this Doc View Source Unpack<T>(Byte[]) Declaration public static T Unpack<T>(byte[] data) where T : IMessageBase, new() Parameters Type Name Description System.Byte [] data Returns Type Description T Type Parameters Name Description T | Improve this Doc View Source UnpackMessage(NetworkReader, out Int32) Declaration public static bool UnpackMessage(NetworkReader messageReader, out int msgType) Parameters Type Name Description NetworkReader messageReader System.Int32 msgType Returns Type Description System.Boolean"
  },
  "api/Mirror.SyncIDictionary-2.SyncDictionaryChanged.html": {
    "href": "api/Mirror.SyncIDictionary-2.SyncDictionaryChanged.html",
    "title": "Delegate SyncIDictionary<TKey, TValue>.SyncDictionaryChanged",
    "keywords": "Delegate SyncIDictionary<TKey, TValue>.SyncDictionaryChanged Namespace : Mirror Assembly : doc.dll Syntax public delegate void SyncDictionaryChanged(SyncIDictionary<TKey, TValue>.Operation op, TKey key, TValue item); Parameters Type Name Description SyncIDictionary.Operation <> op TKey key TValue item"
  },
  "api/Mirror.LLAPITransport.html": {
    "href": "api/Mirror.LLAPITransport.html",
    "title": "Class LLAPITransport",
    "keywords": "Class LLAPITransport Inheritance System.Object Transport LLAPITransport Inherited Members Transport.activeTransport Transport.OnClientConnected Transport.OnClientDataReceived Transport.OnClientError Transport.OnClientDisconnected Transport.OnServerConnected Transport.OnServerDataReceived Transport.OnServerError Transport.OnServerDisconnected Transport.Update() Transport.OnApplicationQuit() Namespace : Mirror Assembly : doc.dll Syntax public class LLAPITransport : Transport Fields | Improve this Doc View Source connectionConfig Declaration public ConnectionConfig connectionConfig Field Value Type Description ConnectionConfig | Improve this Doc View Source globalConfig Declaration public GlobalConfig globalConfig Field Value Type Description GlobalConfig | Improve this Doc View Source port Declaration public ushort port Field Value Type Description System.UInt16 | Improve this Doc View Source Scheme Declaration public const string Scheme = null Field Value Type Description System.String | Improve this Doc View Source useWebsockets Declaration public bool useWebsockets Field Value Type Description System.Boolean Methods | Improve this Doc View Source Available() Declaration public override bool Available() Returns Type Description System.Boolean Overrides Transport.Available() | Improve this Doc View Source ClientConnect(String) Declaration public override void ClientConnect(string address) Parameters Type Name Description System.String address Overrides Transport.ClientConnect(String) | Improve this Doc View Source ClientConnect(Uri) Declaration public override void ClientConnect(Uri uri) Parameters Type Name Description Uri uri Overrides Transport.ClientConnect(Uri) | Improve this Doc View Source ClientConnected() Declaration public override bool ClientConnected() Returns Type Description System.Boolean Overrides Transport.ClientConnected() | Improve this Doc View Source ClientDisconnect() Declaration public override void ClientDisconnect() Overrides Transport.ClientDisconnect() | Improve this Doc View Source ClientGetAddress() Declaration public string ClientGetAddress() Returns Type Description System.String | Improve this Doc View Source ClientSend(Int32, ArraySegment<Byte>) Declaration public override bool ClientSend(int channelId, ArraySegment<byte> segment) Parameters Type Name Description System.Int32 channelId ArraySegment < System.Byte > segment Returns Type Description System.Boolean Overrides Transport.ClientSend(Int32, ArraySegment<Byte>) | Improve this Doc View Source GetMaxPacketSize(Int32) Declaration public override int GetMaxPacketSize(int channelId) Parameters Type Name Description System.Int32 channelId Returns Type Description System.Int32 Overrides Transport.GetMaxPacketSize(Int32) | Improve this Doc View Source LateUpdate() Declaration public void LateUpdate() | Improve this Doc View Source ProcessClientMessage() Declaration public bool ProcessClientMessage() Returns Type Description System.Boolean | Improve this Doc View Source ProcessServerMessage() Declaration public bool ProcessServerMessage() Returns Type Description System.Boolean | Improve this Doc View Source ServerActive() Declaration public override bool ServerActive() Returns Type Description System.Boolean Overrides Transport.ServerActive() | Improve this Doc View Source ServerDisconnect(Int32) Declaration public override bool ServerDisconnect(int connectionId) Parameters Type Name Description System.Int32 connectionId Returns Type Description System.Boolean Overrides Transport.ServerDisconnect(Int32) | Improve this Doc View Source ServerGetClientAddress(Int32) Declaration public override string ServerGetClientAddress(int connectionId) Parameters Type Name Description System.Int32 connectionId Returns Type Description System.String Overrides Transport.ServerGetClientAddress(Int32) | Improve this Doc View Source ServerSend(List<Int32>, Int32, ArraySegment<Byte>) Declaration public override bool ServerSend(List<int> connectionIds, int channelId, ArraySegment<byte> segment) Parameters Type Name Description List < System.Int32 > connectionIds System.Int32 channelId ArraySegment < System.Byte > segment Returns Type Description System.Boolean Overrides Transport.ServerSend(List<Int32>, Int32, ArraySegment<Byte>) | Improve this Doc View Source ServerStart() Declaration public override void ServerStart() Overrides Transport.ServerStart() | Improve this Doc View Source ServerStop() Declaration public override void ServerStop() Overrides Transport.ServerStop() | Improve this Doc View Source Shutdown() Declaration public override void Shutdown() Overrides Transport.Shutdown() | Improve this Doc View Source ToString() Declaration public override string ToString() Returns Type Description System.String"
  },
  "api/Mirror.SyncHashSet-1.html": {
    "href": "api/Mirror.SyncHashSet-1.html",
    "title": "Class SyncHashSet<T>",
    "keywords": "Class SyncHashSet<T> Inheritance System.Object SyncSet <T> SyncHashSet<T> Implements ISyncObject Inherited Members SyncSet<T>.objects SyncSet<T>.Count SyncSet<T>.IsReadOnly SyncSet<T>.Callback SyncSet<T>.SerializeItem(NetworkWriter, T) SyncSet<T>.DeserializeItem(NetworkReader) SyncSet<T>.IsDirty SyncSet<T>.Flush() SyncSet<T>.OnSerializeAll(NetworkWriter) SyncSet<T>.OnSerializeDelta(NetworkWriter) SyncSet<T>.OnDeserializeAll(NetworkReader) SyncSet<T>.OnDeserializeDelta(NetworkReader) SyncSet<T>.Add(T) SyncSet<T>.Clear() SyncSet<T>.Contains(T) SyncSet<T>.CopyTo(T[], Int32) SyncSet<T>.Remove(T) SyncSet<T>.ExceptWith(IEnumerable<T>) SyncSet<T>.IntersectWith(IEnumerable<T>) SyncSet<T>.IsProperSubsetOf(IEnumerable<T>) SyncSet<T>.IsProperSupersetOf(IEnumerable<T>) SyncSet<T>.IsSubsetOf(IEnumerable<T>) SyncSet<T>.IsSupersetOf(IEnumerable<T>) SyncSet<T>.Overlaps(IEnumerable<T>) SyncSet<T>.SetEquals(IEnumerable<T>) SyncSet<T>.SymmetricExceptWith(IEnumerable<T>) SyncSet<T>.UnionWith(IEnumerable<T>) Namespace : Mirror Assembly : doc.dll Syntax public abstract class SyncHashSet<T> : SyncSet<T>, ISyncObject Type Parameters Name Description T Constructors | Improve this Doc View Source SyncHashSet(IEqualityComparer<T>) Declaration protected SyncHashSet(IEqualityComparer<T> comparer = null) Parameters Type Name Description IEqualityComparer <T> comparer Methods | Improve this Doc View Source GetEnumerator() Declaration public HashSet<T>.Enumerator GetEnumerator() Returns Type Description HashSet.Enumerator <> Implements ISyncObject"
  },
  "api/Mirror.TelepathyTransport.html": {
    "href": "api/Mirror.TelepathyTransport.html",
    "title": "Class TelepathyTransport",
    "keywords": "Class TelepathyTransport Inheritance System.Object Transport TelepathyTransport Inherited Members Transport.activeTransport Transport.OnClientConnected Transport.OnClientDataReceived Transport.OnClientError Transport.OnClientDisconnected Transport.OnServerConnected Transport.OnServerDataReceived Transport.OnServerError Transport.OnServerDisconnected Transport.Update() Transport.OnApplicationQuit() Namespace : Mirror Assembly : doc.dll Syntax public class TelepathyTransport : Transport Fields | Improve this Doc View Source client Declaration protected Client client Field Value Type Description Client | Improve this Doc View Source clientMaxMessageSize Declaration public int clientMaxMessageSize Field Value Type Description System.Int32 | Improve this Doc View Source NoDelay Declaration public bool NoDelay Field Value Type Description System.Boolean | Improve this Doc View Source port Declaration public ushort port Field Value Type Description System.UInt16 | Improve this Doc View Source Scheme Declaration public const string Scheme = null Field Value Type Description System.String | Improve this Doc View Source server Declaration protected Server server Field Value Type Description Server | Improve this Doc View Source serverMaxMessageSize Declaration public int serverMaxMessageSize Field Value Type Description System.Int32 Methods | Improve this Doc View Source Available() Declaration public override bool Available() Returns Type Description System.Boolean Overrides Transport.Available() | Improve this Doc View Source ClientConnect(String) Declaration public override void ClientConnect(string address) Parameters Type Name Description System.String address Overrides Transport.ClientConnect(String) | Improve this Doc View Source ClientConnect(Uri) Declaration public override void ClientConnect(Uri uri) Parameters Type Name Description Uri uri Overrides Transport.ClientConnect(Uri) | Improve this Doc View Source ClientConnected() Declaration public override bool ClientConnected() Returns Type Description System.Boolean Overrides Transport.ClientConnected() | Improve this Doc View Source ClientDisconnect() Declaration public override void ClientDisconnect() Overrides Transport.ClientDisconnect() | Improve this Doc View Source ClientSend(Int32, ArraySegment<Byte>) Declaration public override bool ClientSend(int channelId, ArraySegment<byte> segment) Parameters Type Name Description System.Int32 channelId ArraySegment < System.Byte > segment Returns Type Description System.Boolean Overrides Transport.ClientSend(Int32, ArraySegment<Byte>) | Improve this Doc View Source GetMaxPacketSize(Int32) Declaration public override int GetMaxPacketSize(int channelId) Parameters Type Name Description System.Int32 channelId Returns Type Description System.Int32 Overrides Transport.GetMaxPacketSize(Int32) | Improve this Doc View Source LateUpdate() Declaration public void LateUpdate() | Improve this Doc View Source ProcessServerMessage() Declaration public bool ProcessServerMessage() Returns Type Description System.Boolean | Improve this Doc View Source ServerActive() Declaration public override bool ServerActive() Returns Type Description System.Boolean Overrides Transport.ServerActive() | Improve this Doc View Source ServerDisconnect(Int32) Declaration public override bool ServerDisconnect(int connectionId) Parameters Type Name Description System.Int32 connectionId Returns Type Description System.Boolean Overrides Transport.ServerDisconnect(Int32) | Improve this Doc View Source ServerGetClientAddress(Int32) Declaration public override string ServerGetClientAddress(int connectionId) Parameters Type Name Description System.Int32 connectionId Returns Type Description System.String Overrides Transport.ServerGetClientAddress(Int32) | Improve this Doc View Source ServerSend(List<Int32>, Int32, ArraySegment<Byte>) Declaration public override bool ServerSend(List<int> connectionIds, int channelId, ArraySegment<byte> segment) Parameters Type Name Description List < System.Int32 > connectionIds System.Int32 channelId ArraySegment < System.Byte > segment Returns Type Description System.Boolean Overrides Transport.ServerSend(List<Int32>, Int32, ArraySegment<Byte>) | Improve this Doc View Source ServerStart() Declaration public override void ServerStart() Overrides Transport.ServerStart() | Improve this Doc View Source ServerStop() Declaration public override void ServerStop() Overrides Transport.ServerStop() | Improve this Doc View Source Shutdown() Declaration public override void Shutdown() Overrides Transport.Shutdown() | Improve this Doc View Source ToString() Declaration public override string ToString() Returns Type Description System.String"
  },
  "api/Telepathy.Message.html": {
    "href": "api/Telepathy.Message.html",
    "title": "Struct Message",
    "keywords": "Struct Message Namespace : Telepathy Assembly : doc.dll Syntax public struct Message Constructors | Improve this Doc View Source Message(Int32, EventType, Byte[]) Declaration public Message(int connectionId, EventType eventType, byte[] data) Parameters Type Name Description System.Int32 connectionId EventType eventType System.Byte [] data Fields | Improve this Doc View Source connectionId Declaration public readonly int connectionId Field Value Type Description System.Int32 | Improve this Doc View Source data Declaration public readonly byte[] data Field Value Type Description System.Byte [] | Improve this Doc View Source eventType Declaration public readonly EventType eventType Field Value Type Description EventType"
  },
  "api/Mirror.Tcp.Common.html": {
    "href": "api/Mirror.Tcp.Common.html",
    "title": "Class Common",
    "keywords": "Class Common Inheritance System.Object Common Client Server Namespace : Mirror.Tcp Assembly : doc.dll Syntax public abstract class Common : object Methods | Improve this Doc View Source BytesToInt(Byte[]) Declaration protected static int BytesToInt(byte[] bytes) Parameters Type Name Description System.Byte [] bytes Returns Type Description System.Int32 | Improve this Doc View Source ReadMessageAsync(Stream) Declaration protected static Task<byte[]> ReadMessageAsync(Stream stream) Parameters Type Name Description Stream stream Returns Type Description Task < System.Byte []> | Improve this Doc View Source SendMessage(NetworkStream, ArraySegment<Byte>) Declaration protected static Task SendMessage(NetworkStream stream, ArraySegment<byte> content) Parameters Type Name Description NetworkStream stream ArraySegment < System.Byte > content Returns Type Description Task | Improve this Doc View Source SendMessage(NetworkStream, MemoryStream) Declaration protected static Task SendMessage(NetworkStream stream, MemoryStream content) Parameters Type Name Description NetworkStream stream MemoryStream content Returns Type Description Task | Improve this Doc View Source WriteSize(Int32, Byte[]) Declaration protected static void WriteSize(int length, byte[] bytes) Parameters Type Name Description System.Int32 length System.Byte [] bytes"
  },
  "api/Mirror.NetworkAuthenticator.html": {
    "href": "api/Mirror.NetworkAuthenticator.html",
    "title": "Class NetworkAuthenticator",
    "keywords": "Class NetworkAuthenticator Base class for implementing component-based authentication during the Connect phase Inheritance System.Object NetworkAuthenticator Namespace : Mirror Assembly : doc.dll Syntax public abstract class NetworkAuthenticator : MonoBehaviour Methods | Improve this Doc View Source OnClientAuthenticate(NetworkConnectionToServer) Called on client from OnClientAuthenticateInternal when a client needs to authenticate Declaration public virtual void OnClientAuthenticate(NetworkConnectionToServer conn) Parameters Type Name Description NetworkConnectionToServer conn Connection of the client. | Improve this Doc View Source OnServerAuthenticate(NetworkConnectionToClient) Called on server from OnServerAuthenticateInternal when a client needs to authenticate Declaration public virtual void OnServerAuthenticate(NetworkConnectionToClient conn) Parameters Type Name Description NetworkConnectionToClient conn Connection to client. | Improve this Doc View Source OnStartClient() Called on client from StartClient to initialize the Authenticator Client message handlers should be registered in this method. Declaration public virtual void OnStartClient() | Improve this Doc View Source OnStartServer() Called on server from StartServer to initialize the Authenticator Server message handlers should be registered in this method. Declaration public virtual void OnStartServer() Events | Improve this Doc View Source OnClientAuthenticated Notify subscribers on the client when the client is authenticated Declaration public event Action<NetworkConnectionToServer> OnClientAuthenticated Event Type Type Description Action < NetworkConnectionToServer > | Improve this Doc View Source OnServerAuthenticated Notify subscribers on the server when a client is authenticated Declaration public event Action<NetworkConnectionToClient> OnServerAuthenticated Event Type Type Description Action < NetworkConnectionToClient >"
  },
  "api/Mirror.UpdateVarsMessage.html": {
    "href": "api/Mirror.UpdateVarsMessage.html",
    "title": "Struct UpdateVarsMessage",
    "keywords": "Struct UpdateVarsMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct UpdateVarsMessage : IMessageBase Fields | Improve this Doc View Source netId Declaration public uint netId Field Value Type Description System.UInt32 | Improve this Doc View Source payload Declaration public ArraySegment<byte> payload Field Value Type Description ArraySegment < System.Byte > Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.RpcMessage.html": {
    "href": "api/Mirror.RpcMessage.html",
    "title": "Struct RpcMessage",
    "keywords": "Struct RpcMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct RpcMessage : IMessageBase Fields | Improve this Doc View Source componentIndex Declaration public int componentIndex Field Value Type Description System.Int32 | Improve this Doc View Source functionHash Declaration public int functionHash Field Value Type Description System.Int32 | Improve this Doc View Source netId Declaration public uint netId Field Value Type Description System.UInt32 | Improve this Doc View Source payload Declaration public ArraySegment<byte> payload Field Value Type Description ArraySegment < System.Byte > Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.NetworkManager.html": {
    "href": "api/Mirror.NetworkManager.html",
    "title": "Class NetworkManager",
    "keywords": "Class NetworkManager Inheritance System.Object NetworkManager NetworkRoomManager Namespace : Mirror Assembly : doc.dll Syntax public class NetworkManager : MonoBehaviour Fields | Improve this Doc View Source authenticator Declaration public NetworkAuthenticator authenticator Field Value Type Description NetworkAuthenticator | Improve this Doc View Source autoCreatePlayer A flag to control whether or not player objects are automatically created on connect, and on scene change. Declaration public bool autoCreatePlayer Field Value Type Description System.Boolean | Improve this Doc View Source clientLoadedScene This is true if the client loaded a new scene when connecting to the server. This is set before OnClientConnect is called, so it can be checked there to perform different logic if a scene load occurred. Declaration public bool clientLoadedScene Field Value Type Description System.Boolean | Improve this Doc View Source dontDestroyOnLoad A flag to control whether the NetworkManager object is destroyed when the scene changes. This should be set if your game has a single NetworkManager that exists for the lifetime of the process. If there is a NetworkManager in each scene, then this should not be set. Declaration public bool dontDestroyOnLoad Field Value Type Description System.Boolean | Improve this Doc View Source isNetworkActive True if the server or client is started and running This is set True in StartServer / StartClient, and set False in StopServer / StopClient Declaration public bool isNetworkActive Field Value Type Description System.Boolean | Improve this Doc View Source loadingSceneAsync Declaration public static UnityEngine.AsyncOperation loadingSceneAsync Field Value Type Description UnityEngine.AsyncOperation | Improve this Doc View Source maxConnections The maximum number of concurrent network connections to support. This effects the memory usage of the network layer. Declaration public int maxConnections Field Value Type Description System.Int32 | Improve this Doc View Source networkAddress The network address currently in use. For clients, this is the address of the server that is connected to. For servers, this is the local address. Declaration public string networkAddress Field Value Type Description System.String | Improve this Doc View Source networkSceneName The name of the current network scene. Declaration public static string networkSceneName Field Value Type Description System.String Remarks This is populated if the NetworkManager is doing scene management. This should not be changed directly. Calls to ServerChangeScene() cause this to change. New clients that connect to a server will automatically load this scene. This is used to make sure that all scene changes are initialized by Mirror. Loading a scene manually wont set networkSceneName, so Mirror would still load it again on start. | Improve this Doc View Source offlineScene The scene to switch to when offline. Setting this makes the NetworkManager do scene management. This scene will be switched to when a network session is completed - such as a client disconnect, or a server shutdown. Declaration public string offlineScene Field Value Type Description System.String | Improve this Doc View Source onlineScene The scene to switch to when online. Setting this makes the NetworkManager do scene management. This scene will be switched to when a network session is started - such as a client connect, or a server listen. Declaration public string onlineScene Field Value Type Description System.String | Improve this Doc View Source playerPrefab The default prefab to be used to create player objects on the server. Player objects are created in the default handler for AddPlayer() on the server. Implementing OnServerAddPlayer overrides this behaviour. Declaration public GameObject playerPrefab Field Value Type Description GameObject | Improve this Doc View Source playerSpawnMethod The current method of spawning players used by the NetworkManager. Declaration public PlayerSpawnMethod playerSpawnMethod Field Value Type Description PlayerSpawnMethod | Improve this Doc View Source runInBackground Controls whether the program runs when it is in the background. This is required when multiple instances of a program using networking are running on the same machine, such as when testing using localhost. But this is not recommended when deploying to mobile platforms. Declaration public bool runInBackground Field Value Type Description System.Boolean | Improve this Doc View Source serverTickRate Server Update frequency, per second. Use around 60Hz for fast paced games like Counter-Strike to minimize latency. Use around 30Hz for games like WoW to minimize computations. Use around 1-10Hz for slow paced games like EVE. Declaration public int serverTickRate Field Value Type Description System.Int32 | Improve this Doc View Source showDebugMessages Enables verbose debug messages in the console Declaration public bool showDebugMessages Field Value Type Description System.Boolean | Improve this Doc View Source singleton NetworkManager singleton Declaration public static NetworkManager singleton Field Value Type Description NetworkManager | Improve this Doc View Source spawnPrefabs List of prefabs that will be registered with the spawning system. For each of these prefabs, ClientManager.RegisterPrefab() will be automatically invoke. Declaration public List<GameObject> spawnPrefabs Field Value Type Description List < GameObject > | Improve this Doc View Source startOnHeadless Automatically invoke StartServer() If the application is a Server Build or run with the -batchMode command line arguement, StartServer is automatically invoked. Declaration public bool startOnHeadless Field Value Type Description System.Boolean | Improve this Doc View Source startPositionIndex Declaration public static int startPositionIndex Field Value Type Description System.Int32 | Improve this Doc View Source startPositions List of transforms populted by NetworkStartPosition components found in the scene. Declaration public static List<Transform> startPositions Field Value Type Description List < Transform > | Improve this Doc View Source transport Declaration protected Transport transport Field Value Type Description Transport Properties | Improve this Doc View Source isHeadless headless mode detection Declaration public static bool isHeadless { get; } Property Value Type Description System.Boolean | Improve this Doc View Source mode Declaration public NetworkManagerMode mode { get; } Property Value Type Description NetworkManagerMode | Improve this Doc View Source numPlayers Number of active player objects across all connections on the server. This is only valid on the host / server. Declaration public int numPlayers { get; } Property Value Type Description System.Int32 Methods | Improve this Doc View Source Awake() virtual so that inheriting classes' Awake() can call base.Awake() too Declaration public virtual void Awake() | Improve this Doc View Source ConfigureServerFrameRate() Set the frame rate for a headless server. Override if you wish to disable the behavior or set your own tick rate. Declaration public virtual void ConfigureServerFrameRate() | Improve this Doc View Source GetStartPosition() This finds a spawn position based on NetworkStartPosition objects in the scene. This is used by the default implementation of OnServerAddPlayer. Declaration public Transform GetStartPosition() Returns Type Description Transform Returns the transform to spawn a player at, or null. | Improve this Doc View Source LateUpdate() virtual so that inheriting classes' LateUpdate() can call base.LateUpdate() too Declaration public virtual void LateUpdate() | Improve this Doc View Source OnApplicationQuit() called when quitting the application by closing the window / pressing stop in the editor virtual so that inheriting classes' OnApplicationQuit() can call base.OnApplicationQuit() too Declaration public virtual void OnApplicationQuit() | Improve this Doc View Source OnClientChangeScene(String, SceneOperation, Boolean) Called from ClientChangeScene immediately before SceneManager.LoadSceneAsync is executed This allows client to do work / cleanup / prep before the scene changes. Declaration public virtual void OnClientChangeScene(string newSceneName, SceneOperation sceneOperation, bool customHandling) Parameters Type Name Description System.String newSceneName Name of the scene that's about to be loaded SceneOperation sceneOperation Scene operation that's about to happen System.Boolean customHandling true to indicate that scene loading will be handled through overrides | Improve this Doc View Source OnClientConnect(NetworkConnection) Called on the client when connected to a server. The default implementation of this function sets the client as ready and adds a player. Override the function to dictate what happens when the client connects. Declaration public virtual void OnClientConnect(NetworkConnection conn) Parameters Type Name Description NetworkConnection conn Connection to the server. | Improve this Doc View Source OnClientDisconnect(NetworkConnection) Called on clients when disconnected from a server. This is called on the client when it disconnects from the server. Override this function to decide what happens when the client disconnects. Declaration public virtual void OnClientDisconnect(NetworkConnection conn) Parameters Type Name Description NetworkConnection conn Connection to the server. | Improve this Doc View Source OnClientError(NetworkConnection, Int32) Called on clients when a network error occurs. Declaration public virtual void OnClientError(NetworkConnection conn, int errorCode) Parameters Type Name Description NetworkConnection conn Connection to a server. System.Int32 errorCode Error code. | Improve this Doc View Source OnClientNotReady(NetworkConnection) Called on clients when a servers tells the client it is no longer ready. This is commonly used when switching scenes. Declaration public virtual void OnClientNotReady(NetworkConnection conn) Parameters Type Name Description NetworkConnection conn Connection to the server. | Improve this Doc View Source OnClientSceneChanged(NetworkConnection) Called on clients when a scene has completed loaded, when the scene load was initiated by the server. Scene changes can cause player objects to be destroyed. The default implementation of OnClientSceneChanged in the NetworkManager is to add a player object for the connection if no player object exists. Declaration public virtual void OnClientSceneChanged(NetworkConnection conn) Parameters Type Name Description NetworkConnection conn The network connection that the scene change message arrived on. | Improve this Doc View Source OnDestroy() virtual so that inheriting classes' OnDestroy() can call base.OnDestroy() too Declaration public virtual void OnDestroy() | Improve this Doc View Source OnServerAddPlayer(NetworkConnection) Called on the server when a client adds a new player with ClientScene.AddPlayer. The default implementation for this function creates a new player object from the playerPrefab. Declaration public virtual void OnServerAddPlayer(NetworkConnection conn) Parameters Type Name Description NetworkConnection conn Connection from client. | Improve this Doc View Source OnServerAddPlayer(NetworkConnection, AddPlayerMessage) Obsolete: Override OnServerAddPlayer(NetworkConnection) instead. See Custom Players for details. Declaration public virtual void OnServerAddPlayer(NetworkConnection conn, AddPlayerMessage extraMessage) Parameters Type Name Description NetworkConnection conn Connection from client. AddPlayerMessage extraMessage An extra message object passed for the new player. | Improve this Doc View Source OnServerChangeScene(String) Called from ServerChangeScene immediately before SceneManager.LoadSceneAsync is executed This allows server to do work / cleanup / prep before the scene changes. Declaration public virtual void OnServerChangeScene(string newSceneName) Parameters Type Name Description System.String newSceneName Name of the scene that's about to be loaded | Improve this Doc View Source OnServerConnect(NetworkConnection) Called on the server when a new client connects. Unity calls this on the Server when a Client connects to the Server. Use an override to tell the NetworkManager what to do when a client connects to the server. Declaration public virtual void OnServerConnect(NetworkConnection conn) Parameters Type Name Description NetworkConnection conn Connection from client. | Improve this Doc View Source OnServerDisconnect(NetworkConnection) Called on the server when a client disconnects. This is called on the Server when a Client disconnects from the Server. Use an override to decide what should happen when a disconnection is detected. Declaration public virtual void OnServerDisconnect(NetworkConnection conn) Parameters Type Name Description NetworkConnection conn Connection from client. | Improve this Doc View Source OnServerError(NetworkConnection, Int32) Called on the server when a network error occurs for a client connection. Declaration public virtual void OnServerError(NetworkConnection conn, int errorCode) Parameters Type Name Description NetworkConnection conn Connection from client. System.Int32 errorCode Error code. | Improve this Doc View Source OnServerReady(NetworkConnection) Called on the server when a client is ready. The default implementation of this function calls NetworkServer.SetClientReady() to continue the network setup process. Declaration public virtual void OnServerReady(NetworkConnection conn) Parameters Type Name Description NetworkConnection conn Connection from client. | Improve this Doc View Source OnServerRemovePlayer(NetworkConnection, NetworkIdentity) Called on the server when a client removes a player. The default implementation of this function destroys the corresponding player object. Declaration public virtual void OnServerRemovePlayer(NetworkConnection conn, NetworkIdentity player) Parameters Type Name Description NetworkConnection conn The connection to remove the player from. NetworkIdentity player The player identity to remove. | Improve this Doc View Source OnServerSceneChanged(String) Called on the server when a scene is completed loaded, when the scene load was initiated by the server with ServerChangeScene(). Declaration public virtual void OnServerSceneChanged(string sceneName) Parameters Type Name Description System.String sceneName The name of the new scene. | Improve this Doc View Source OnStartClient() This is invoked when the client is started. Declaration public virtual void OnStartClient() | Improve this Doc View Source OnStartHost() This is invoked when a host is started. StartHost has multiple signatures, but they all cause this hook to be called. Declaration public virtual void OnStartHost() | Improve this Doc View Source OnStartServer() This is invoked when a server is started - including when a host is started. StartServer has multiple signatures, but they all cause this hook to be called. Declaration public virtual void OnStartServer() | Improve this Doc View Source OnStopClient() This is called when a client is stopped. Declaration public virtual void OnStopClient() | Improve this Doc View Source OnStopHost() This is called when a host is stopped. Declaration public virtual void OnStopHost() | Improve this Doc View Source OnStopServer() This is called when a server is stopped - including when a host is stopped. Declaration public virtual void OnStopServer() | Improve this Doc View Source OnValidate() virtual so that inheriting classes' OnValidate() can call base.OnValidate() too Declaration public virtual void OnValidate() | Improve this Doc View Source RegisterStartPosition(Transform) Registers the transform of a game object as a player spawn location. This is done automatically by NetworkStartPosition components, but can be done manually from user script code. Declaration public static void RegisterStartPosition(Transform start) Parameters Type Name Description Transform start Transform to register. | Improve this Doc View Source ServerChangeScene(String) This causes the server to switch scenes and sets the networkSceneName. Clients that connect to this server will automatically switch to this scene. This is called autmatically if onlineScene or offlineScene are set, but it can be called from user code to switch scenes again while the game is in progress. This automatically sets clients to be not-ready. The clients must call NetworkClient.Ready() again to participate in the new scene. Declaration public virtual void ServerChangeScene(string newSceneName) Parameters Type Name Description System.String newSceneName | Improve this Doc View Source Shutdown() This is the only way to clear the singleton, so another instance can be created. Declaration public static void Shutdown() | Improve this Doc View Source Start() virtual so that inheriting classes' Start() can call base.Start() too Declaration public virtual void Start() | Improve this Doc View Source StartClient() This starts a network client. It uses the networkAddress and networkPort properties as the address to connect to. This makes the newly created client connect to the server immediately. Declaration public void StartClient() | Improve this Doc View Source StartClient(Uri) This starts a network client. It uses the networkAddress and networkPort properties as the address to connect to. This makes the newly created client connect to the server immediately. Declaration public void StartClient(Uri uri) Parameters Type Name Description Uri uri location of the server to connect to | Improve this Doc View Source StartHost() This starts a network \"host\" - a server and client in the same application. The client returned from StartHost() is a special \"local\" client that communicates to the in-process server using a message queue instead of the real network. But in almost all other cases, it can be treated as a normal client. Declaration public virtual void StartHost() | Improve this Doc View Source StartServer() This starts a new server. This uses the networkPort property as the listen port. Declaration public void StartServer() | Improve this Doc View Source StopClient() Stops the client that the manager is using. Declaration public void StopClient() | Improve this Doc View Source StopHost() This stops both the client and the server that the manager is using. Declaration public void StopHost() | Improve this Doc View Source StopServer() Stops the server that the manager is using. Declaration public void StopServer() | Improve this Doc View Source UnRegisterStartPosition(Transform) Unregisters the transform of a game object as a player spawn location. This is done automatically by the NetworkStartPosition component, but can be done manually from user code. Declaration public static void UnRegisterStartPosition(Transform start) Parameters Type Name Description Transform start Transform to unregister."
  },
  "api/Mirror.Tcp.ObjectPool-1.html": {
    "href": "api/Mirror.Tcp.ObjectPool-1.html",
    "title": "Class ObjectPool<T>",
    "keywords": "Class ObjectPool<T> Inheritance System.Object ObjectPool<T> Namespace : Mirror.Tcp Assembly : doc.dll Syntax public class ObjectPool<T> : object Type Parameters Name Description T Constructors | Improve this Doc View Source ObjectPool(Func<T>) Declaration public ObjectPool(Func<T> objectGenerator) Parameters Type Name Description Func <T> objectGenerator Methods | Improve this Doc View Source GetObject() Declaration public T GetObject() Returns Type Description T | Improve this Doc View Source PutObject(T) Declaration public void PutObject(T item) Parameters Type Name Description T item"
  },
  "api/Mirror.Websocket.Server.html": {
    "href": "api/Mirror.Websocket.Server.html",
    "title": "Class Server",
    "keywords": "Class Server Inheritance System.Object Server Namespace : Mirror.Websocket Assembly : doc.dll Syntax public class Server : object Fields | Improve this Doc View Source _secure Declaration public bool _secure Field Value Type Description System.Boolean | Improve this Doc View Source _sslConfig Declaration public Server.SslConfiguration _sslConfig Field Value Type Description Server.SslConfiguration | Improve this Doc View Source NoDelay Declaration public bool NoDelay Field Value Type Description System.Boolean Properties | Improve this Doc View Source Active Declaration public bool Active { get; } Property Value Type Description System.Boolean Methods | Improve this Doc View Source Disconnect(Int32) Declaration public bool Disconnect(int connectionId) Parameters Type Name Description System.Int32 connectionId Returns Type Description System.Boolean | Improve this Doc View Source GetClient(Int32) Declaration public WebSocket GetClient(int connectionId) Parameters Type Name Description System.Int32 connectionId Returns Type Description WebSocket | Improve this Doc View Source GetClientAddress(Int32) Declaration public string GetClientAddress(int connectionId) Parameters Type Name Description System.Int32 connectionId Returns Type Description System.String | Improve this Doc View Source Listen(Int32) Declaration public Task Listen(int port) Parameters Type Name Description System.Int32 port Returns Type Description Task | Improve this Doc View Source NextConnectionId() Declaration public static int NextConnectionId() Returns Type Description System.Int32 | Improve this Doc View Source Send(Int32, ArraySegment<Byte>) Declaration public Task Send(int connectionId, ArraySegment<byte> segment) Parameters Type Name Description System.Int32 connectionId ArraySegment < System.Byte > segment Returns Type Description Task | Improve this Doc View Source Stop() Declaration public void Stop() | Improve this Doc View Source ToString() Declaration public override string ToString() Returns Type Description System.String Events | Improve this Doc View Source Connected Declaration public event Action<int> Connected Event Type Type Description Action < System.Int32 > | Improve this Doc View Source Disconnected Declaration public event Action<int> Disconnected Event Type Type Description Action < System.Int32 > | Improve this Doc View Source ReceivedData Declaration public event Action<int, ArraySegment<byte>> ReceivedData Event Type Type Description Action < System.Int32 , ArraySegment < System.Byte >> | Improve this Doc View Source ReceivedError Declaration public event Action<int, Exception> ReceivedError Event Type Type Description Action < System.Int32 , Exception >"
  },
  "api/Mirror.SyncListFloat.html": {
    "href": "api/Mirror.SyncListFloat.html",
    "title": "Class SyncListFloat",
    "keywords": "Class SyncListFloat Inheritance System.Object SyncList < System.Single > SyncListFloat Implements IReadOnlyList < System.Single > ISyncObject Inherited Members SyncList<Single>.Count SyncList<Single>.IsReadOnly SyncList<Single>.Callback SyncList<Single>.IsDirty SyncList<Single>.Flush() SyncList<Single>.OnSerializeAll(NetworkWriter) SyncList<Single>.OnSerializeDelta(NetworkWriter) SyncList<Single>.OnDeserializeAll(NetworkReader) SyncList<Single>.OnDeserializeDelta(NetworkReader) SyncList<Single>.Add(Single) SyncList<Single>.Clear() SyncList<Single>.Contains(Single) SyncList<Single>.CopyTo(Single[], Int32) SyncList<Single>.IndexOf(Single) SyncList<Single>.FindIndex(Predicate<Single>) SyncList<Single>.Insert(Int32, Single) SyncList<Single>.Remove(Single) SyncList<Single>.RemoveAt(Int32) SyncList<Single>.Item[Int32] SyncList<Single>.GetEnumerator() Namespace : Mirror Assembly : doc.dll Syntax public class SyncListFloat : SyncList<float>, IReadOnlyList<float>, ISyncObject Methods | Improve this Doc View Source DeserializeItem(NetworkReader) Declaration protected override float DeserializeItem(NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description System.Single Overrides Mirror.SyncList<System.Single>.DeserializeItem(Mirror.NetworkReader) | Improve this Doc View Source SerializeItem(NetworkWriter, Single) Declaration protected override void SerializeItem(NetworkWriter writer, float item) Parameters Type Name Description NetworkWriter writer System.Single item Overrides Mirror.SyncList<System.Single>.SerializeItem(Mirror.NetworkWriter, System.Single) Implements IReadOnlyList<> ISyncObject"
  },
  "api/Mirror.AddPlayerMessage.html": {
    "href": "api/Mirror.AddPlayerMessage.html",
    "title": "Struct AddPlayerMessage",
    "keywords": "Struct AddPlayerMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct AddPlayerMessage : IMessageBase Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.NotReadyMessage.html": {
    "href": "api/Mirror.NotReadyMessage.html",
    "title": "Struct NotReadyMessage",
    "keywords": "Struct NotReadyMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct NotReadyMessage : IMessageBase Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.ISyncObject.html": {
    "href": "api/Mirror.ISyncObject.html",
    "title": "Interface ISyncObject",
    "keywords": "Interface ISyncObject Namespace : Mirror Assembly : doc.dll Syntax public interface ISyncObject Properties | Improve this Doc View Source IsDirty Declaration bool IsDirty { get; } Property Value Type Description System.Boolean Methods | Improve this Doc View Source Flush() Declaration void Flush() | Improve this Doc View Source OnDeserializeAll(NetworkReader) Declaration void OnDeserializeAll(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source OnDeserializeDelta(NetworkReader) Declaration void OnDeserializeDelta(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source OnSerializeAll(NetworkWriter) Declaration void OnSerializeAll(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer | Improve this Doc View Source OnSerializeDelta(NetworkWriter) Declaration void OnSerializeDelta(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer"
  },
  "api/Mirror.ServerAttribute.html": {
    "href": "api/Mirror.ServerAttribute.html",
    "title": "Class ServerAttribute",
    "keywords": "Class ServerAttribute Prevents clients from running this method. Prints a warning if a client tries to execute this method. Inheritance System.Object ServerAttribute Namespace : Mirror Assembly : doc.dll Syntax public class ServerAttribute : Attribute"
  },
  "api/Telepathy.Common.html": {
    "href": "api/Telepathy.Common.html",
    "title": "Class Common",
    "keywords": "Class Common Inheritance System.Object Common Client Server Namespace : Telepathy Assembly : doc.dll Syntax public abstract class Common : object Fields | Improve this Doc View Source MaxMessageSize Declaration public int MaxMessageSize Field Value Type Description System.Int32 | Improve this Doc View Source messageQueueSizeWarning Declaration public static int messageQueueSizeWarning Field Value Type Description System.Int32 | Improve this Doc View Source NoDelay Declaration public bool NoDelay Field Value Type Description System.Boolean | Improve this Doc View Source receiveQueue Declaration protected ConcurrentQueue<Message> receiveQueue Field Value Type Description ConcurrentQueue < Message > | Improve this Doc View Source SendTimeout Declaration public int SendTimeout Field Value Type Description System.Int32 Properties | Improve this Doc View Source ReceiveQueueCount Declaration public int ReceiveQueueCount { get; } Property Value Type Description System.Int32 Methods | Improve this Doc View Source GetNextMessage(out Message) Declaration public bool GetNextMessage(out Message message) Parameters Type Name Description Message message Returns Type Description System.Boolean | Improve this Doc View Source ReadMessageBlocking(NetworkStream, Int32, out Byte[]) Declaration protected static bool ReadMessageBlocking(NetworkStream stream, int MaxMessageSize, out byte[] content) Parameters Type Name Description NetworkStream stream System.Int32 MaxMessageSize System.Byte [] content Returns Type Description System.Boolean | Improve this Doc View Source ReceiveLoop(Int32, TcpClient, ConcurrentQueue<Message>, Int32) Declaration protected static void ReceiveLoop(int connectionId, TcpClient client, ConcurrentQueue<Message> receiveQueue, int MaxMessageSize) Parameters Type Name Description System.Int32 connectionId TcpClient client ConcurrentQueue < Message > receiveQueue System.Int32 MaxMessageSize | Improve this Doc View Source SendLoop(Int32, TcpClient, SafeQueue<Byte[]>, ManualResetEvent) Declaration protected static void SendLoop(int connectionId, TcpClient client, SafeQueue<byte[]> sendQueue, ManualResetEvent sendPending) Parameters Type Name Description System.Int32 connectionId TcpClient client SafeQueue < System.Byte []> sendQueue ManualResetEvent sendPending | Improve this Doc View Source SendMessagesBlocking(NetworkStream, Byte[][]) Declaration protected static bool SendMessagesBlocking(NetworkStream stream, byte[][] messages) Parameters Type Name Description NetworkStream stream System.Byte [][] messages Returns Type Description System.Boolean"
  },
  "api/Mirror.DisconnectMessage.html": {
    "href": "api/Mirror.DisconnectMessage.html",
    "title": "Struct DisconnectMessage",
    "keywords": "Struct DisconnectMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct DisconnectMessage : IMessageBase Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.ConnectMessage.html": {
    "href": "api/Mirror.ConnectMessage.html",
    "title": "Struct ConnectMessage",
    "keywords": "Struct ConnectMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct ConnectMessage : IMessageBase Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.SpawnHandlerDelegate.html": {
    "href": "api/Mirror.SpawnHandlerDelegate.html",
    "title": "Delegate SpawnHandlerDelegate",
    "keywords": "Delegate SpawnHandlerDelegate Namespace : Mirror Assembly : doc.dll Syntax public delegate GameObject SpawnHandlerDelegate(SpawnMessage msg); Parameters Type Name Description SpawnMessage msg Returns Type Description GameObject"
  },
  "api/Mirror.ServerCallbackAttribute.html": {
    "href": "api/Mirror.ServerCallbackAttribute.html",
    "title": "Class ServerCallbackAttribute",
    "keywords": "Class ServerCallbackAttribute Prevents clients from running this method. No warning is thrown. Inheritance System.Object ServerCallbackAttribute Namespace : Mirror Assembly : doc.dll Syntax public class ServerCallbackAttribute : Attribute"
  },
  "api/Mirror.NetworkTransformBase.html": {
    "href": "api/Mirror.NetworkTransformBase.html",
    "title": "Class NetworkTransformBase",
    "keywords": "Class NetworkTransformBase Inheritance System.Object NetworkBehaviour NetworkTransformBase NetworkTransform NetworkTransformChild Inherited Members NetworkBehaviour.syncMode NetworkBehaviour.syncInterval NetworkBehaviour.isServer NetworkBehaviour.isClient NetworkBehaviour.isLocalPlayer NetworkBehaviour.isServerOnly NetworkBehaviour.isClientOnly NetworkBehaviour.hasAuthority NetworkBehaviour.netId NetworkBehaviour.connectionToServer NetworkBehaviour.connectionToClient NetworkBehaviour.syncVarDirtyBits NetworkBehaviour.getSyncVarHookGuard(UInt64) NetworkBehaviour.setSyncVarHookGuard(UInt64, Boolean) NetworkBehaviour.syncObjects NetworkBehaviour.netIdentity NetworkBehaviour.ComponentIndex NetworkBehaviour.InitSyncObject(ISyncObject) NetworkBehaviour.SendCommandInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeCommand(Int32, NetworkReader) NetworkBehaviour.SendRPCInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.SendTargetRPCInternal(NetworkConnection, Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeRPC(Int32, NetworkReader) NetworkBehaviour.SendEventInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeSyncEvent(Int32, NetworkReader) NetworkBehaviour.RegisterDelegate(Type, String, MirrorInvokeType, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterCommandDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterRpcDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterEventDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.GetRpcHandler(Int32) NetworkBehaviour.SyncVarGameObjectEqual(GameObject, UInt32) NetworkBehaviour.SetSyncVarGameObject(GameObject, GameObject, UInt64, UInt32) NetworkBehaviour.GetSyncVarGameObject(UInt32, GameObject) NetworkBehaviour.SyncVarNetworkIdentityEqual(NetworkIdentity, UInt32) NetworkBehaviour.SetSyncVarNetworkIdentity(NetworkIdentity, NetworkIdentity, UInt64, UInt32) NetworkBehaviour.GetSyncVarNetworkIdentity(UInt32, NetworkIdentity) NetworkBehaviour.SyncVarEqual<T>(T, T) NetworkBehaviour.SetSyncVar<T>(T, T, UInt64) NetworkBehaviour.SetDirtyBit(UInt64) NetworkBehaviour.ClearAllDirtyBits() NetworkBehaviour.SerializeObjectsAll(NetworkWriter) NetworkBehaviour.SerializeObjectsDelta(NetworkWriter) NetworkBehaviour.OnNetworkDestroy() NetworkBehaviour.OnStartServer() NetworkBehaviour.OnStartClient() NetworkBehaviour.OnStartLocalPlayer() NetworkBehaviour.OnStartAuthority() NetworkBehaviour.OnStopAuthority() NetworkBehaviour.OnRebuildObservers(HashSet<NetworkConnection>, Boolean) NetworkBehaviour.OnSetHostVisibility(Boolean) NetworkBehaviour.OnCheckObserver(NetworkConnection) Namespace : Mirror Assembly : doc.dll Syntax public abstract class NetworkTransformBase : NetworkBehaviour Fields | Improve this Doc View Source clientAuthority Declaration public bool clientAuthority Field Value Type Description System.Boolean Properties | Improve this Doc View Source TargetComponent Declaration protected abstract Transform TargetComponent { get; } Property Value Type Description Transform Methods | Improve this Doc View Source OnDeserialize(NetworkReader, Boolean) Declaration public override void OnDeserialize(NetworkReader reader, bool initialState) Parameters Type Name Description NetworkReader reader System.Boolean initialState Overrides NetworkBehaviour.OnDeserialize(NetworkReader, Boolean) | Improve this Doc View Source OnSerialize(NetworkWriter, Boolean) Declaration public override bool OnSerialize(NetworkWriter writer, bool initialState) Parameters Type Name Description NetworkWriter writer System.Boolean initialState Returns Type Description System.Boolean Overrides NetworkBehaviour.OnSerialize(NetworkWriter, Boolean)"
  },
  "api/Mirror.FallbackTransport.html": {
    "href": "api/Mirror.FallbackTransport.html",
    "title": "Class FallbackTransport",
    "keywords": "Class FallbackTransport Inheritance System.Object Transport FallbackTransport Inherited Members Transport.activeTransport Transport.OnClientConnected Transport.OnClientDataReceived Transport.OnClientError Transport.OnClientDisconnected Transport.OnServerConnected Transport.OnServerDataReceived Transport.OnServerError Transport.OnServerDisconnected Transport.Update() Transport.OnApplicationQuit() Namespace : Mirror Assembly : doc.dll Syntax public class FallbackTransport : Transport Fields | Improve this Doc View Source transports Declaration public Transport[] transports Field Value Type Description Transport [] Methods | Improve this Doc View Source Available() Declaration public override bool Available() Returns Type Description System.Boolean Overrides Transport.Available() | Improve this Doc View Source Awake() Declaration public void Awake() | Improve this Doc View Source ClientConnect(String) Declaration public override void ClientConnect(string address) Parameters Type Name Description System.String address Overrides Transport.ClientConnect(String) | Improve this Doc View Source ClientConnect(Uri) Declaration public override void ClientConnect(Uri uri) Parameters Type Name Description Uri uri Overrides Transport.ClientConnect(Uri) | Improve this Doc View Source ClientConnected() Declaration public override bool ClientConnected() Returns Type Description System.Boolean Overrides Transport.ClientConnected() | Improve this Doc View Source ClientDisconnect() Declaration public override void ClientDisconnect() Overrides Transport.ClientDisconnect() | Improve this Doc View Source ClientSend(Int32, ArraySegment<Byte>) Declaration public override bool ClientSend(int channelId, ArraySegment<byte> segment) Parameters Type Name Description System.Int32 channelId ArraySegment < System.Byte > segment Returns Type Description System.Boolean Overrides Transport.ClientSend(Int32, ArraySegment<Byte>) | Improve this Doc View Source GetMaxPacketSize(Int32) Declaration public override int GetMaxPacketSize(int channelId = 0) Parameters Type Name Description System.Int32 channelId Returns Type Description System.Int32 Overrides Transport.GetMaxPacketSize(Int32) | Improve this Doc View Source ServerActive() Declaration public override bool ServerActive() Returns Type Description System.Boolean Overrides Transport.ServerActive() | Improve this Doc View Source ServerDisconnect(Int32) Declaration public override bool ServerDisconnect(int connectionId) Parameters Type Name Description System.Int32 connectionId Returns Type Description System.Boolean Overrides Transport.ServerDisconnect(Int32) | Improve this Doc View Source ServerGetClientAddress(Int32) Declaration public override string ServerGetClientAddress(int connectionId) Parameters Type Name Description System.Int32 connectionId Returns Type Description System.String Overrides Transport.ServerGetClientAddress(Int32) | Improve this Doc View Source ServerSend(List<Int32>, Int32, ArraySegment<Byte>) Declaration public override bool ServerSend(List<int> connectionIds, int channelId, ArraySegment<byte> segment) Parameters Type Name Description List < System.Int32 > connectionIds System.Int32 channelId ArraySegment < System.Byte > segment Returns Type Description System.Boolean Overrides Transport.ServerSend(List<Int32>, Int32, ArraySegment<Byte>) | Improve this Doc View Source ServerStart() Declaration public override void ServerStart() Overrides Transport.ServerStart() | Improve this Doc View Source ServerStop() Declaration public override void ServerStop() Overrides Transport.ServerStop() | Improve this Doc View Source Shutdown() Declaration public override void Shutdown() Overrides Transport.Shutdown() | Improve this Doc View Source ToString() Declaration public override string ToString() Returns Type Description System.String"
  },
  "api/Mirror.NetworkIdentity.ClientAuthorityCallback.html": {
    "href": "api/Mirror.NetworkIdentity.ClientAuthorityCallback.html",
    "title": "Delegate NetworkIdentity.ClientAuthorityCallback",
    "keywords": "Delegate NetworkIdentity.ClientAuthorityCallback The delegate type for the clientAuthorityCallback. Namespace : Mirror Assembly : doc.dll Syntax public delegate void ClientAuthorityCallback(NetworkConnection conn, NetworkIdentity identity, bool authorityState); Parameters Type Name Description NetworkConnection conn The network connection that is gaining or losing authority. NetworkIdentity identity The object whose client authority status is being changed. System.Boolean authorityState The new state of client authority of the object for the connection."
  },
  "api/Mirror.SyncVarAttribute.html": {
    "href": "api/Mirror.SyncVarAttribute.html",
    "title": "Class SyncVarAttribute",
    "keywords": "Class SyncVarAttribute SyncVars are used to synchronize a variable from the server to all clients automatically. Value must be changed on server, not directly by clients. Hook parameter allows you to define a client-side method to be invoked when the client gets an update from the server. Inheritance System.Object SyncVarAttribute Namespace : Mirror Assembly : doc.dll Syntax public class SyncVarAttribute : Attribute Fields | Improve this Doc View Source hook A function that should be called on the client when the value changes. Declaration public string hook Field Value Type Description System.String"
  },
  "api/Mirror.ObjectHideMessage.html": {
    "href": "api/Mirror.ObjectHideMessage.html",
    "title": "Struct ObjectHideMessage",
    "keywords": "Struct ObjectHideMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct ObjectHideMessage : IMessageBase Fields | Improve this Doc View Source netId Declaration public uint netId Field Value Type Description System.UInt32 Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.Channels.html": {
    "href": "api/Mirror.Channels.html",
    "title": "Class Channels",
    "keywords": "Class Channels Inheritance System.Object Channels Namespace : Mirror Assembly : doc.dll Syntax public static class Channels : object Fields | Improve this Doc View Source DefaultReliable Declaration public const int DefaultReliable = null Field Value Type Description System.Int32 | Improve this Doc View Source DefaultUnreliable Declaration public const int DefaultUnreliable = null Field Value Type Description System.Int32"
  },
  "api/Mirror.CommandMessage.html": {
    "href": "api/Mirror.CommandMessage.html",
    "title": "Struct CommandMessage",
    "keywords": "Struct CommandMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct CommandMessage : IMessageBase Fields | Improve this Doc View Source componentIndex Declaration public int componentIndex Field Value Type Description System.Int32 | Improve this Doc View Source functionHash Declaration public int functionHash Field Value Type Description System.Int32 | Improve this Doc View Source netId Declaration public uint netId Field Value Type Description System.UInt32 | Improve this Doc View Source payload Declaration public ArraySegment<byte> payload Field Value Type Description ArraySegment < System.Byte > Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.PlayerSpawnMethod.html": {
    "href": "api/Mirror.PlayerSpawnMethod.html",
    "title": "Enum PlayerSpawnMethod",
    "keywords": "Enum PlayerSpawnMethod Enumeration of methods of where to spawn player objects in multiplayer games. Namespace : Mirror Assembly : doc.dll Syntax public enum PlayerSpawnMethod : int Fields Name Description Random RoundRobin"
  },
  "api/Mirror.ReadyMessage.html": {
    "href": "api/Mirror.ReadyMessage.html",
    "title": "Struct ReadyMessage",
    "keywords": "Struct ReadyMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct ReadyMessage : IMessageBase Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.NetworkPingMessage.html": {
    "href": "api/Mirror.NetworkPingMessage.html",
    "title": "Struct NetworkPingMessage",
    "keywords": "Struct NetworkPingMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct NetworkPingMessage : IMessageBase Constructors | Improve this Doc View Source NetworkPingMessage(Double) Declaration public NetworkPingMessage(double value) Parameters Type Name Description System.Double value Fields | Improve this Doc View Source clientTime Declaration public double clientTime Field Value Type Description System.Double Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.Tcp.Server.html": {
    "href": "api/Mirror.Tcp.Server.html",
    "title": "Class Server",
    "keywords": "Class Server Inheritance System.Object Common Server Inherited Members Common.BytesToInt(Byte[]) Common.WriteSize(Int32, Byte[]) Common.SendMessage(NetworkStream, ArraySegment<Byte>) Common.SendMessage(NetworkStream, MemoryStream) Common.ReadMessageAsync(Stream) Namespace : Mirror.Tcp Assembly : doc.dll Syntax public class Server : Common Fields | Improve this Doc View Source NoDelay Declaration public bool NoDelay Field Value Type Description System.Boolean Properties | Improve this Doc View Source Active Declaration public bool Active { get; } Property Value Type Description System.Boolean Methods | Improve this Doc View Source Disconnect(Int32) Declaration public bool Disconnect(int connectionId) Parameters Type Name Description System.Int32 connectionId Returns Type Description System.Boolean | Improve this Doc View Source Flush() Declaration public void Flush() | Improve this Doc View Source GetClient(Int32) Declaration public TcpClient GetClient(int connectionId) Parameters Type Name Description System.Int32 connectionId Returns Type Description TcpClient | Improve this Doc View Source GetClientAddress(Int32) Declaration public string GetClientAddress(int connectionId) Parameters Type Name Description System.Int32 connectionId Returns Type Description System.String | Improve this Doc View Source ListenAsync(Int32) Declaration public Task ListenAsync(int port) Parameters Type Name Description System.Int32 port Returns Type Description Task | Improve this Doc View Source NextConnectionId() Declaration public int NextConnectionId() Returns Type Description System.Int32 | Improve this Doc View Source Send(Int32, ArraySegment<Byte>) Declaration public void Send(int connectionId, ArraySegment<byte> data) Parameters Type Name Description System.Int32 connectionId ArraySegment < System.Byte > data | Improve this Doc View Source Stop() Declaration public void Stop() | Improve this Doc View Source ToString() Declaration public override string ToString() Returns Type Description System.String Events | Improve this Doc View Source Connected Declaration public event Action<int> Connected Event Type Type Description Action < System.Int32 > | Improve this Doc View Source Disconnected Declaration public event Action<int> Disconnected Event Type Type Description Action < System.Int32 > | Improve this Doc View Source ReceivedData Declaration public event Action<int, byte[]> ReceivedData Event Type Type Description Action < System.Int32 , System.Byte []> | Improve this Doc View Source ReceivedError Declaration public event Action<int, Exception> ReceivedError Event Type Type Description Action < System.Int32 , Exception >"
  },
  "api/Mirror.NetworkConnection.html": {
    "href": "api/Mirror.NetworkConnection.html",
    "title": "Class NetworkConnection",
    "keywords": "Class NetworkConnection A High level network connection. This is used for connections from client-to-server and for connection from server-to-client. Inheritance System.Object NetworkConnection NetworkConnectionToClient NetworkConnectionToServer Namespace : Mirror Assembly : doc.dll Syntax public abstract class NetworkConnection : IDisposable Remarks A NetworkConnection corresponds to a specific connection for a host in the transport layer. It has a connectionId that is assigned by the transport layer and passed to the Initialize function. A NetworkClient has one NetworkConnection. A NetworkServerSimple manages multiple NetworkConnections. The NetworkServer has multiple \"remote\" connections and a \"local\" connection for the local client. The NetworkConnection class provides message sending and handling facilities. For sending data over a network, there are methods to send message objects, byte arrays, and NetworkWriter objects. To handle data arriving from the network, handler functions can be registered for message Ids, byte arrays can be processed by HandleBytes(), and NetworkReader object can be processed by HandleReader(). NetworkConnection objects also act as observers for networked objects. When a connection is an observer of a networked object with a NetworkIdentity, then the object will be visible to corresponding client for the connection, and incremental state changes will be sent to the client. There are many virtual functions on NetworkConnection that allow its behaviour to be customized. NetworkClient and NetworkServer can both be made to instantiate custom classes derived from NetworkConnection by setting their networkConnectionClass member variable. Fields | Improve this Doc View Source authenticationData General purpose object to hold authentication data, character selection, tokens, etc. associated with the connection for reference after Authentication completes. Declaration public object authenticationData Field Value Type Description System.Object | Improve this Doc View Source clientOwnedObjects A list of the NetworkIdentity objects owned by this connection. This list is read-only. This includes the player object for the connection - if it has localPlayerAutority set, and any objects spawned with local authority or set with AssignLocalAuthority. This list can be used to validate messages from clients, to ensure that clients are only trying to control objects that they own. Declaration public readonly HashSet<NetworkIdentity> clientOwnedObjects Field Value Type Description HashSet < NetworkIdentity > | Improve this Doc View Source connectionId Unique identifier for this connection that is assigned by the transport layer. Declaration public readonly int connectionId Field Value Type Description System.Int32 Remarks On a server, this Id is unique for every connection on the server. On a client this Id is local to the client, it is not the same as the Id on the server for this connection. Transport layers connections begin at one. So on a client with a single connection to a server, the connectionId of that connection will be one. In NetworkServer, the connectionId of the local connection is zero. Clients do not know their connectionId on the server, and do not know the connectionId of other clients on the server. | Improve this Doc View Source isAuthenticated Flag that indicates the client has been authenticated. Declaration public bool isAuthenticated Field Value Type Description System.Boolean | Improve this Doc View Source isReady Flag that tells if the connection has been marked as \"ready\" by a client calling ClientScene.Ready(). This property is read-only. It is set by the system on the client when ClientScene.Ready() is called, and set by the system on the server when a ready message is received from a client. A client that is ready is sent spawned objects by the server and updates to the state of spawned objects. A client that is not ready is not sent spawned objects. Declaration public bool isReady Field Value Type Description System.Boolean | Improve this Doc View Source lastMessageTime The last time that a message was received on this connection. This includes internal system messages (such as Commands and ClientRpc calls) and user messages. Declaration public float lastMessageTime Field Value Type Description System.Single | Improve this Doc View Source logNetworkMessages Setting this to true will log the contents of network message to the console. Declaration public bool logNetworkMessages Field Value Type Description System.Boolean Remarks Warning: this can be a lot of data and can be very slow. Both incoming and outgoing messages are logged. The format of the logs is: ConnectionSend con:1 bytes:11 msgId:5 FB59D743FD120000000000 ConnectionRecv con:1 bytes:27 msgId:8 14F21000000000016800AC3FE090C240437846403CDDC0BD3B0000 Note that these are application-level network messages, not protocol-level packets. There will typically be multiple network messages combined in a single protocol packet. Properties | Improve this Doc View Source address The IP address / URL / FQDN associated with the connection. Can be useful for a game master to do IP Bans etc. Declaration public abstract string address { get; } Property Value Type Description System.String | Improve this Doc View Source identity The NetworkIdentity for this connection. Declaration public NetworkIdentity identity { get; } Property Value Type Description NetworkIdentity Methods | Improve this Doc View Source Disconnect() Disconnects this connection. Declaration public abstract void Disconnect() | Improve this Doc View Source Dispose() Disposes of this connection, releasing channel buffers that it holds. Declaration public void Dispose() | Improve this Doc View Source Dispose(Boolean) Declaration protected virtual void Dispose(bool disposing) Parameters Type Name Description System.Boolean disposing | Improve this Doc View Source Finalize() Declaration protected void Finalize() | Improve this Doc View Source InvokeHandler<T>(T, Int32) This function invokes the registered handler function for a message. Network connections used by the NetworkClient and NetworkServer use this function for handling network messages. Declaration public bool InvokeHandler<T>(T msg, int channelId) where T : IMessageBase Parameters Type Name Description T msg The message object to process. System.Int32 channelId Returns Type Description System.Boolean Type Parameters Name Description T The message type to unregister. | Improve this Doc View Source Send<T>(T, Int32) This sends a network message with a message ID on the connection. This message is sent on channel zero, which by default is the reliable channel. Declaration public bool Send<T>(T msg, int channelId = null) where T : IMessageBase Parameters Type Name Description T msg The message to send. System.Int32 channelId The transport layer channel to send on. Returns Type Description System.Boolean Type Parameters Name Description T The message type to unregister. | Improve this Doc View Source ToString() Declaration public override string ToString() Returns Type Description System.String | Improve this Doc View Source ValidatePacketSize(ArraySegment<Byte>, Int32) Declaration protected static bool ValidatePacketSize(ArraySegment<byte> segment, int channelId) Parameters Type Name Description ArraySegment < System.Byte > segment System.Int32 channelId Returns Type Description System.Boolean"
  },
  "api/Mirror.Websocket.Server.SslConfiguration.html": {
    "href": "api/Mirror.Websocket.Server.SslConfiguration.html",
    "title": "Class Server.SslConfiguration",
    "keywords": "Class Server.SslConfiguration Inheritance System.Object Server.SslConfiguration Namespace : Mirror.Websocket Assembly : doc.dll Syntax public class SslConfiguration : object Fields | Improve this Doc View Source Certificate Declaration public System.Security.Cryptography.X509Certificates.X509Certificate2 Certificate Field Value Type Description System.Security.Cryptography.X509Certificates.X509Certificate2 | Improve this Doc View Source CheckCertificateRevocation Declaration public bool CheckCertificateRevocation Field Value Type Description System.Boolean | Improve this Doc View Source ClientCertificateRequired Declaration public bool ClientCertificateRequired Field Value Type Description System.Boolean | Improve this Doc View Source EnabledSslProtocols Declaration public System.Security.Authentication.SslProtocols EnabledSslProtocols Field Value Type Description System.Security.Authentication.SslProtocols"
  },
  "api/Mirror.SyncListUInt.html": {
    "href": "api/Mirror.SyncListUInt.html",
    "title": "Class SyncListUInt",
    "keywords": "Class SyncListUInt Inheritance System.Object SyncList < System.UInt32 > SyncListUInt Implements IReadOnlyList < System.UInt32 > ISyncObject Inherited Members SyncList<UInt32>.Count SyncList<UInt32>.IsReadOnly SyncList<UInt32>.Callback SyncList<UInt32>.IsDirty SyncList<UInt32>.Flush() SyncList<UInt32>.OnSerializeAll(NetworkWriter) SyncList<UInt32>.OnSerializeDelta(NetworkWriter) SyncList<UInt32>.OnDeserializeAll(NetworkReader) SyncList<UInt32>.OnDeserializeDelta(NetworkReader) SyncList<UInt32>.Add(UInt32) SyncList<UInt32>.Clear() SyncList<UInt32>.Contains(UInt32) SyncList<UInt32>.CopyTo(UInt32[], Int32) SyncList<UInt32>.IndexOf(UInt32) SyncList<UInt32>.FindIndex(Predicate<UInt32>) SyncList<UInt32>.Insert(Int32, UInt32) SyncList<UInt32>.Remove(UInt32) SyncList<UInt32>.RemoveAt(Int32) SyncList<UInt32>.Item[Int32] SyncList<UInt32>.GetEnumerator() Namespace : Mirror Assembly : doc.dll Syntax public class SyncListUInt : SyncList<uint>, IReadOnlyList<uint>, ISyncObject Methods | Improve this Doc View Source DeserializeItem(NetworkReader) Declaration protected override uint DeserializeItem(NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description System.UInt32 Overrides Mirror.SyncList<System.UInt32>.DeserializeItem(Mirror.NetworkReader) | Improve this Doc View Source SerializeItem(NetworkWriter, UInt32) Declaration protected override void SerializeItem(NetworkWriter writer, uint item) Parameters Type Name Description NetworkWriter writer System.UInt32 item Overrides Mirror.SyncList<System.UInt32>.SerializeItem(Mirror.NetworkWriter, System.UInt32) Implements IReadOnlyList<> ISyncObject"
  },
  "api/Mirror.NetworkManagerMode.html": {
    "href": "api/Mirror.NetworkManagerMode.html",
    "title": "Enum NetworkManagerMode",
    "keywords": "Enum NetworkManagerMode Namespace : Mirror Assembly : doc.dll Syntax public enum NetworkManagerMode : int Fields Name Description ClientOnly Host Offline ServerOnly"
  }
}